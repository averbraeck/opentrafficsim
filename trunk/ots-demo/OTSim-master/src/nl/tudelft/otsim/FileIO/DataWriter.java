package nl.tudelft.otsim.FileIO;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;

import nl.tudelft.otsim.GUI.Main;
import nl.tudelft.otsim.GUI.Model;
import nl.tudelft.otsim.GeoObjects.CrossSection;
import nl.tudelft.otsim.GeoObjects.CrossSectionElement;
import nl.tudelft.otsim.GeoObjects.CrossSectionObject;
import nl.tudelft.otsim.GeoObjects.Lane;
import nl.tudelft.otsim.GeoObjects.Link;
import nl.tudelft.otsim.GeoObjects.Node;

public class DataWriter {

    static final String dataFileLinks = "Links";
    static final String dataFileNodes = "Nodes";
    static final String dataFileCategories = "Categories";

    public static void WriteData(String pathName, Model model) throws IOException {
    	FileWriter outputStream = null;    
    	String space = " ";
    	// Rewrite the model data to a Paramics format

    	// A Categories file with link templates
    	int borderSpeedHighway = 90;
    	int borderSpeedMajor = 40;
    	double speedCat[] = {30, 40, 50, 60, 70, 80, 90, 100, 120};
    	int lanesCat[] = {1, 2, 3, 4, 5};
    	String roadType1[] = {"urban", "highway"};
    	String roadType2[] = {"minor", "major"};
    	int catNumber = 0;
    	double width = 3.5;
    	int itelMajor = 0;
    	int itelHighway = 0;

        try {
        	outputStream = new FileWriter(pathName + "\\" + dataFileCategories);	 
	    	String line;
	    	for (int i = 0; i < speedCat.length; i++) {
	    		for (int j = 0; j < lanesCat.length; j++) {
	    			if (speedCat[i] > borderSpeedMajor) 
	    				itelMajor = 1;
	    			else
	    				itelMajor = 0;
	    			if (speedCat[i] > borderSpeedHighway) 
	    				itelHighway = 1;
	    			else
	    				itelHighway = 0;			
	    			catNumber++;
			    	line = "category ";
			    	line = line + Integer.toString(catNumber);
			    	line = line + space + "lanes: " + Integer.toString(lanesCat[j]);
			    	line = line + space + "speed: " + Double.toString(speedCat[i]);
			    	line = line + space + "width: " + Double.toString(lanesCat[j]* width) + space + "m";
			    	line = line + space + "type: " + roadType1[itelMajor] + space + roadType2[itelHighway];
			    	line = line + space + "cost factor" + space + "1.0";
			    	line = line + space + "colour: " + space + "0xb9ffff";
	    			outputStream.write(line + "\n");	
	    		}	
	    	}
        } finally {
        	outputStream.close();
        }	  

    	// Rewrite  links
        try {
        	outputStream = new FileWriter(pathName + "\\" + dataFileLinks);	 
	    	Collection<Link> links = Main.mainFrame.model.network.getLinkList();
	    	for (Link link : links) {
	    		if (! link.isAutoGenerated())   {
		    		boolean oneWay = true;
		    		for (Link link2 : links) {
		    	    	if ( link.getFromNode_r().equals(link2.getToNode_r()) && link.getToNode_r().equals(link2.getFromNode_r()) ) {
		    	    		oneWay = false;
		    	    	}
		    		}
		    		for (CrossSection cs : link.getCrossSections_r())  {
		    			for (CrossSectionElement cse : cs.getCrossSectionElementList_r())  {
		    				String name = cse.getCrossSectionElementTypology().getName_r();
		    				if (name.contentEquals("road"))  {
					    		double speed = link.getMaxSpeed_r();
					    		ArrayList<CrossSectionObject> lanes = cse.getCrossSectionObjects(Lane.class);
					    		int countLanes = lanes.size();
					    		catNumber = 0;
					    		int catNumberLink = 0;
					    		boolean breakLoop = false;
						    	for (int i = 0; i < speedCat.length; i++) {
					    			
						    		for (int j = 0; j < lanesCat.length; j++) {
						    			catNumber++;
						    			if (speedCat[i] > borderSpeedMajor) 
						    				itelMajor = 2;
						    			else
						    				itelMajor = 1;
						    			if (speedCat[i] > borderSpeedHighway) 
						    				itelHighway = 2;
						    			else
						    				itelHighway = 1;			
							    		if (speed >= speedCat[i]-5 && speed <  speedCat[i]+5)   {
							    			if (countLanes == lanesCat[j]) {
							    				breakLoop = true;
							    				catNumberLink = catNumber;
							    			}
							    		}
						    		}
						    	}

					    		String line;					    		
					    		line = "link" ;
					    		line = line + space + Integer.toString(link.getFromNode_r().getNodeID());
					    		line = line + space + Integer.toString(link.getToNode_r().getNodeID());
					    		line = line + space + "category " + Integer.toString(catNumberLink);
					    		line = line + space + "lanes " + Integer.toString(countLanes); 
					    		line = line + space + "speed " + Double.toString(speed); 
					    		outputStream.write(line + "\n");
		    				}
		    			}
		    		}		    		
		    		if (oneWay == true)   {
			    		String line;
			    		line = "link" ;
			    		line = line + space + Integer.toString(link.getToNode_r().getNodeID());
			    		line = line + space + Integer.toString(link.getFromNode_r().getNodeID());
			    		line = line + space + "barred";
		    			outputStream.write(line + "\n");
		    		}
	    		}		    		
	    	}
        } finally {
        	outputStream.close();
        }

        
    	// Rewrite nodes
        try {
        	outputStream = new FileWriter(pathName + "\\" + dataFileNodes);	 
	    	Collection<Node> nodes = Main.mainFrame.model.network.getNodeList(false);
    		double maxX  = Double.NEGATIVE_INFINITY;
    		double minX  = Double.POSITIVE_INFINITY;
    		double maxY  = Double.NEGATIVE_INFINITY;
    		double minY  = Double.POSITIVE_INFINITY;
	    	for (Node node : nodes) {
	    		if (node.getX() < minX)
	    			minX = node.getX();
	    		if (node.getX() > maxX)
	    			maxX = node.getX();
	    		if (node.getY() < minY)
	    			minY = node.getX();
	    		if (node.getY() > maxY)
	    			maxY = node.getX();
	    	}
	    	String line;
    		line = "Bounding Box";
    		line = line + space + Double.toString(minX);
    		line = line + space + Double.toString(minY);
    		line = line + space + Double.toString(maxX);
    		line = line + space + Double.toString(maxY);
    		outputStream.write(line + "\n");
    		
	    	for (Node node : nodes) {
	    		line = "";					    		
	    		line = line + "node" ;
	    		line = line + space + Integer.toString(node.getNodeID());
	    		line = line + space + "at";
	    		line = line + space + Double.toString((node.getX() != Double.NaN) ? node.getX() : 0.0 );
	    		line = line + space + "m ,";
	    		line = line + space + Double.toString((node.getY() != Double.NaN) ? node.getY() : 0.0 );
	    		line = line + space + "m ,";
	    		line = line + space + Double.toString( ( Double.isNaN(node.getZ()) ) ? 0.0 : node.getZ() );
	    		line = line + space + "m";
	    		line = line + space + "junction";
	    		outputStream.write(line + "\n");		    		
	    	}
        } finally {
        	outputStream.close();
        }
    }
}