package org.opentrafficsim.graphs;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Paint;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Point2D;

import javax.swing.JFrame;
import javax.swing.JLabel;

import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.event.PlotChangeEvent;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.PaintScale;
import org.jfree.chart.renderer.xy.XYBlockRenderer;
import org.jfree.data.xy.DefaultXYZDataset;
import org.jfree.data.xy.XYDataset;
import org.jfree.data.xy.XYZDataset;
import org.jfree.ui.RefineryUtilities;

/**
 * <p>
 * Copyright (c) 2002-2014 Delft University of Technology, Jaffalaan 5, 2628 BX Delft, the Netherlands. All rights
 * reserved.
 * <p>
 * See for project information <a href="http://www.simulation.tudelft.nl/"> www.simulation.tudelft.nl</a>.
 * <p>
 * The OpenTrafficSim project is distributed under the following BSD-style license:<br>
 * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
 * following conditions are met:
 * <ul>
 * <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following
 * disclaimer.</li>
 * <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
 * following disclaimer in the documentation and/or other materials provided with the distribution.</li>
 * <li>Neither the name of Delft University of Technology, nor the names of its contributors may be used to endorse or
 * promote products derived from this software without specific prior written permission.</li>
 * </ul>
 * This software is provided by the copyright holders and contributors "as is" and any express or implied warranties,
 * including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are
 * disclaimed. In no event shall the copyright holder or contributors be liable for any direct, indirect, incidental,
 * special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or
 * services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability,
 * whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use
 * of this software, even if advised of the possibility of such damage.
 * @version Jul 16, 2014 <br>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class ContourPlot extends JFrame implements MouseMotionListener
{
    // TODO: make this class work with data generated by a simulator
    /** */
    private static final long serialVersionUID = 20140716L;

    /** The ChartPanel for this ContourPlot */
    protected final ChartPanel chartPanel;

    /** Area to show status information */
    protected final JLabel statusLabel;

    /** Time granularity in seconds */
    protected double timeGranularity = 1;

    /** Distance granularity in meters */
    protected double distanceGranularity = 1;

    /**
     * Create a new ContourPlot
     * @param caption
     */
    public ContourPlot(String caption)
    {
        this.setLayout(new BorderLayout());
        this.chartPanel =
                new ChartPanel(createChart(caption, "\u2192 Distance", ", density %.1f veh/km", createDataset()));
        this.chartPanel.setPreferredSize(new java.awt.Dimension(500, 270));
        this.chartPanel.addMouseMotionListener(this);
        this.add(this.chartPanel, BorderLayout.CENTER);
        this.statusLabel = new JLabel(" ");
        this.add(this.statusLabel, BorderLayout.SOUTH);
    }

    /**
     * Create a demo data set
     * @return XYZDataset with demo data
     */
    private static XYZDataset createDataset()
    {
        double[] xvalues = new double[14 * 60];
        double[] yvalues = new double[14 * 60];
        double[] zvalues = new double[14 * 60];
        double[][] data = new double[][]{xvalues, yvalues, zvalues};

        // set the default z-value to zero throughout the data array.
        for (int c = 0; c < 60; c++)
        {
            for (int r = 8; r < 22; r++)
            {
                setValue(data, c, r, 0.0);
            }
        }

        for (int r = 8; r < 12; r++)
        {
            for (int c = 13; c < 48; c++)
            {
                setValue(data, c, r, 1.0);
            }
        }
        for (int r = 12; r < 20; r++)
        {
            for (int c = 23; c < 43; c++)
            {
                setValue(data, c, r, 1.0);
            }
        }
        setValue(data, 2, 20, 2);
        setValue(data, 5, 20, 3);
        setValue(data, 6, 20, 3);
        setValue(data, 7, 20, 3);
        setValue(data, 8, 20, 3);
        setValue(data, 9, 20, 3);
        setValue(data, 11, 20, 3);
        setValue(data, 17, 20, 2);
        setValue(data, 18, 20, 2);
        setValue(data, 19, 20, 2);
        setValue(data, 20, 20, 2);
        setValue(data, 22, 20, 2);
        setValue(data, 25, 20, 2);
        setValue(data, 28, 20, 2);
        setValue(data, 35, 20, 2);
        for (int c = 40; c < 60; c++)
        {
            setValue(data, c, 20, 3.0);
        }

        for (int c = 23; c < 43; c++)
        {
            setValue(data, c, 21, 1.0);
        }
        DefaultXYZDataset dataset = new DefaultXYZDataset();
        dataset.addSeries("Series 1", data);
        return dataset;
    }

    /**
     * Utility method called by createDataset().
     * @param data the data array.
     * @param c the column.
     * @param r the row.
     * @param value the value.
     */
    private static void setValue(double[][] data, int c, int r, double value)
    {

        data[0][(r - 8) * 60 + c] = c;
        data[1][(r - 8) * 60 + c] = r;
        data[2][(r - 8) * 60 + c] = value;

    }

    /**
     * Create a XYBlockChart.
     * @param caption String; text to show above the chart
     * @param contourType String; type of value plotted in the chart
     * @param valueFormat String; format string used to render the value in the status bar
     * @param dataset XYZDataset with the values to render
     * @return JFreeChart; the new XYBlockChart
     */
    private static JFreeChart createChart(String caption, String contourType, String valueFormat, XYZDataset dataset)
    {
        NumberAxis xAxis = new NumberAxis("\u2192 time");
        xAxis.setLowerMargin(0.0);
        xAxis.setUpperMargin(0.0);
        NumberAxis yAxis = new NumberAxis(contourType);
        yAxis.setAutoRangeIncludesZero(false);
        yAxis.setInverted(true);
        yAxis.setLowerMargin(0.0);
        yAxis.setUpperMargin(0.0);
        yAxis.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
        XYBlockRenderer renderer = new XYBlockRenderer();
        double[] colorBoundaries = {0.0, 1.0, 2.0, 3.0};
        Color[] colorValues = {Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE};
        ColorPaintScale paintScale = new ColorPaintScale(valueFormat, colorBoundaries, colorValues);
        renderer.setPaintScale(paintScale);
        XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer);
        plot.setBackgroundPaint(Color.lightGray);
        plot.setDomainGridlinePaint(Color.white);
        plot.setRangeGridlinePaint(Color.white);
        plot.setForegroundAlpha(0.66f);
        JFreeChart chart = new JFreeChart(caption, plot);
        chart.removeLegend();
        chart.setBackgroundPaint(Color.white);
        return chart;
    }

    /**
     * Create a continuous color paint scale for the contour plots.
     * <p>
     * Copyright (c) 2002-2014 Delft University of Technology, Jaffalaan 5, 2628 BX Delft, the Netherlands. All rights
     * reserved.
     * <p>
     * See for project information <a href="http://www.simulation.tudelft.nl/"> www.simulation.tudelft.nl</a>.
     * <p>
     * The OpenTrafficSim project is distributed under the following BSD-style license:<br>
     * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the
     * following conditions are met:
     * <ul>
     * <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the
     * following disclaimer.</li>
     * <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
     * following disclaimer in the documentation and/or other materials provided with the distribution.</li>
     * <li>Neither the name of Delft University of Technology, nor the names of its contributors may be used to endorse
     * or promote products derived from this software without specific prior written permission.</li>
     * </ul>
     * This software is provided by the copyright holders and contributors "as is" and any express or implied
     * warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular
     * purpose are disclaimed. In no event shall the copyright holder or contributors be liable for any direct,
     * indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of
     * substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any
     * theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising
     * in any way out of the use of this software, even if advised of the possibility of such damage.
     * @version Jul 16, 2014 <br>
     * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
     */
    static class ColorPaintScale implements PaintScale
    {
        /** Boundary values for this ColorPaintScale */
        private double[] bounds;

        /** Color values to use at the boundary values */
        private Color[] boundColors;

        /** Format string to render values in a human readable format (used in tool tip texts) */
        final String format;

        /**
         * Create a new ColorPaintScale.
         * @param format Format string to render the value under the mouse in a human readable format
         * @param bounds Double[] array of boundary values (must be ordered by increasing value)
         * @param boundColors Color[] array of the colors to use at the boundary values
         */
        ColorPaintScale(String format, double bounds[], Color boundColors[])
        {
            this.format = format;
            if (bounds.length < 2)
                throw new Error("bounds must have >= 2 entries");
            if (bounds.length != boundColors.length)
                throw new Error("bounds must have same length as boundColors");
            for (int i = 1; i < bounds.length; i++)
                if (bounds[i] - bounds[i - 1] <= 0)
                    throw new Error("bounds values must be strictly ascending");
            this.bounds = bounds;
            this.boundColors = boundColors;
        }

        @Override
        public double getLowerBound()
        {
            return this.bounds[0];
        }

        /**
         * Create a mixed color. Depending on the value of ratio the result varies from <i>low</i> to <i>high</i>.
         * @param ratio Double; value between 0.0 and 1.0.
         * @param low Integer; this value is returned when ratio equals 0.0
         * @param high Integer; this value is returned when ratio equals 1.0
         * @return Integer; the ratio-weighted average of <i>low</i> and <i>high</i>
         */
        private static int mixComponent(double ratio, int low, int high)
        {
            double mix = low * (1 - ratio) + high * ratio;
            int result = (int) mix;
            if (result < 0)
                result = 0;
            if (result > 255)
                result = 255;
            return result;
        }

        @Override
        public Paint getPaint(double value)
        {
            int bucket;
            for (bucket = 0; bucket < this.bounds.length - 1; bucket++)
                if (value < this.bounds[bucket + 1])
                    break;
            if (bucket >= this.bounds.length - 1)
                bucket = this.bounds.length - 2;
            double ratio = (value - this.bounds[bucket]) / (this.bounds[bucket + 1] - this.bounds[bucket]);

            Color mix =
                    new Color(mixComponent(ratio, this.boundColors[bucket].getRed(),
                            this.boundColors[bucket + 1].getRed()), mixComponent(ratio,
                            this.boundColors[bucket].getGreen(), this.boundColors[bucket + 1].getGreen()),
                            mixComponent(ratio, this.boundColors[bucket].getBlue(),
                                    this.boundColors[bucket + 1].getBlue()));
            return mix;
        }

        @Override
        public double getUpperBound()
        {
            return this.bounds[this.bounds.length - 1];
        }

    }

    /**
     * @see java.awt.event.MouseMotionListener#mouseDragged(java.awt.event.MouseEvent)
     */
    @Override
    public void mouseDragged(MouseEvent e)
    {
        // not used
    }

    /**
     * @see java.awt.event.MouseMotionListener#mouseMoved(java.awt.event.MouseEvent)
     */
    @Override
    public void mouseMoved(MouseEvent mouseEvent)
    {
        ChartPanel cp = (ChartPanel) mouseEvent.getSource();
        XYPlot plot = (XYPlot) cp.getChart().getPlot();
        boolean showCrossHair = cp.getScreenDataArea().contains(mouseEvent.getPoint());
        if (cp.getHorizontalAxisTrace() != showCrossHair)
        {
            cp.setHorizontalAxisTrace(showCrossHair);
            cp.setVerticalAxisTrace(showCrossHair);
            plot.notifyListeners(new PlotChangeEvent(plot));
        }
        if (showCrossHair)
        {
            Point2D p = cp.translateScreenToJava2D(mouseEvent.getPoint());
            PlotRenderingInfo pi = cp.getChartRenderingInfo().getPlotInfo();
            double t = plot.getDomainAxis().java2DToValue(p.getX(), pi.getDataArea(), plot.getDomainAxisEdge());
            double distance = plot.getRangeAxis().java2DToValue(p.getY(), pi.getDataArea(), plot.getRangeAxisEdge());
            XYDataset dataset = plot.getDataset();
            String value = "";
            for (int item = dataset.getItemCount(0); --item >= 0;)
            {
                double x = dataset.getXValue(0, item);
                if ((x + this.timeGranularity / 2 < t) || (x - this.timeGranularity / 2 >= t))
                    continue;
                double y = dataset.getYValue(0, item);
                if ((y + this.distanceGranularity / 2 < distance) || (y - this.timeGranularity / 2 >= distance))
                    continue;
                double valueUnderMouse = ((XYZDataset) dataset).getZValue(0, item);
                if (Double.isNaN(valueUnderMouse))
                    continue;
                String format = ((ColorPaintScale) (((XYBlockRenderer) (plot.getRenderer(0))).getPaintScale())).format;
                value = String.format(format, valueUnderMouse);
            }
            this.statusLabel.setText(String.format("time %.0fs, distance %.0fm%s", t, distance, value));
        }
        else
            this.statusLabel.setText(" ");
    }

    /**
     * Main for stand alone running
     * @param args
     */
    public static void main(String[] args)
    {
        ContourPlot cp = new ContourPlot("Density Contour Graph");
        cp.setTitle("Stand-alone demo of Density Contour Graph");
        cp.setPreferredSize(new java.awt.Dimension(500, 270));
        cp.pack();
        RefineryUtilities.centerFrameOnScreen(cp);
        cp.setVisible(true);
    }

}
