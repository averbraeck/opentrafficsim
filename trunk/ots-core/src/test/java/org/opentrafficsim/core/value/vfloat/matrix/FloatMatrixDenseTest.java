package org.opentrafficsim.core.value.vfloat.matrix;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;


import org.junit.Test;
import org.opentrafficsim.core.unit.LengthUnit;
import org.opentrafficsim.core.unit.TemperatureUnit;
import org.opentrafficsim.core.unit.Unit;
import org.opentrafficsim.core.value.ValueException;
import org.opentrafficsim.core.value.vfloat.scalar.FloatScalar;

/**
 * Test the FloatMatrix class.
 * <p>
 * This file was generated by the OpenTrafficSim value test classes generator, 26 jun, 2015
 * <p>
 * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 26 jun, 2015 <br>
 * @author <a href="http://www.tbm.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class FloatMatrixDenseTest
{
    /**
     * Generate test data.
     * @param rows int; the number of rows in the result
     * @param columns int; the number of columns in the result
     * @param nonRectangular boolean; if true; return a non-rectangular array; if false; return a rectangular array
     * @param startValue float; seed value
     * @return float[][]
     */
    private static float[][] data(final int rows, final int columns, final boolean nonRectangular,
            final float startValue)
    {
        float[][] result = new float[rows][];
        final int badRowIndex = nonRectangular ? rows - 1 : -1;
        for (int row = 0; row < rows; row++)
        {
            result[row] = new float[row == badRowIndex ? columns + 1 : columns];
            for (int column = 0; column < result[row].length; column++)
            {
                result[row][column] = row * 1000 + column + startValue;
            }
        }
        return result;
    }

    /**
     * Check that the values in a FloatMatrixmatch the expected values.
     * @param fm FloatMatrix&lt;?&gt;; the FloatMatrix to match
     * @param reference float[][]; the reference values
     * @param precision float; the maximum allowed error
     * @param u Unit&lt;?&gt;; the expected type
     * @param expectAbsolute boolean; if true; fm should be Absolute; if false; fm should be Relative
     */
    private static void checkContentsAndType(final FloatMatrix<?> fm, final float[][] reference, final float precision,
            final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue("FloatMatrix should not be null", null != fm);
        for (int row = fm.rows(); --row >= 0;)
        {
            for (int column = fm.columns(); --column >= 0;)
                {
                try
                {
                    assertEquals("Value should match", reference[row][column], fm.getInUnit(row, column), precision);
                }
                catch (ValueException exception)
                {
                    fail("Unexpected exception");
                }
            }
        }
        assertEquals("Unit should be " + u.toString(), u, fm.getUnit());
        assertTrue("Should be " + (expectAbsolute ? "Absolute" : "Relative"), 
                    expectAbsolute ? fm.isAbsolute() : fm.isRelative());
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringAbsTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
            float[][] value = data(3, 5, false, 38.0f);
            FloatMatrix.Abs.Dense<TemperatureUnit> fm = new FloatMatrix.Abs.Dense<TemperatureUnit>(value, tempUnit);
            String result = fm.toString(true, true);
            assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableAbsTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
            float[][] value = data(3, 5, false, 38.0f);
            MutableFloatMatrix.Abs.Dense<TemperatureUnit> fm = new MutableFloatMatrix.Abs.Dense<TemperatureUnit>(value, tempUnit);
            String result = fm.toString(true, true);
            assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings({"static-method", "unchecked"})
    @Test
    public final void basicsAbsTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            float[][] value = data(3, 5, false, 38.0f);
            FloatMatrix.Abs.Dense<TemperatureUnit> temperatureFM = new FloatMatrix.Abs.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(temperatureFM, value, 0.001f, tempUnit, true);
            assertEquals("Value in SI is equivalent in Kelvin", 311.15f, temperatureFM.getSI(0, 0), 0.05);
            assertEquals("Value in Fahrenheit", 100.4f, temperatureFM.getInUnit(0, 0, TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
            float[][] out = temperatureFM.getValuesInUnit();
            for (int row = 0; row < value.length; row++)
            {
                for (int column = 0; column < value[row].length; column++)
                {
                    assertEquals("Value should match", value[row][column], out[row][column], 0.001);
                }
            }
            MutableFloatMatrix.Abs.Dense<TemperatureUnit> mfm = new MutableFloatMatrix.Abs.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, true);
            mfm.setSI(0, 0, 73);
            float safe = value[0][0];
            value[0][0] = -200; // Approximate Celsius equivalent of 73 Kelvin
            checkContentsAndType(mfm, value, 1, tempUnit, true);
            value[0][0] = safe; // Restore
            mfm.set(0, 0, temperatureFM.get(0, 0));
            checkContentsAndType(mfm, value, 0.001f, tempUnit, true);
            FloatMatrix.Abs.Dense<TemperatureUnit> temperature2FM = new FloatMatrix.Abs.Dense<TemperatureUnit>(temperatureFM.getMatrixSI(), TemperatureUnit.KELVIN);
            assertTrue("temperature2FM should be equal to temperatureFM", temperature2FM.equals(temperatureFM));
            assertTrue("Value is Absolute", temperatureFM.isAbsolute());
            assertFalse("Value is not Relative", temperatureFM.isRelative());
            temperatureFM = new FloatMatrix.Abs.Dense<TemperatureUnit>(value, TemperatureUnit.KELVIN);
            checkContentsAndType(temperatureFM, value, 0.001f, TemperatureUnit.KELVIN, true);
            out = temperatureFM.getValuesSI();
            for (int row = 0; row < value.length; row++)
            {
                for (int column = 0; column < value[row].length; column++)
                {
                    assertEquals("Value should match", value[row][column], out[row][column], 0.001);
                }
            }
            FloatScalar.Abs<TemperatureUnit>[][] scalar = new FloatScalar.Abs[value.length][];
        for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.Abs[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    scalar[row][column] = new FloatScalar.Abs<TemperatureUnit>(value[row][column], TemperatureUnit.DEGREE_CELSIUS);
                }
            }
            temperatureFM = new FloatMatrix.Abs.Dense<TemperatureUnit>(scalar);
            checkContentsAndType(temperatureFM, value, 0.001f, tempUnit, true);
            assertEquals("All cells != 0; cardinality should equal number of cells", value.length * value[0].length, temperatureFM.cardinality());
            float sum = 0;
            for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.Abs[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    sum += temperatureFM.getSI(row, column);
                }
            }
            assertEquals("zSum should be sum of all values", sum, temperatureFM.zSum(), 0.001);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackAbsTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            float[][] value = data(3, 5, false, 38.0f);
            float[][] value2 = data(3, 5, false, 38.0f);
            value2[0][0] = 12345;
            FloatMatrix.Abs.Dense<TemperatureUnit> fm = new FloatMatrix.Abs.Dense<TemperatureUnit>(value, tempUnit);
            FloatMatrix.Abs<TemperatureUnit> fmCopy = fm.copy();
            MutableFloatMatrix.Abs.Dense<TemperatureUnit> mfm = fm.mutable();
            checkContentsAndType(fm, value, 0.001f, tempUnit, true);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, true);
            checkContentsAndType(fmCopy, value, 0.001f, tempUnit, true);
            MutableFloatMatrix.Abs.Dense<TemperatureUnit> mfmCopy = mfm.copy();
            checkContentsAndType(mfmCopy, value, 0.001f, tempUnit, true);
            MutableFloatMatrix.Abs.Dense<TemperatureUnit> mmfm = mfm.mutable();
            checkContentsAndType(mmfm, value, 0.001f, tempUnit, true);
            assertEquals("hashCode is independent on mutability", fm.hashCode(), mfm.hashCode());
            // Modify mfm
            mfm.setInUnit(0, 0, 12345, TemperatureUnit.DEGREE_CELSIUS);
            checkContentsAndType(fm, value, 0.001f, tempUnit, true);
            checkContentsAndType(mfm, value2, 0.01f, tempUnit, true);
            checkContentsAndType(mfmCopy, value, 0.001f, tempUnit, true);
            checkContentsAndType(mmfm, value, 0.001f, tempUnit, true);
            FloatMatrix.Abs<TemperatureUnit> ifm = mfm.immutable();
            assertTrue("Different value extremely likely results in different hashCode", fm.hashCode() != mfm.hashCode());
            // Restore value of mfm
            mfm.setSI(0, 0, fm.getSI(0, 0));
            checkContentsAndType(ifm, value2, 0.01f, tempUnit, true);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, true);
            checkContentsAndType(mmfm, value, 0.001f, tempUnit, true);
            mmfm.setSI(0, 0, 0);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, true);
            assertEquals("value should be about -273", -273, mmfm.getInUnit(0, 0, tempUnit), 0.2);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        float value = 38.0f;
        FloatScalar.Abs<LengthUnit> fm = new FloatScalar.Abs<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", fm.equals(fm));
        assertFalse("Not equal to null", fm.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", fm.equals(new String("abc")));
        FloatScalar.Rel<LengthUnit> fmCounterPart = new FloatScalar.Rel<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", fm.equals(fmCounterPart));
        FloatScalar.Abs<TemperatureUnit> fmWrongBaseUnit = new FloatScalar.Abs<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", fm.getSI(), fmWrongBaseUnit.getSI(), 0.0001f);
        assertFalse("Not equals because the standard SI unit differs", fm.equals(fmWrongBaseUnit));
        FloatScalar.Abs<LengthUnit> fmCompatibleUnit =
                new FloatScalar.Abs<LengthUnit>(38000.0f, LengthUnit.MILLIMETER);
        assertFalse("Units are different", fm.getUnit().equals(fmCompatibleUnit.getUnit()));
        assertTrue("equals returns true", fm.equals(fmCompatibleUnit));
        FloatScalar.Abs<LengthUnit> fmDifferentValue =
                new FloatScalar.Abs<LengthUnit>(123.456f, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", fm.equals(fmDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        float[] seedValues = {-10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f};
        for (float seedValue : seedValues)
        {
            float[][] input = data(3, 5, false, seedValue);
            MutableFloatMatrix.Abs.Dense<LengthUnit> fm;
            try
            {
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.abs();
                MathTester.tester(input, "abs", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return Math.abs(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.acos();
                MathTester.tester(input, "acos", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.acos(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.asin();
                MathTester.tester(input, "asin", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.asin(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.atan();
                MathTester.tester(input, "atan", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.atan(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.cbrt();
                MathTester.tester(input, "cbrt", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.cbrt(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.ceil();
                MathTester.tester(input, "ceil", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.ceil(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.cos();
                MathTester.tester(input, "cos", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.cos(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.cosh();
                MathTester.tester(input, "cosh", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.cosh(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.exp();
                MathTester.tester(input, "exp", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.exp(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.expm1();
                MathTester.tester(input, "expm1", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.expm1(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.floor();
                MathTester.tester(input, "floor", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.floor(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.log();
                MathTester.tester(input, "log", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.log(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.log10();
                MathTester.tester(input, "log10", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.log10(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.log1p();
                MathTester.tester(input, "log1p", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.log1p(f);
                    }
                });
            for (int i = -10; i <= 10; i++)
            {
                final float exponent = i * 0.5f;
                    fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                    fm.pow(exponent);
                    MathTester.tester(input, "pow(" + exponent + ")", fm, 0.001, new FloatToFloat()
                    {
                        @Override
                        public float function(final float f)
                        {
                            return (float) Math.pow(f, exponent);
                        }
                    });
            }
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.rint();
                MathTester.tester(input, "rint", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.rint(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.round();
                MathTester.tester(input, "round", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return Math.round(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.signum();
                MathTester.tester(input, "signum", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return Math.signum(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.sin();
                MathTester.tester(input, "sin", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.sin(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.sinh();
                MathTester.tester(input, "sinh", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.sinh(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.sqrt();
                MathTester.tester(input, "sqrt", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.sqrt(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.tan();
                MathTester.tester(input, "tan", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.tan(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.tanh();
                MathTester.tester(input, "tanh", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.tanh(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.toDegrees();
                MathTester.tester(input, "toDegrees", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.toDegrees(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.toRadians();
                MathTester.tester(input, "toRadians", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.toRadians(f);
                    }
                });
                fm = new MutableFloatMatrix.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.inv();
                MathTester.tester(input, "inv", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return 1 / f;
                    }
                });
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected ValueException: " + ve.toString());
            }
        }
    }

    /**
     * Test plus(FloatMatrixAbs.Dense, FloatMatrixRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfAbsDenseAndRelDenseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Abs.Dense<LengthUnit> left = new FloatMatrix.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Dense<LengthUnit> right = new FloatMatrix.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Abs.Dense<?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements", left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(FloatMatrixAbs.Dense, FloatMatrixRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfAbsDenseAndRelDenseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Abs.Dense<LengthUnit> left = new FloatMatrix.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Dense<LengthUnit> right = new FloatMatrix.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Abs.Dense<?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements", left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(FloatMatrixAbs.Dense, FloatMatrixAbs.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfAbsDenseAndAbsDenseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Abs.Dense<LengthUnit> left = new FloatMatrix.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Abs.Dense<LengthUnit> right = new FloatMatrix.Abs.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Abs.Dense<?> result = FloatMatrix.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI times of contributing elements", left.getSI(i, j) * right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test plus(FloatMatrixAbs.Dense, FloatMatrixRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfAbsDenseAndRelSparseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Abs.Dense<LengthUnit> left = new FloatMatrix.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Sparse<LengthUnit> right = new FloatMatrix.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Abs.Dense<?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements", left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(FloatMatrixAbs.Dense, FloatMatrixRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfAbsDenseAndRelSparseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Abs.Dense<LengthUnit> left = new FloatMatrix.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Sparse<LengthUnit> right = new FloatMatrix.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Abs.Dense<?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements", left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(FloatMatrixAbs.Dense, FloatMatrixAbs.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfAbsDenseAndAbsSparseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Abs.Dense<LengthUnit> left = new FloatMatrix.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Abs.Sparse<LengthUnit> right = new FloatMatrix.Abs.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Abs.Sparse<?> result = FloatMatrix.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI times of contributing elements", left.getSI(i, j) * right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that malformed or mismatching arrays throw a ValueException.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void sizeCheckAbsTest()
    {
        int junk = 0;
        try
        {
            // null array
            new FloatMatrix.Abs.Dense<TemperatureUnit>((float[][]) null, TemperatureUnit.DEGREE_FAHRENHEIT);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on first row
            float[][] in = data(3, 5, false, 12.3f);
            in[0] = null;
            new FloatMatrix.Abs.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on last row
            float[][] in = data(3, 5, false, 12.3f);
            in[in.length - 1] = null;
            new FloatMatrix.Abs.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Non-rectangular array
            float[][] in = data(3, 5, true, 12.3f);
            new FloatMatrix.Abs.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        // Determinant of non-square Matrix
        float[][] in = data(3, 5, false, 12.3f);
        try
        {
            FloatMatrix.Abs.Dense<TemperatureUnit> matrix = null;
            try
            {
                matrix = new FloatMatrix.Abs.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected exception: " + ve.toString());
            }
            matrix.det();
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            FloatMatrix.Abs.Dense<TemperatureUnit> matrix = null;
            float[][] rowCountWrong = null;
            try
            {
                matrix = new FloatMatrix.Abs.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
                 rowCountWrong = data(4, 5, false, 2);
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected exception: " + ve.toString());
            }
            FloatMatrix.times(matrix, rowCountWrong);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        assertTrue("The variable junk is only used to suppress annoying warnings of the code checker", junk > 0);
    }

    /**
     * Test the det method that computes and returns the determinant.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void determinantAbsTest()
    {
        try
        {
            float[][] values = {{1, 2, 3 }, {3, 5, 7 }, {5, 10, 0} };
            FloatMatrix.Abs.Dense<TemperatureUnit> matrix = new FloatMatrix.Abs.Dense<TemperatureUnit>(values, TemperatureUnit.KELVIN);
            assertEquals("Determinant should be 15", 15, matrix.det(), 0.001);
        }
        catch (ValueException ve)
        {
            if (ve.toString().contains("Matrix must be sparse"))
            {
                System.err.println("Ignoring bug in COLT library");
                return;
            }
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that the times methods with a simple array as the 2nd argument.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void scaleAbsTest()
    {
        try
        {
            float[][] leftIn = data(3, 5, false, -12.34f);
            FloatMatrix.Abs.Dense<TemperatureUnit> left = new FloatMatrix.Abs.Dense<TemperatureUnit>(leftIn, TemperatureUnit.KELVIN);
            float[][] right = data(3, 5, false, -4.321f);
            MutableFloatMatrix.Abs.Dense<TemperatureUnit> result = FloatMatrix.times(left, right);
            assertEquals("Result should be in Kelvin", TemperatureUnit.KELVIN, result.getUnit());
            for (int row = right.length; --row >= 0;)
            {
                for (int column = right[row].length; --column >= 0;)
                {
                    assertEquals("Content should match product of left and right", leftIn[row][column] * right[row][column], result.getSI(row, column), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
            float[][] value = data(3, 5, false, 38.0f);
            FloatMatrix.Rel.Dense<TemperatureUnit> fm = new FloatMatrix.Rel.Dense<TemperatureUnit>(value, tempUnit);
            String result = fm.toString(true, true);
            assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
            float[][] value = data(3, 5, false, 38.0f);
            MutableFloatMatrix.Rel.Dense<TemperatureUnit> fm = new MutableFloatMatrix.Rel.Dense<TemperatureUnit>(value, tempUnit);
            String result = fm.toString(true, true);
            assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
            assertTrue("toString result contains \"K\"", result.contains("K"));
            assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
            assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings({"static-method", "unchecked"})
    @Test
    public final void basicsRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            float[][] value = data(3, 5, false, 38.0f);
            FloatMatrix.Rel.Dense<TemperatureUnit> temperatureFM = new FloatMatrix.Rel.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(temperatureFM, value, 0.001f, tempUnit, false);
            assertEquals("Value in SI is equivalent in Kelvin", 311.15f, temperatureFM.getSI(0, 0), 0.05);
            assertEquals("Value in Fahrenheit", 100.4f, temperatureFM.getInUnit(0, 0, TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
            float[][] out = temperatureFM.getValuesInUnit();
            for (int row = 0; row < value.length; row++)
            {
                for (int column = 0; column < value[row].length; column++)
                {
                    assertEquals("Value should match", value[row][column], out[row][column], 0.001);
                }
            }
            MutableFloatMatrix.Rel.Dense<TemperatureUnit> mfm = new MutableFloatMatrix.Rel.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, false);
            mfm.setSI(0, 0, 73);
            float safe = value[0][0];
            value[0][0] = -200; // Approximate Celsius equivalent of 73 Kelvin
            checkContentsAndType(mfm, value, 1, tempUnit, false);
            value[0][0] = safe; // Restore
            mfm.set(0, 0, temperatureFM.get(0, 0));
            checkContentsAndType(mfm, value, 0.001f, tempUnit, false);
            FloatMatrix.Rel.Dense<TemperatureUnit> temperature2FM = new FloatMatrix.Rel.Dense<TemperatureUnit>(temperatureFM.getMatrixSI(), TemperatureUnit.KELVIN);
            assertTrue("temperature2FM should be equal to temperatureFM", temperature2FM.equals(temperatureFM));
            assertTrue("Value is Relative", temperatureFM.isRelative());
            assertFalse("Value is not Absolute", temperatureFM.isAbsolute());
            temperatureFM = new FloatMatrix.Rel.Dense<TemperatureUnit>(value, TemperatureUnit.KELVIN);
            checkContentsAndType(temperatureFM, value, 0.001f, TemperatureUnit.KELVIN, false);
            out = temperatureFM.getValuesSI();
            for (int row = 0; row < value.length; row++)
            {
                for (int column = 0; column < value[row].length; column++)
                {
                    assertEquals("Value should match", value[row][column], out[row][column], 0.001);
                }
            }
            FloatScalar.Rel<TemperatureUnit>[][] scalar = new FloatScalar.Rel[value.length][];
        for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.Rel[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    scalar[row][column] = new FloatScalar.Rel<TemperatureUnit>(value[row][column], TemperatureUnit.DEGREE_CELSIUS);
                }
            }
            temperatureFM = new FloatMatrix.Rel.Dense<TemperatureUnit>(scalar);
            checkContentsAndType(temperatureFM, value, 0.001f, tempUnit, false);
            assertEquals("All cells != 0; cardinality should equal number of cells", value.length * value[0].length, temperatureFM.cardinality());
            float sum = 0;
            for (int row = 0; row < value.length; row++)
            {
                scalar[row] = new FloatScalar.Rel[value[row].length];
                for (int column = 0; column < value[row].length; column++)
                {
                    sum += temperatureFM.getSI(row, column);
                }
            }
            assertEquals("zSum should be sum of all values", sum, temperatureFM.zSum(), 0.001);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            float[][] value = data(3, 5, false, 38.0f);
            float[][] value2 = data(3, 5, false, 38.0f);
            value2[0][0] = 12345;
            FloatMatrix.Rel.Dense<TemperatureUnit> fm = new FloatMatrix.Rel.Dense<TemperatureUnit>(value, tempUnit);
            FloatMatrix.Rel<TemperatureUnit> fmCopy = fm.copy();
            MutableFloatMatrix.Rel.Dense<TemperatureUnit> mfm = fm.mutable();
            checkContentsAndType(fm, value, 0.001f, tempUnit, false);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, false);
            checkContentsAndType(fmCopy, value, 0.001f, tempUnit, false);
            MutableFloatMatrix.Rel.Dense<TemperatureUnit> mfmCopy = mfm.copy();
            checkContentsAndType(mfmCopy, value, 0.001f, tempUnit, false);
            MutableFloatMatrix.Rel.Dense<TemperatureUnit> mmfm = mfm.mutable();
            checkContentsAndType(mmfm, value, 0.001f, tempUnit, false);
            assertEquals("hashCode is independent on mutability", fm.hashCode(), mfm.hashCode());
            // Modify mfm
            mfm.setInUnit(0, 0, 12345, TemperatureUnit.DEGREE_CELSIUS);
            checkContentsAndType(fm, value, 0.001f, tempUnit, false);
            checkContentsAndType(mfm, value2, 0.01f, tempUnit, false);
            checkContentsAndType(mfmCopy, value, 0.001f, tempUnit, false);
            checkContentsAndType(mmfm, value, 0.001f, tempUnit, false);
            FloatMatrix.Rel<TemperatureUnit> ifm = mfm.immutable();
            assertTrue("Different value extremely likely results in different hashCode", fm.hashCode() != mfm.hashCode());
            // Restore value of mfm
            mfm.setSI(0, 0, fm.getSI(0, 0));
            checkContentsAndType(ifm, value2, 0.01f, tempUnit, false);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, false);
            checkContentsAndType(mmfm, value, 0.001f, tempUnit, false);
            mmfm.setSI(0, 0, 0);
            checkContentsAndType(mfm, value, 0.001f, tempUnit, false);
            assertEquals("value should be about -273", -273, mmfm.getInUnit(0, 0, tempUnit), 0.2);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        float value = 38.0f;
        FloatScalar.Rel<LengthUnit> fm = new FloatScalar.Rel<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", fm.equals(fm));
        assertFalse("Not equal to null", fm.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", fm.equals(new String("abc")));
        FloatScalar.Abs<LengthUnit> fmCounterPart = new FloatScalar.Abs<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", fm.equals(fmCounterPart));
        FloatScalar.Rel<TemperatureUnit> fmWrongBaseUnit = new FloatScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", fm.getSI(), fmWrongBaseUnit.getSI(), 0.0001f);
        assertFalse("Not equals because the standard SI unit differs", fm.equals(fmWrongBaseUnit));
        FloatScalar.Rel<LengthUnit> fmCompatibleUnit =
                new FloatScalar.Rel<LengthUnit>(38000.0f, LengthUnit.MILLIMETER);
        assertFalse("Units are different", fm.getUnit().equals(fmCompatibleUnit.getUnit()));
        assertTrue("equals returns true", fm.equals(fmCompatibleUnit));
        FloatScalar.Rel<LengthUnit> fmDifferentValue =
                new FloatScalar.Rel<LengthUnit>(123.456f, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", fm.equals(fmDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestRelTest()
    {
        float[] seedValues = {-10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f};
        for (float seedValue : seedValues)
        {
            float[][] input = data(3, 5, false, seedValue);
            MutableFloatMatrix.Rel.Dense<LengthUnit> fm;
            try
            {
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.abs();
                MathTester.tester(input, "abs", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return Math.abs(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.acos();
                MathTester.tester(input, "acos", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.acos(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.asin();
                MathTester.tester(input, "asin", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.asin(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.atan();
                MathTester.tester(input, "atan", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.atan(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.cbrt();
                MathTester.tester(input, "cbrt", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.cbrt(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.ceil();
                MathTester.tester(input, "ceil", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.ceil(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.cos();
                MathTester.tester(input, "cos", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.cos(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.cosh();
                MathTester.tester(input, "cosh", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.cosh(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.exp();
                MathTester.tester(input, "exp", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.exp(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.expm1();
                MathTester.tester(input, "expm1", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.expm1(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.floor();
                MathTester.tester(input, "floor", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.floor(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.log();
                MathTester.tester(input, "log", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.log(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.log10();
                MathTester.tester(input, "log10", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.log10(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.log1p();
                MathTester.tester(input, "log1p", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.log1p(f);
                    }
                });
            for (int i = -10; i <= 10; i++)
            {
                final float exponent = i * 0.5f;
                    fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                    fm.pow(exponent);
                    MathTester.tester(input, "pow(" + exponent + ")", fm, 0.001, new FloatToFloat()
                    {
                        @Override
                        public float function(final float f)
                        {
                            return (float) Math.pow(f, exponent);
                        }
                    });
            }
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.rint();
                MathTester.tester(input, "rint", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.rint(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.round();
                MathTester.tester(input, "round", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return Math.round(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.signum();
                MathTester.tester(input, "signum", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return Math.signum(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.sin();
                MathTester.tester(input, "sin", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.sin(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.sinh();
                MathTester.tester(input, "sinh", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.sinh(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.sqrt();
                MathTester.tester(input, "sqrt", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.sqrt(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.tan();
                MathTester.tester(input, "tan", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.tan(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.tanh();
                MathTester.tester(input, "tanh", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.tanh(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.toDegrees();
                MathTester.tester(input, "toDegrees", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.toDegrees(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.toRadians();
                MathTester.tester(input, "toRadians", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.toRadians(f);
                    }
                });
                fm = new MutableFloatMatrix.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                fm.inv();
                MathTester.tester(input, "inv", fm, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return 1 / f;
                    }
                });
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected ValueException: " + ve.toString());
            }
        }
    }

    /**
     * Test plus(FloatMatrixRel.Dense, FloatMatrixRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfRelDenseAndRelDenseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Rel.Dense<LengthUnit> left = new FloatMatrix.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Dense<LengthUnit> right = new FloatMatrix.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Rel.Dense<?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements", left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(FloatMatrixRel.Dense, FloatMatrixRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfRelDenseAndRelDenseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Rel.Dense<LengthUnit> left = new FloatMatrix.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Dense<LengthUnit> right = new FloatMatrix.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Rel.Dense<?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements", left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(FloatMatrixRel.Dense, FloatMatrixRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfRelDenseAndRelDenseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Rel.Dense<LengthUnit> left = new FloatMatrix.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Dense<LengthUnit> right = new FloatMatrix.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Rel.Dense<?> result = FloatMatrix.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI times of contributing elements", left.getSI(i, j) * right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test plus(FloatMatrixRel.Dense, FloatMatrixRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfRelDenseAndRelSparseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Rel.Dense<LengthUnit> left = new FloatMatrix.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Sparse<LengthUnit> right = new FloatMatrix.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Rel.Dense<?> result = FloatMatrix.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI plus of contributing elements", left.getSI(i, j) + right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(FloatMatrixRel.Dense, FloatMatrixRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfRelDenseAndRelSparseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Rel.Dense<LengthUnit> left = new FloatMatrix.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Sparse<LengthUnit> right = new FloatMatrix.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Rel.Dense<?> result = FloatMatrix.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI minus of contributing elements", left.getSI(i, j) - right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(FloatMatrixRel.Dense, FloatMatrixRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfRelDenseAndRelSparseTest()
    {
        try
        {
            float[][] leftValue = data(3, 5, false, 123.4f);
            float[][] rightValue = data(3, 5, false, 234.5f);
            FloatMatrix.Rel.Dense<LengthUnit> left = new FloatMatrix.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            FloatMatrix.Rel.Sparse<LengthUnit> right = new FloatMatrix.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableFloatMatrix.Rel.Sparse<?> result = FloatMatrix.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                for (int j = 0; j < leftValue[i].length; j++)
                {
                    assertEquals("value of element should be SI times of contributing elements", left.getSI(i, j) * right.getSI(i, j), result.getSI(i, j), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that malformed or mismatching arrays throw a ValueException.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void sizeCheckRelTest()
    {
        int junk = 0;
        try
        {
            // null array
            new FloatMatrix.Rel.Dense<TemperatureUnit>((float[][]) null, TemperatureUnit.DEGREE_FAHRENHEIT);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on first row
            float[][] in = data(3, 5, false, 12.3f);
            in[0] = null;
            new FloatMatrix.Rel.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Matrix with null on last row
            float[][] in = data(3, 5, false, 12.3f);
            in[in.length - 1] = null;
            new FloatMatrix.Rel.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            // Non-rectangular array
            float[][] in = data(3, 5, true, 12.3f);
            new FloatMatrix.Rel.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        // Determinant of non-square Matrix
        float[][] in = data(3, 5, false, 12.3f);
        try
        {
            FloatMatrix.Rel.Dense<TemperatureUnit> matrix = null;
            try
            {
                matrix = new FloatMatrix.Rel.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected exception: " + ve.toString());
            }
            matrix.det();
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        try
        {
            FloatMatrix.Rel.Dense<TemperatureUnit> matrix = null;
            float[][] rowCountWrong = null;
            try
            {
                matrix = new FloatMatrix.Rel.Dense<TemperatureUnit>(in, TemperatureUnit.DEGREE_CELSIUS);
                 rowCountWrong = data(4, 5, false, 2);
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected exception: " + ve.toString());
            }
            FloatMatrix.times(matrix, rowCountWrong);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        assertTrue("The variable junk is only used to suppress annoying warnings of the code checker", junk > 0);
    }

    /**
     * Test the det method that computes and returns the determinant.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void determinantRelTest()
    {
        try
        {
            float[][] values = {{1, 2, 3 }, {3, 5, 7 }, {5, 10, 0} };
            FloatMatrix.Rel.Dense<TemperatureUnit> matrix = new FloatMatrix.Rel.Dense<TemperatureUnit>(values, TemperatureUnit.KELVIN);
            assertEquals("Determinant should be 15", 15, matrix.det(), 0.001);
        }
        catch (ValueException ve)
        {
            if (ve.toString().contains("Matrix must be sparse"))
            {
                System.err.println("Ignoring bug in COLT library");
                return;
            }
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that the times methods with a simple array as the 2nd argument.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void scaleRelTest()
    {
        try
        {
            float[][] leftIn = data(3, 5, false, -12.34f);
            FloatMatrix.Rel.Dense<TemperatureUnit> left = new FloatMatrix.Rel.Dense<TemperatureUnit>(leftIn, TemperatureUnit.KELVIN);
            float[][] right = data(3, 5, false, -4.321f);
            MutableFloatMatrix.Rel.Dense<TemperatureUnit> result = FloatMatrix.times(left, right);
            assertEquals("Result should be in Kelvin", TemperatureUnit.KELVIN, result.getUnit());
            for (int row = right.length; --row >= 0;)
            {
                for (int column = right[row].length; --column >= 0;)
                {
                    assertEquals("Content should match product of left and right", leftIn[row][column] * right[row][column], result.getSI(row, column), 0.001f);
                }
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /** */
    interface FloatToFloat
    {
        /**
         * @param f float; value
         * @return float value
         */
        float function(float f);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValues float[][]; unprocessed value
         * @param operation String; description of method that is being tested
         * @param actualResult FloatMatrix&lt;?&gt;; the actual result of the operation
         * @param precision double; expected accuracy
         * @param function FloatToFloat; encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final float[][] inputValues, final String operation, final FloatMatrix<?> actualResult,
                final double precision, final FloatToFloat function)
        {
            for (int i = 0; i < inputValues.length; i++)
            {
                for (int j = 0; j < inputValues[i].length; j++)
                {
                    float expectedResult = function.function(inputValues[i][j]);
                    float got = 0;
                    try
                    {
                        got = actualResult.getSI(i, j);
                    }
                    catch (ValueException ve)
                    {
                        fail("Caught unexpected exception: " + ve.toString());
                    }
                    String description =
                            String.format("%s(%f->%f should be equal to %f with precision %f", operation, inputValues[i][j],
                                    expectedResult, got, precision);
                    // System.out.println(description);
                    assertEquals(description, expectedResult, got, precision);
                }
            }
        }

    }

}
