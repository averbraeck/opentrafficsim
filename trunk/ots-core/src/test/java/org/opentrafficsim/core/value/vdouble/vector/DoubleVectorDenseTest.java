package org.opentrafficsim.core.value.vdouble.vector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.Set;

import org.junit.Test;
import org.opentrafficsim.core.unit.AreaUnit;
import org.opentrafficsim.core.unit.LengthUnit;
import org.opentrafficsim.core.unit.SIUnit;
import org.opentrafficsim.core.unit.SpeedUnit;
import org.opentrafficsim.core.unit.TemperatureUnit;
import org.opentrafficsim.core.unit.TimeUnit;
import org.opentrafficsim.core.unit.Unit;
import org.opentrafficsim.core.value.Absolute;
import org.opentrafficsim.core.value.Relative;
import org.opentrafficsim.core.value.ValueException;
import org.opentrafficsim.core.value.vdouble.scalar.DoubleScalar;

/**
 * Test the DoubleVector class.
 * <p>
 * This file was generated by the OpenTrafficSim value test classes generator, 30 dec, 2014
 * <p>
 * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 30 dec, 2014 <br>
 * @author <a href="http://www.tbm.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class DoubleVectorDenseTest
{
    /**
     * Generate test data.
     * @param size int; number of values in the result
     * @param startValue double; seed value
     * @return double[]
     */
    private static double[] data(final int size, final double startValue)
    {
        double[] result = new double[size];
        for (int index = 0; index < size; index++)
        {
            result[index] = index + startValue;
        }
        return result;
    }

    /**
     * Check that the values in a DoubleVectormatch the expected values.
     * @param dv DoubleVector&lt;?&gt;; the DoubleVector to match
     * @param reference double[]; the reference values
     * @param precision double; the maximum allowed error
     * @param u Unit&lt;?&gt;; the expected type
     * @param expectAbsolute boolean; if true; dv should be Absolute; if false; dv should be Relative
     */
    private static void checkContentsAndType(final DoubleVector<?> dv, final double[] reference, final double precision,
            final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue("DoubleVector should not be null", null != dv);
        for (int index = dv.size(); --index >= 0;)
        {
            try
            {
                assertEquals("Value should match", reference[index], dv.getInUnit(index), precision);
            }
            catch (ValueException exception)
            {
                fail("Unexpected exception");
            }
        }
        assertEquals("Unit should be " + u.toString(), u, dv.getUnit());
        assertTrue("Should be " + (expectAbsolute ? "Absolute" : "Relative"), 
                    expectAbsolute ? dv.isAbsolute() : dv.isRelative());
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringAbsTest()
    {
        try
        {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double[] value = data(3, 38.0);
        DoubleVector.Abs.Dense<TemperatureUnit> dv = new DoubleVector.Abs.Dense<TemperatureUnit>(value, tempUnit);
        String result = dv.toString(true);
        assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
        assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableAbsTest()
    {
        try
        {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double[] value = data(3, 38.0);
        MutableDoubleVector.Abs.Dense<TemperatureUnit> dv = new MutableDoubleVector.Abs.Dense<TemperatureUnit>(value, tempUnit);
        String result = dv.toString(true);
        assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
        assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings({"static-method", "unchecked"})
    @Test
    public final void basicsAbsTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[] value = data(3, 38.0);
            DoubleVector.Abs.Dense<TemperatureUnit> temperatureDV = new DoubleVector.Abs.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(temperatureDV, value, 0.001, tempUnit, true);
            assertEquals("Value in SI is equivalent in Kelvin", 311.15, temperatureDV.getSI(0), 0.05);
            assertEquals("Value in Fahrenheit", 100.4, temperatureDV.getInUnit(0, TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
            double[] out = temperatureDV.getValuesInUnit();
            for (int index = 0; index < value.length; index++)
            {
                assertEquals("Value should match", value[index], out[index], 0.001);
            }
            MutableDoubleVector.Abs.Dense<TemperatureUnit> mdv = new MutableDoubleVector.Abs.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(mdv, value, 0.001, tempUnit, true);
            mdv.setSI(0, 73);
            double safe = value[0];
            value[0] = -200; // Approximate Celsius equivalent of 73 Kelvin
            checkContentsAndType(mdv, value, 1, tempUnit, true);
            value[0] = safe; // Restore
            mdv.set(0, temperatureDV.get(0));
            checkContentsAndType(mdv, value, 0.001, tempUnit, true);
            DoubleVector.Abs.Dense<TemperatureUnit> temperature2DV = new DoubleVector.Abs.Dense<TemperatureUnit>(temperatureDV.getVectorSI(), TemperatureUnit.KELVIN);
            assertTrue("temperature2DV should be equal to temperatureDV", temperature2DV.equals(temperatureDV));
            assertTrue("Value is Absolute", temperatureDV.isAbsolute());
            assertFalse("Value is not Relative", temperatureDV.isRelative());
            temperatureDV = new DoubleVector.Abs.Dense<TemperatureUnit>(value, TemperatureUnit.KELVIN);
            checkContentsAndType(temperatureDV, value, 0.001, TemperatureUnit.KELVIN, true);
            out = temperatureDV.getValuesSI();
            for (int index = 0; index < value.length; index++)
            {
                assertEquals("Value should match", value[index], out[index], 0.001);
            }
            DoubleScalar.Abs<TemperatureUnit>[] scalar = new DoubleScalar.Abs[value.length];
        for (int index = 0; index < value.length; index++)
            {
                scalar[index] = new DoubleScalar.Abs<TemperatureUnit>(value[index], TemperatureUnit.DEGREE_CELSIUS);
            }
            temperatureDV = new DoubleVector.Abs.Dense<TemperatureUnit>(scalar);
            checkContentsAndType(temperatureDV, value, 0.001, tempUnit, true);
            assertEquals("All cells != 0; cardinality should equal number of cells", value.length, temperatureDV.cardinality());
            double sum = 0;
            for (int index = 0; index < value.length; index++)
            {
                sum += temperatureDV.getSI(index);
            }
            assertEquals("zSum should be sum of all values", sum, temperatureDV.zSum(), 0.001);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackAbsTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[] value = data(3, 38.0);
            double[] value2 = data(3, 38.0);
            value2[0] = 12345;
            DoubleVector.Abs.Dense<TemperatureUnit> dv = new DoubleVector.Abs.Dense<TemperatureUnit>(value, tempUnit);
            DoubleVector.Abs<TemperatureUnit> dvCopy = dv.copy();
            MutableDoubleVector.Abs.Dense<TemperatureUnit> mdv = dv.mutable();
            checkContentsAndType(dv, value, 0.001, tempUnit, true);
            checkContentsAndType(mdv, value, 0.001, tempUnit, true);
            checkContentsAndType(dvCopy, value, 0.001, tempUnit, true);
            MutableDoubleVector.Abs.Dense<TemperatureUnit> mdvCopy = mdv.copy();
            checkContentsAndType(mdvCopy, value, 0.001, tempUnit, true);
            MutableDoubleVector.Abs.Dense<TemperatureUnit> mmdv = mdv.mutable();
            checkContentsAndType(mmdv, value, 0.001, tempUnit, true);
            assertEquals("hashCode is independent on mutability", dv.hashCode(), mdv.hashCode());
            // Modify mdv
            mdv.setInUnit(0, 12345, TemperatureUnit.DEGREE_CELSIUS);
            checkContentsAndType(dv, value, 0.001, tempUnit, true);
            checkContentsAndType(mdv, value2, 0.01, tempUnit, true);
            checkContentsAndType(mdvCopy, value, 0.001, tempUnit, true);
            checkContentsAndType(mmdv, value, 0.001, tempUnit, true);
            DoubleVector.Abs<TemperatureUnit> idv = mdv.immutable();
            assertTrue("Different value extremely likely results in different hashCode", dv.hashCode() != mdv.hashCode());
            // Restore value of mdv
            mdv.setSI(0, dv.getSI(0));
            checkContentsAndType(idv, value2, 0.01, tempUnit, true);
            checkContentsAndType(mdv, value, 0.001, tempUnit, true);
            checkContentsAndType(mmdv, value, 0.001, tempUnit, true);
            mmdv.setSI(0, 0);
            checkContentsAndType(mdv, value, 0.001, tempUnit, true);
            assertEquals("value should be about -273", -273, mmdv.getInUnit(0, tempUnit), 0.2);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        double value = 38.0;
        DoubleScalar.Abs<LengthUnit> dv = new DoubleScalar.Abs<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", dv.equals(dv));
        assertFalse("Not equal to null", dv.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", dv.equals(new String("abc")));
        DoubleScalar.Rel<LengthUnit> dvCounterPart = new DoubleScalar.Rel<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", dv.equals(dvCounterPart));
        DoubleScalar.Abs<TemperatureUnit> dvWrongBaseUnit = new DoubleScalar.Abs<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", dv.getSI(), dvWrongBaseUnit.getSI(), 0.0001);
        assertFalse("Not equals because the standard SI unit differs", dv.equals(dvWrongBaseUnit));
        DoubleScalar.Abs<LengthUnit> dvCompatibleUnit =
                new DoubleScalar.Abs<LengthUnit>(38000.0, LengthUnit.MILLIMETER);
        assertFalse("Units are different", dv.getUnit().equals(dvCompatibleUnit.getUnit()));
        assertTrue("equals returns true", dv.equals(dvCompatibleUnit));
        DoubleScalar.Abs<LengthUnit> dvDifferentValue =
                new DoubleScalar.Abs<LengthUnit>(123.456, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", dv.equals(dvDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        double[] seedValues = {-10, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 10};
        for (double seedValue : seedValues)
        {
            double[] input = data(3, seedValue);
            MutableDoubleVector.Abs.Dense<LengthUnit> dv;
            try
            {
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.abs();
                MathTester.tester(input, "abs", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.abs(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.acos();
                MathTester.tester(input, "acos", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.acos(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.asin();
                MathTester.tester(input, "asin", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.asin(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.atan();
                MathTester.tester(input, "atan", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.atan(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.cbrt();
                MathTester.tester(input, "cbrt", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.cbrt(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.ceil();
                MathTester.tester(input, "ceil", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.ceil(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.cos();
                MathTester.tester(input, "cos", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.cos(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.cosh();
                MathTester.tester(input, "cosh", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.cosh(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.exp();
                MathTester.tester(input, "exp", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.exp(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.expm1();
                MathTester.tester(input, "expm1", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.expm1(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.floor();
                MathTester.tester(input, "floor", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.floor(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.log();
                MathTester.tester(input, "log", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.log(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.log10();
                MathTester.tester(input, "log10", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.log10(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.log1p();
                MathTester.tester(input, "log1p", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.log1p(d);
                    }
                });
            for (int i = -10; i <= 10; i++)
            {
                final double exponent = i * 0.5d;
                    dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                    dv.pow(exponent);
                    MathTester.tester(input, "pow(" + exponent + ")", dv, 0.001, new DoubleToDouble()
                    {
                        @Override
                        public double function(final double d)
                        {
                            return Math.pow(d, exponent);
                        }
                    });
            }
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.rint();
                MathTester.tester(input, "rint", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.rint(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.round();
                MathTester.tester(input, "round", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.round(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.signum();
                MathTester.tester(input, "signum", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.signum(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.sin();
                MathTester.tester(input, "sin", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.sin(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.sinh();
                MathTester.tester(input, "sinh", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.sinh(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.sqrt();
                MathTester.tester(input, "sqrt", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.sqrt(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.tan();
                MathTester.tester(input, "tan", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.tan(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.tanh();
                MathTester.tester(input, "tanh", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.tanh(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.toDegrees();
                MathTester.tester(input, "toDegrees", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.toDegrees(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.toRadians();
                MathTester.tester(input, "toRadians", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.toRadians(d);
                    }
                });
                dv = new MutableDoubleVector.Abs.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.inv();
                MathTester.tester(input, "inv", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return 1 / d;
                    }
                });
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected ValueException: " + ve.toString());
            }
        }
    }

    /**
     * Test plus(DoubleVectorAbs.Dense, DoubleVectorRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfAbsDenseAndRelDenseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Abs.Dense<LengthUnit> left = new DoubleVector.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Dense<LengthUnit> right = new DoubleVector.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Abs.Dense<?> result = DoubleVector.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI plus of contributing elements", left.getSI(i) + right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleVectorAbs.Dense, DoubleVectorRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfAbsDenseAndRelDenseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Abs.Dense<LengthUnit> left = new DoubleVector.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Dense<LengthUnit> right = new DoubleVector.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Abs.Dense<?> result = DoubleVector.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI minus of contributing elements", left.getSI(i) - right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(DoubleVectorAbs.Dense, DoubleVectorAbs.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfAbsDenseAndAbsDenseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Abs.Dense<LengthUnit> left = new DoubleVector.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Abs.Dense<LengthUnit> right = new DoubleVector.Abs.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Abs.Dense<?> result = DoubleVector.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI times of contributing elements", left.getSI(i) * right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test plus(DoubleVectorAbs.Dense, DoubleVectorRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfAbsDenseAndRelSparseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Abs.Dense<LengthUnit> left = new DoubleVector.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Sparse<LengthUnit> right = new DoubleVector.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Abs.Dense<?> result = DoubleVector.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI plus of contributing elements", left.getSI(i) + right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleVectorAbs.Dense, DoubleVectorRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfAbsDenseAndRelSparseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Abs.Dense<LengthUnit> left = new DoubleVector.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Sparse<LengthUnit> right = new DoubleVector.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Abs.Dense<?> result = DoubleVector.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI minus of contributing elements", left.getSI(i) - right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(DoubleVectorAbs.Dense, DoubleVectorAbs.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfAbsDenseAndAbsSparseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Abs.Dense<LengthUnit> left = new DoubleVector.Abs.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Abs.Sparse<LengthUnit> right = new DoubleVector.Abs.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Abs.Sparse<?> result = DoubleVector.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI times of contributing elements", left.getSI(i) * right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that malformed or mismatching arrays throw a ValueException.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void sizeCheckAbsTest()
    {
        int junk = 0;
        try
        {
            // null array
            new DoubleVector.Abs.Dense<TemperatureUnit>((double[]) null, TemperatureUnit.DEGREE_FAHRENHEIT);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        assertTrue("The variable junk is only used to suppress annoying warnings of the code checker", junk > 0);
    }

    /**
     * Test that the times methods with a simple array as the 2nd argument.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void scaleAbsTest()
    {
        try
        {
            double[] leftIn = data(3, -12.34);
            DoubleVector.Abs.Dense<TemperatureUnit> left = new DoubleVector.Abs.Dense<TemperatureUnit>(leftIn, TemperatureUnit.KELVIN);
            double[] right = data(3, -4.321);
            MutableDoubleVector.Abs.Dense<TemperatureUnit> result = DoubleVector.times(left, right);
            assertEquals("Result should be in Kelvin", TemperatureUnit.KELVIN, result.getUnit());
            for (int index = right.length; --index >= 0;)
            {
                assertEquals("Content should match product of left and right", leftIn[index] * right[index], result.getSI(index), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringRelTest()
    {
        try
        {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double[] value = data(3, 38.0);
        DoubleVector.Rel.Dense<TemperatureUnit> dv = new DoubleVector.Rel.Dense<TemperatureUnit>(value, tempUnit);
        String result = dv.toString(true);
        assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
        assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableRelTest()
    {
        try
        {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double[] value = data(3, 38.0);
        MutableDoubleVector.Rel.Dense<TemperatureUnit> dv = new MutableDoubleVector.Rel.Dense<TemperatureUnit>(value, tempUnit);
        String result = dv.toString(true);
        assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
        assertTrue("toString contains \"Dense\"", result.contains("Dense"));
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings({"static-method", "unchecked"})
    @Test
    public final void basicsRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[] value = data(3, 38.0);
            DoubleVector.Rel.Dense<TemperatureUnit> temperatureDV = new DoubleVector.Rel.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(temperatureDV, value, 0.001, tempUnit, false);
            assertEquals("Value in SI is equivalent in Kelvin", 311.15, temperatureDV.getSI(0), 0.05);
            assertEquals("Value in Fahrenheit", 100.4, temperatureDV.getInUnit(0, TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
            double[] out = temperatureDV.getValuesInUnit();
            for (int index = 0; index < value.length; index++)
            {
                assertEquals("Value should match", value[index], out[index], 0.001);
            }
            MutableDoubleVector.Rel.Dense<TemperatureUnit> mdv = new MutableDoubleVector.Rel.Dense<TemperatureUnit>(value, tempUnit);
            checkContentsAndType(mdv, value, 0.001, tempUnit, false);
            mdv.setSI(0, 73);
            double safe = value[0];
            value[0] = -200; // Approximate Celsius equivalent of 73 Kelvin
            checkContentsAndType(mdv, value, 1, tempUnit, false);
            value[0] = safe; // Restore
            mdv.set(0, temperatureDV.get(0));
            checkContentsAndType(mdv, value, 0.001, tempUnit, false);
            DoubleVector.Rel.Dense<TemperatureUnit> temperature2DV = new DoubleVector.Rel.Dense<TemperatureUnit>(temperatureDV.getVectorSI(), TemperatureUnit.KELVIN);
            assertTrue("temperature2DV should be equal to temperatureDV", temperature2DV.equals(temperatureDV));
            assertTrue("Value is Relative", temperatureDV.isRelative());
            assertFalse("Value is not Absolute", temperatureDV.isAbsolute());
            temperatureDV = new DoubleVector.Rel.Dense<TemperatureUnit>(value, TemperatureUnit.KELVIN);
            checkContentsAndType(temperatureDV, value, 0.001, TemperatureUnit.KELVIN, false);
            out = temperatureDV.getValuesSI();
            for (int index = 0; index < value.length; index++)
            {
                assertEquals("Value should match", value[index], out[index], 0.001);
            }
            DoubleScalar.Rel<TemperatureUnit>[] scalar = new DoubleScalar.Rel[value.length];
        for (int index = 0; index < value.length; index++)
            {
                scalar[index] = new DoubleScalar.Rel<TemperatureUnit>(value[index], TemperatureUnit.DEGREE_CELSIUS);
            }
            temperatureDV = new DoubleVector.Rel.Dense<TemperatureUnit>(scalar);
            checkContentsAndType(temperatureDV, value, 0.001, tempUnit, false);
            assertEquals("All cells != 0; cardinality should equal number of cells", value.length, temperatureDV.cardinality());
            double sum = 0;
            for (int index = 0; index < value.length; index++)
            {
                sum += temperatureDV.getSI(index);
            }
            assertEquals("zSum should be sum of all values", sum, temperatureDV.zSum(), 0.001);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackRelTest()
    {
        try
        {
            TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
            double[] value = data(3, 38.0);
            double[] value2 = data(3, 38.0);
            value2[0] = 12345;
            DoubleVector.Rel.Dense<TemperatureUnit> dv = new DoubleVector.Rel.Dense<TemperatureUnit>(value, tempUnit);
            DoubleVector.Rel<TemperatureUnit> dvCopy = dv.copy();
            MutableDoubleVector.Rel.Dense<TemperatureUnit> mdv = dv.mutable();
            checkContentsAndType(dv, value, 0.001, tempUnit, false);
            checkContentsAndType(mdv, value, 0.001, tempUnit, false);
            checkContentsAndType(dvCopy, value, 0.001, tempUnit, false);
            MutableDoubleVector.Rel.Dense<TemperatureUnit> mdvCopy = mdv.copy();
            checkContentsAndType(mdvCopy, value, 0.001, tempUnit, false);
            MutableDoubleVector.Rel.Dense<TemperatureUnit> mmdv = mdv.mutable();
            checkContentsAndType(mmdv, value, 0.001, tempUnit, false);
            assertEquals("hashCode is independent on mutability", dv.hashCode(), mdv.hashCode());
            // Modify mdv
            mdv.setInUnit(0, 12345, TemperatureUnit.DEGREE_CELSIUS);
            checkContentsAndType(dv, value, 0.001, tempUnit, false);
            checkContentsAndType(mdv, value2, 0.01, tempUnit, false);
            checkContentsAndType(mdvCopy, value, 0.001, tempUnit, false);
            checkContentsAndType(mmdv, value, 0.001, tempUnit, false);
            DoubleVector.Rel<TemperatureUnit> idv = mdv.immutable();
            assertTrue("Different value extremely likely results in different hashCode", dv.hashCode() != mdv.hashCode());
            // Restore value of mdv
            mdv.setSI(0, dv.getSI(0));
            checkContentsAndType(idv, value2, 0.01, tempUnit, false);
            checkContentsAndType(mdv, value, 0.001, tempUnit, false);
            checkContentsAndType(mmdv, value, 0.001, tempUnit, false);
            mmdv.setSI(0, 0);
            checkContentsAndType(mdv, value, 0.001, tempUnit, false);
            assertEquals("value should be about -273", -273, mmdv.getInUnit(0, tempUnit), 0.2);
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        double value = 38.0;
        DoubleScalar.Rel<LengthUnit> dv = new DoubleScalar.Rel<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", dv.equals(dv));
        assertFalse("Not equal to null", dv.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", dv.equals(new String("abc")));
        DoubleScalar.Abs<LengthUnit> dvCounterPart = new DoubleScalar.Abs<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", dv.equals(dvCounterPart));
        DoubleScalar.Rel<TemperatureUnit> dvWrongBaseUnit = new DoubleScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", dv.getSI(), dvWrongBaseUnit.getSI(), 0.0001);
        assertFalse("Not equals because the standard SI unit differs", dv.equals(dvWrongBaseUnit));
        DoubleScalar.Rel<LengthUnit> dvCompatibleUnit =
                new DoubleScalar.Rel<LengthUnit>(38000.0, LengthUnit.MILLIMETER);
        assertFalse("Units are different", dv.getUnit().equals(dvCompatibleUnit.getUnit()));
        assertTrue("equals returns true", dv.equals(dvCompatibleUnit));
        DoubleScalar.Rel<LengthUnit> dvDifferentValue =
                new DoubleScalar.Rel<LengthUnit>(123.456, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", dv.equals(dvDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestRelTest()
    {
        double[] seedValues = {-10, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 10};
        for (double seedValue : seedValues)
        {
            double[] input = data(3, seedValue);
            MutableDoubleVector.Rel.Dense<LengthUnit> dv;
            try
            {
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.abs();
                MathTester.tester(input, "abs", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.abs(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.acos();
                MathTester.tester(input, "acos", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.acos(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.asin();
                MathTester.tester(input, "asin", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.asin(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.atan();
                MathTester.tester(input, "atan", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.atan(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.cbrt();
                MathTester.tester(input, "cbrt", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.cbrt(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.ceil();
                MathTester.tester(input, "ceil", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.ceil(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.cos();
                MathTester.tester(input, "cos", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.cos(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.cosh();
                MathTester.tester(input, "cosh", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.cosh(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.exp();
                MathTester.tester(input, "exp", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.exp(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.expm1();
                MathTester.tester(input, "expm1", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.expm1(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.floor();
                MathTester.tester(input, "floor", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.floor(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.log();
                MathTester.tester(input, "log", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.log(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.log10();
                MathTester.tester(input, "log10", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.log10(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.log1p();
                MathTester.tester(input, "log1p", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.log1p(d);
                    }
                });
            for (int i = -10; i <= 10; i++)
            {
                final double exponent = i * 0.5d;
                    dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                    dv.pow(exponent);
                    MathTester.tester(input, "pow(" + exponent + ")", dv, 0.001, new DoubleToDouble()
                    {
                        @Override
                        public double function(final double d)
                        {
                            return Math.pow(d, exponent);
                        }
                    });
            }
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.rint();
                MathTester.tester(input, "rint", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.rint(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.round();
                MathTester.tester(input, "round", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.round(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.signum();
                MathTester.tester(input, "signum", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.signum(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.sin();
                MathTester.tester(input, "sin", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.sin(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.sinh();
                MathTester.tester(input, "sinh", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.sinh(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.sqrt();
                MathTester.tester(input, "sqrt", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.sqrt(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.tan();
                MathTester.tester(input, "tan", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.tan(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.tanh();
                MathTester.tester(input, "tanh", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.tanh(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.toDegrees();
                MathTester.tester(input, "toDegrees", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.toDegrees(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.toRadians();
                MathTester.tester(input, "toRadians", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.toRadians(d);
                    }
                });
                dv = new MutableDoubleVector.Rel.Dense<LengthUnit>(input, LengthUnit.METER);
                dv.inv();
                MathTester.tester(input, "inv", dv, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return 1 / d;
                    }
                });
            }
            catch (ValueException ve)
            {
                fail("Caught unexpected ValueException: " + ve.toString());
            }
        }
    }

    /**
     * Test plus(DoubleVectorRel.Dense, DoubleVectorRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfRelDenseAndRelDenseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Rel.Dense<LengthUnit> left = new DoubleVector.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Dense<LengthUnit> right = new DoubleVector.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Rel.Dense<?> result = DoubleVector.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI plus of contributing elements", left.getSI(i) + right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleVectorRel.Dense, DoubleVectorRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfRelDenseAndRelDenseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Rel.Dense<LengthUnit> left = new DoubleVector.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Dense<LengthUnit> right = new DoubleVector.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Rel.Dense<?> result = DoubleVector.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI minus of contributing elements", left.getSI(i) - right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(DoubleVectorRel.Dense, DoubleVectorRel.Dense).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfRelDenseAndRelDenseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Rel.Dense<LengthUnit> left = new DoubleVector.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Dense<LengthUnit> right = new DoubleVector.Rel.Dense<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Rel.Dense<?> result = DoubleVector.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI times of contributing elements", left.getSI(i) * right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test plus(DoubleVectorRel.Dense, DoubleVectorRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfRelDenseAndRelSparseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Rel.Dense<LengthUnit> left = new DoubleVector.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Sparse<LengthUnit> right = new DoubleVector.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Rel.Dense<?> result = DoubleVector.plus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI plus of contributing elements", left.getSI(i) + right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test minus(DoubleVectorRel.Dense, DoubleVectorRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfRelDenseAndRelSparseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Rel.Dense<LengthUnit> left = new DoubleVector.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Sparse<LengthUnit> right = new DoubleVector.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Rel.Dense<?> result = DoubleVector.minus(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI minus of contributing elements", left.getSI(i) - right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test times(DoubleVectorRel.Dense, DoubleVectorRel.Sparse).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarytimesOfRelDenseAndRelSparseTest()
    {
        try
        {
            double[] leftValue = data(3, 123.4);
            double[] rightValue = data(3, 234.5);
            DoubleVector.Rel.Dense<LengthUnit> left = new DoubleVector.Rel.Dense<LengthUnit>(leftValue, LengthUnit.MILE);
            DoubleVector.Rel.Sparse<LengthUnit> right = new DoubleVector.Rel.Sparse<LengthUnit>(rightValue, LengthUnit.MILE);
            MutableDoubleVector.Rel.Sparse<?> result = DoubleVector.times(left, right);
            for (int i = 0; i < leftValue.length; i++)
            {
                assertEquals("value of element should be SI times of contributing elements", left.getSI(i) * right.getSI(i), result.getSI(i), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected ValueException: " + ve.toString());
        }
    }

    /**
     * Test that malformed or mismatching arrays throw a ValueException.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void sizeCheckRelTest()
    {
        int junk = 0;
        try
        {
            // null array
            new DoubleVector.Rel.Dense<TemperatureUnit>((double[]) null, TemperatureUnit.DEGREE_FAHRENHEIT);
            fail("Preceding code should have thrown a ValueException");
        }
        catch (ValueException ve)
        {
            // Ignore (exception was expected)
            junk++;
        }
        assertTrue("The variable junk is only used to suppress annoying warnings of the code checker", junk > 0);
    }

    /**
     * Test that the times methods with a simple array as the 2nd argument.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void scaleRelTest()
    {
        try
        {
            double[] leftIn = data(3, -12.34);
            DoubleVector.Rel.Dense<TemperatureUnit> left = new DoubleVector.Rel.Dense<TemperatureUnit>(leftIn, TemperatureUnit.KELVIN);
            double[] right = data(3, -4.321);
            MutableDoubleVector.Rel.Dense<TemperatureUnit> result = DoubleVector.times(left, right);
            assertEquals("Result should be in Kelvin", TemperatureUnit.KELVIN, result.getUnit());
            for (int index = right.length; --index >= 0;)
            {
                assertEquals("Content should match product of left and right", leftIn[index] * right[index], result.getSI(index), 0.001);
            }
        }
        catch (ValueException ve)
        {
            fail("Caught unexpected exception: " + ve.toString());
        }
    }

    /** */
    interface DoubleToDouble
    {
        /**
         * @param d double; value
         * @return double value
         */
        double function(double d);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValues double[]; unprocessed value
         * @param operation String; description of method that is being tested
         * @param actualResult DoubleVector&lt;?&gt;; the actual result of the operation
         * @param precision double; expected accuracy
         * @param function DoubleToDouble; encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final double[] inputValues, final String operation, final DoubleVector<?> actualResult,
                final double precision, final DoubleToDouble function)
        {
            for (int i = 0; i < inputValues.length; i++)
            {
                double expectedResult = function.function(inputValues[i]);
                double got = 0;
                try
                {
                    got = actualResult.getSI(i);
                }
                catch (ValueException ve)
                {
                    fail("Caught unexpected exception: " + ve.toString());
                }
                String description =
                        String.format("%s(%f->%f should be equal to %f with precision %f", operation, inputValues[i],
                                expectedResult, got, precision);
                // System.out.println(description);
                assertEquals(description, expectedResult, got, precision);
            }
        }

    }

}
