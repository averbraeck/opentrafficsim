package org.opentrafficsim.core.value.vdouble.scalar;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.opentrafficsim.core.unit.AreaUnit;
import org.opentrafficsim.core.unit.LengthUnit;
import org.opentrafficsim.core.unit.SIUnit;
import org.opentrafficsim.core.unit.SpeedUnit;
import org.opentrafficsim.core.unit.TemperatureUnit;
import org.opentrafficsim.core.unit.TimeUnit;
import org.opentrafficsim.core.unit.Unit;
import org.opentrafficsim.core.value.Absolute;
import org.opentrafficsim.core.value.Relative;
import org.opentrafficsim.core.value.ValueException;
import org.opentrafficsim.core.value.vdouble.scalar.DoubleScalar;

/**
 * Test the DoubleScalar class.
 * <p>
 * This file was generated by the OpenTrafficSim value test classes generator, 30 dec, 2014
 * <p>
 * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 30 dec, 2014 <br>
 * @author <a href="http://www.tbm.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class DoubleScalarTest
{
    /**
     * Check that the value in a DoubleScalarmatches the expected value.
     * @param ds DoubleScalar&lt;?&gt;; the DoubleScalar to match
     * @param reference double; the reference value
     * @param precision double; the maximum allowed error
     * @param u Unit&lt;?&gt;; the expected type
     * @param expectAbsolute boolean; if true; ds should be Absolute; if false; ds should be Relative
     */
    private static void checkContentsAndType(final DoubleScalar<?> ds, final double reference, final double precision,
        final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue("DoubleScalar should not be null", null != ds);
        assertEquals("Value should match", reference, ds.getInUnit(), precision);
        assertEquals("Unit should be " + u.toString(), u, ds.getUnit());
        assertTrue("Should be " + (expectAbsolute ? "Absolute" : "Relative"), expectAbsolute ? ds.isAbsolute() : ds
            .isRelative());
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double value = 38.0;
        DoubleScalar.Abs<TemperatureUnit> ds = new DoubleScalar.Abs<TemperatureUnit>(value, tempUnit);
        String result = ds.toString(true);
        assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double value = 38.0;
        MutableDoubleScalar.Abs<TemperatureUnit> ds = new MutableDoubleScalar.Abs<TemperatureUnit>(value, tempUnit);
        String result = ds.toString(true);
        assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void basicsAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        double value = 38.0;
        DoubleScalar.Abs<TemperatureUnit> temperatureDS = new DoubleScalar.Abs<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(temperatureDS, value, 0.001, tempUnit, true);
        assertEquals("Value in SI is equivalent in Kelvin", 311.15, temperatureDS.getSI(), 0.05);
        assertEquals("Value in Fahrenheit", 100.4, temperatureDS.getInUnit(TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
        double out = temperatureDS.getInUnit();
        assertEquals("Value should match", value, out, 0.001);
        MutableDoubleScalar.Abs<TemperatureUnit> mds = new MutableDoubleScalar.Abs<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(mds, value, 0.001, tempUnit, true);
        mds.setSI(73);
        double safe = value;
        value = -200; // Approximate Celsius equivalent of 73 Kelvin
        checkContentsAndType(mds, value, 1, tempUnit, true);
        value = safe; // Restore
        mds.set(temperatureDS);
        checkContentsAndType(mds, value, 0.001, tempUnit, true);
        DoubleScalar.Abs<TemperatureUnit> temperature2DS = new DoubleScalar.Abs<TemperatureUnit>(temperatureDS);
        assertTrue("temperature2DS should be equal to temperatureDS", temperature2DS.equals(temperatureDS));
        assertTrue("Value is Absolute", temperatureDS.isAbsolute());
        assertFalse("Value is not Relative", temperatureDS.isRelative());
        temperatureDS = new DoubleScalar.Abs<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        checkContentsAndType(temperatureDS, value, 0.001, TemperatureUnit.KELVIN, true);
        out = temperatureDS.getSI();
        assertEquals("Value should match", value, out, 0.001);
        for (int i = -100; i <= 100; i++)
        {
            double v = i / 10.0;
            mds.setSI(v);
            assertEquals("intValue should round like Math.round", Math.round(v), mds.intValue(), 0.0001);
            assertEquals("longValue should round like Math.round", Math.round(v), mds.longValue(), 0.0001);
            assertEquals("floatValue should return the value", v, mds.floatValue(), 0.0001);
            assertEquals("doubleValue should return the value", v, mds.doubleValue(), 0.0001);
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        double value = 38.0;
        double value2 = 38.0;
        value2 = 12345;
        DoubleScalar.Abs<TemperatureUnit> ds = new DoubleScalar.Abs<TemperatureUnit>(value, tempUnit);
        DoubleScalar.Abs<TemperatureUnit> dsCopy = ds.copy();
        MutableDoubleScalar.Abs<TemperatureUnit> mds = ds.mutable();
        checkContentsAndType(ds, value, 0.001, tempUnit, true);
        checkContentsAndType(mds, value, 0.001, tempUnit, true);
        checkContentsAndType(dsCopy, value, 0.001, tempUnit, true);
        MutableDoubleScalar.Abs<TemperatureUnit> mdsCopy = mds.copy();
        checkContentsAndType(mdsCopy, value, 0.001, tempUnit, true);
        MutableDoubleScalar.Abs<TemperatureUnit> mmds = mds.mutable();
        checkContentsAndType(mmds, value, 0.001, tempUnit, true);
        assertEquals("hashCode is independent on mutability", ds.hashCode(), mds.hashCode());
        // Modify mds
        mds.setInUnit(12345, TemperatureUnit.DEGREE_CELSIUS);
        checkContentsAndType(ds, value, 0.001, tempUnit, true);
        checkContentsAndType(mds, value2, 0.01, tempUnit, true);
        checkContentsAndType(mdsCopy, value, 0.001, tempUnit, true);
        checkContentsAndType(mmds, value, 0.001, tempUnit, true);
        DoubleScalar.Abs<TemperatureUnit> ids = mds.immutable();
        assertTrue("Different value extremely likely results in different hashCode", ds.hashCode() != mds.hashCode());
        // Restore value of mds
        mds.setValueSI(ds.getSI());
        checkContentsAndType(ids, value2, 0.01, tempUnit, true);
        checkContentsAndType(mds, value, 0.001, tempUnit, true);
        checkContentsAndType(mmds, value, 0.001, tempUnit, true);
        mmds.setSI(0);
        checkContentsAndType(mds, value, 0.001, tempUnit, true);
        assertEquals("value should be about -273", -273, mmds.getInUnit(tempUnit), 0.2);
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        double value = 38.0;
        DoubleScalar.Abs<LengthUnit> ds = new DoubleScalar.Abs<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", ds.equals(ds));
        assertFalse("Not equal to null", ds.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", ds.equals(new String("abc")));
        DoubleScalar.Rel<LengthUnit> dsCounterPart = new DoubleScalar.Rel<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", ds.equals(dsCounterPart));
        DoubleScalar.Abs<TemperatureUnit> dsWrongBaseUnit =
            new DoubleScalar.Abs<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", ds.getSI(), dsWrongBaseUnit.getSI(), 0.0001);
        assertFalse("Not equals because the standard SI unit differs", ds.equals(dsWrongBaseUnit));
        DoubleScalar.Abs<LengthUnit> dsCompatibleUnit = new DoubleScalar.Abs<LengthUnit>(38000.0, LengthUnit.MILLIMETER);
        assertFalse("Units are different", ds.getUnit().equals(dsCompatibleUnit.getUnit()));
        assertTrue("equals returns true", ds.equals(dsCompatibleUnit));
        DoubleScalar.Abs<LengthUnit> dsDifferentValue = new DoubleScalar.Abs<LengthUnit>(123.456, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", ds.equals(dsDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        double[] seedValues = {-10, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 10};
        for (double seedValue : seedValues)
        {
            double input = seedValue;
            MutableDoubleScalar.Abs<LengthUnit> ds;
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.abs();
            MathTester.tester(input, "abs", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.abs(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.acos();
            MathTester.tester(input, "acos", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.acos(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.asin();
            MathTester.tester(input, "asin", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.asin(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.atan();
            MathTester.tester(input, "atan", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.atan(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.cbrt();
            MathTester.tester(input, "cbrt", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.cbrt(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.ceil();
            MathTester.tester(input, "ceil", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.ceil(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.cos();
            MathTester.tester(input, "cos", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.cos(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.cosh();
            MathTester.tester(input, "cosh", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.cosh(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.exp();
            MathTester.tester(input, "exp", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.exp(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.expm1();
            MathTester.tester(input, "expm1", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.expm1(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.floor();
            MathTester.tester(input, "floor", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.floor(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.log();
            MathTester.tester(input, "log", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.log(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.log10();
            MathTester.tester(input, "log10", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.log10(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.log1p();
            MathTester.tester(input, "log1p", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.log1p(d);
                }
            });
            for (int i = -10; i <= 10; i++)
            {
                final double exponent = i * 0.5d;
                ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
                ds.pow(exponent);
                MathTester.tester(input, "pow(" + exponent + ")", ds, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.pow(d, exponent);
                    }
                });
            }
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.rint();
            MathTester.tester(input, "rint", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.rint(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.round();
            MathTester.tester(input, "round", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.round(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.signum();
            MathTester.tester(input, "signum", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.signum(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.sin();
            MathTester.tester(input, "sin", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.sin(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.sinh();
            MathTester.tester(input, "sinh", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.sinh(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.sqrt();
            MathTester.tester(input, "sqrt", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.sqrt(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.tan();
            MathTester.tester(input, "tan", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.tan(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.tanh();
            MathTester.tester(input, "tanh", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.tanh(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.toDegrees();
            MathTester.tester(input, "toDegrees", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.toDegrees(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.toRadians();
            MathTester.tester(input, "toRadians", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.toRadians(d);
                }
            });
            ds = new MutableDoubleScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            ds.inv();
            MathTester.tester(input, "inv", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return 1 / d;
                }
            });
        }
    }

    /**
     * Test plus(DoubleScalarAbs, DoubleScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfAbsAndRelTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Abs<LengthUnit> left = new DoubleScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Rel<LengthUnit> right = new DoubleScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Abs<?> result = DoubleScalar.plus(left, right);
        assertEquals("value of element should be SI plus of contributing elements", left.getSI() + right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test minus(DoubleScalarAbs, DoubleScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfAbsAndRelTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Abs<LengthUnit> left = new DoubleScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Rel<LengthUnit> right = new DoubleScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Abs<?> result = DoubleScalar.minus(left, right);
        assertEquals("value of element should be SI minus of contributing elements", left.getSI() - right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test multiply(DoubleScalarAbs, DoubleScalarAbs).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarymultiplyOfAbsAndAbsTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Abs<LengthUnit> left = new DoubleScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Abs<LengthUnit> right = new DoubleScalar.Abs<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Abs<?> result = DoubleScalar.multiply(left, right);
        assertEquals("value of element should be SI multiply of contributing elements", left.getSI() * right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test divide(DoubleScalarAbs, DoubleScalarAbs).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarydivideOfAbsAndAbsTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Abs<LengthUnit> left = new DoubleScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Abs<LengthUnit> right = new DoubleScalar.Abs<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Abs<?> result = DoubleScalar.divide(left, right);
        assertEquals("value of element should be SI divide of contributing elements", left.getSI() / right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double value = 38.0;
        DoubleScalar.Rel<TemperatureUnit> ds = new DoubleScalar.Rel<TemperatureUnit>(value, tempUnit);
        String result = ds.toString(true);
        assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        double value = 38.0;
        MutableDoubleScalar.Rel<TemperatureUnit> ds = new MutableDoubleScalar.Rel<TemperatureUnit>(value, tempUnit);
        String result = ds.toString(true);
        assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
        assertTrue("toString result contains \"[K]\"", result.contains("[K]"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void basicsRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        double value = 38.0;
        DoubleScalar.Rel<TemperatureUnit> temperatureDS = new DoubleScalar.Rel<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(temperatureDS, value, 0.001, tempUnit, false);
        assertEquals("Value in SI is equivalent in Kelvin", 311.15, temperatureDS.getSI(), 0.05);
        assertEquals("Value in Fahrenheit", 100.4, temperatureDS.getInUnit(TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
        double out = temperatureDS.getInUnit();
        assertEquals("Value should match", value, out, 0.001);
        MutableDoubleScalar.Rel<TemperatureUnit> mds = new MutableDoubleScalar.Rel<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(mds, value, 0.001, tempUnit, false);
        mds.setSI(73);
        double safe = value;
        value = -200; // Approximate Celsius equivalent of 73 Kelvin
        checkContentsAndType(mds, value, 1, tempUnit, false);
        value = safe; // Restore
        mds.set(temperatureDS);
        checkContentsAndType(mds, value, 0.001, tempUnit, false);
        DoubleScalar.Rel<TemperatureUnit> temperature2DS = new DoubleScalar.Rel<TemperatureUnit>(temperatureDS);
        assertTrue("temperature2DS should be equal to temperatureDS", temperature2DS.equals(temperatureDS));
        assertTrue("Value is Relative", temperatureDS.isRelative());
        assertFalse("Value is not Absolute", temperatureDS.isAbsolute());
        temperatureDS = new DoubleScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        checkContentsAndType(temperatureDS, value, 0.001, TemperatureUnit.KELVIN, false);
        out = temperatureDS.getSI();
        assertEquals("Value should match", value, out, 0.001);
        for (int i = -100; i <= 100; i++)
        {
            double v = i / 10.0;
            mds.setSI(v);
            assertEquals("intValue should round like Math.round", Math.round(v), mds.intValue(), 0.0001);
            assertEquals("longValue should round like Math.round", Math.round(v), mds.longValue(), 0.0001);
            assertEquals("floatValue should return the value", v, mds.floatValue(), 0.0001);
            assertEquals("doubleValue should return the value", v, mds.doubleValue(), 0.0001);
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        double value = 38.0;
        double value2 = 38.0;
        value2 = 12345;
        DoubleScalar.Rel<TemperatureUnit> ds = new DoubleScalar.Rel<TemperatureUnit>(value, tempUnit);
        DoubleScalar.Rel<TemperatureUnit> dsCopy = ds.copy();
        MutableDoubleScalar.Rel<TemperatureUnit> mds = ds.mutable();
        checkContentsAndType(ds, value, 0.001, tempUnit, false);
        checkContentsAndType(mds, value, 0.001, tempUnit, false);
        checkContentsAndType(dsCopy, value, 0.001, tempUnit, false);
        MutableDoubleScalar.Rel<TemperatureUnit> mdsCopy = mds.copy();
        checkContentsAndType(mdsCopy, value, 0.001, tempUnit, false);
        MutableDoubleScalar.Rel<TemperatureUnit> mmds = mds.mutable();
        checkContentsAndType(mmds, value, 0.001, tempUnit, false);
        assertEquals("hashCode is independent on mutability", ds.hashCode(), mds.hashCode());
        // Modify mds
        mds.setInUnit(12345, TemperatureUnit.DEGREE_CELSIUS);
        checkContentsAndType(ds, value, 0.001, tempUnit, false);
        checkContentsAndType(mds, value2, 0.01, tempUnit, false);
        checkContentsAndType(mdsCopy, value, 0.001, tempUnit, false);
        checkContentsAndType(mmds, value, 0.001, tempUnit, false);
        DoubleScalar.Rel<TemperatureUnit> ids = mds.immutable();
        assertTrue("Different value extremely likely results in different hashCode", ds.hashCode() != mds.hashCode());
        // Restore value of mds
        mds.setValueSI(ds.getSI());
        checkContentsAndType(ids, value2, 0.01, tempUnit, false);
        checkContentsAndType(mds, value, 0.001, tempUnit, false);
        checkContentsAndType(mmds, value, 0.001, tempUnit, false);
        mmds.setSI(0);
        checkContentsAndType(mds, value, 0.001, tempUnit, false);
        assertEquals("value should be about -273", -273, mmds.getInUnit(tempUnit), 0.2);
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        double value = 38.0;
        DoubleScalar.Rel<LengthUnit> ds = new DoubleScalar.Rel<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", ds.equals(ds));
        assertFalse("Not equal to null", ds.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", ds.equals(new String("abc")));
        DoubleScalar.Abs<LengthUnit> dsCounterPart = new DoubleScalar.Abs<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", ds.equals(dsCounterPart));
        DoubleScalar.Rel<TemperatureUnit> dsWrongBaseUnit =
            new DoubleScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", ds.getSI(), dsWrongBaseUnit.getSI(), 0.0001);
        assertFalse("Not equals because the standard SI unit differs", ds.equals(dsWrongBaseUnit));
        DoubleScalar.Rel<LengthUnit> dsCompatibleUnit = new DoubleScalar.Rel<LengthUnit>(38000.0, LengthUnit.MILLIMETER);
        assertFalse("Units are different", ds.getUnit().equals(dsCompatibleUnit.getUnit()));
        assertTrue("equals returns true", ds.equals(dsCompatibleUnit));
        DoubleScalar.Rel<LengthUnit> dsDifferentValue = new DoubleScalar.Rel<LengthUnit>(123.456, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", ds.equals(dsDifferentValue));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestRelTest()
    {
        double[] seedValues = {-10, -2, -1, -0.5, -0.1, 0, 0.1, 0.5, 1, 2, 10};
        for (double seedValue : seedValues)
        {
            double input = seedValue;
            MutableDoubleScalar.Rel<LengthUnit> ds;
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.abs();
            MathTester.tester(input, "abs", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.abs(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.acos();
            MathTester.tester(input, "acos", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.acos(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.asin();
            MathTester.tester(input, "asin", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.asin(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.atan();
            MathTester.tester(input, "atan", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.atan(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.cbrt();
            MathTester.tester(input, "cbrt", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.cbrt(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.ceil();
            MathTester.tester(input, "ceil", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.ceil(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.cos();
            MathTester.tester(input, "cos", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.cos(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.cosh();
            MathTester.tester(input, "cosh", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.cosh(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.exp();
            MathTester.tester(input, "exp", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.exp(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.expm1();
            MathTester.tester(input, "expm1", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.expm1(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.floor();
            MathTester.tester(input, "floor", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.floor(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.log();
            MathTester.tester(input, "log", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.log(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.log10();
            MathTester.tester(input, "log10", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.log10(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.log1p();
            MathTester.tester(input, "log1p", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.log1p(d);
                }
            });
            for (int i = -10; i <= 10; i++)
            {
                final double exponent = i * 0.5d;
                ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
                ds.pow(exponent);
                MathTester.tester(input, "pow(" + exponent + ")", ds, 0.001, new DoubleToDouble()
                {
                    @Override
                    public double function(final double d)
                    {
                        return Math.pow(d, exponent);
                    }
                });
            }
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.rint();
            MathTester.tester(input, "rint", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.rint(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.round();
            MathTester.tester(input, "round", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.round(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.signum();
            MathTester.tester(input, "signum", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.signum(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.sin();
            MathTester.tester(input, "sin", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.sin(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.sinh();
            MathTester.tester(input, "sinh", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.sinh(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.sqrt();
            MathTester.tester(input, "sqrt", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.sqrt(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.tan();
            MathTester.tester(input, "tan", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.tan(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.tanh();
            MathTester.tester(input, "tanh", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.tanh(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.toDegrees();
            MathTester.tester(input, "toDegrees", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.toDegrees(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.toRadians();
            MathTester.tester(input, "toRadians", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return Math.toRadians(d);
                }
            });
            ds = new MutableDoubleScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            ds.inv();
            MathTester.tester(input, "inv", ds, 0.001, new DoubleToDouble()
            {
                @Override
                public double function(final double d)
                {
                    return 1 / d;
                }
            });
        }
    }

    /**
     * Test plus(DoubleScalarRel, DoubleScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfRelAndRelTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Rel<LengthUnit> left = new DoubleScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Rel<LengthUnit> right = new DoubleScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Rel<?> result = DoubleScalar.plus(left, right);
        assertEquals("value of element should be SI plus of contributing elements", left.getSI() + right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test minus(DoubleScalarRel, DoubleScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfRelAndRelTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Rel<LengthUnit> left = new DoubleScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Rel<LengthUnit> right = new DoubleScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Rel<?> result = DoubleScalar.minus(left, right);
        assertEquals("value of element should be SI minus of contributing elements", left.getSI() - right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test multiply(DoubleScalarRel, DoubleScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarymultiplyOfRelAndRelTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Rel<LengthUnit> left = new DoubleScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Rel<LengthUnit> right = new DoubleScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Rel<?> result = DoubleScalar.multiply(left, right);
        assertEquals("value of element should be SI multiply of contributing elements", left.getSI() * right.getSI(), result
            .getSI(), 0.001);
    }

    /**
     * Test divide(DoubleScalarRel, DoubleScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarydivideOfRelAndRelTest()
    {
        double leftValue = 123.4;
        double rightValue = 234.5;
        DoubleScalar.Rel<LengthUnit> left = new DoubleScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        DoubleScalar.Rel<LengthUnit> right = new DoubleScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableDoubleScalar.Rel<?> result = DoubleScalar.divide(left, right);
        assertEquals("value of element should be SI divide of contributing elements", left.getSI() / right.getSI(), result
            .getSI(), 0.001);
    }

    /** */
    interface DoubleToDouble
    {
        /**
         * @param d double; value
         * @return double value
         */
        double function(double d);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValue double; unprocessed value
         * @param operation String; description of method that is being tested
         * @param actualResult DoubleScalar&lt;?&gt;; the actual result of the operation
         * @param precision double; expected accuracy
         * @param function DoubleToDouble; encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final double inputValue, final String operation, final DoubleScalar<?> actualResult,
            final double precision, final DoubleToDouble function)
        {
            double expectedResult = function.function(inputValue);
            double got = actualResult.getSI();
            String description =
                String.format("%s(%f->%f should be equal to %f with precision %f", operation, inputValue, expectedResult,
                    got, precision);
            // System.out.println(description);
            assertEquals(description, expectedResult, got, precision);
        }

    }

}
