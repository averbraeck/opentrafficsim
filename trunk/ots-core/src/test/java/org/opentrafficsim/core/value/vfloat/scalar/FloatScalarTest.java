package org.opentrafficsim.core.value.vfloat.scalar;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;
import org.opentrafficsim.core.unit.LengthUnit;
import org.opentrafficsim.core.unit.TemperatureUnit;
import org.opentrafficsim.core.unit.Unit;

/**
 * Test the FloatScalar class.
 * <p>
 * This file was generated by the OpenTrafficSim value test classes generator, 26 jun, 2015
 * <p>
 * Copyright (c) 2015 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/docs/license.html">OpenTrafficSim License</a>.
 * <p>
 * $LastChangedDate$, @version $Revision$, by $Author$,
 * initial version 26 jun, 2015 <br>
 * @author <a href="http://www.tbm.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class FloatScalarTest
{
    /**
     * Check that the value in a FloatScalarmatches the expected value.
     * @param fs FloatScalar&lt;?&gt;; the FloatScalar to match
     * @param reference float; the reference value
     * @param precision float; the maximum allowed error
     * @param u Unit&lt;?&gt;; the expected type
     * @param expectAbsolute boolean; if true; fs should be Absolute; if false; fs should be Relative
     */
    private static void checkContentsAndType(final FloatScalar<?> fs, final float reference, final float precision,
        final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue("FloatScalar should not be null", null != fs);
        assertEquals("Value should match", reference, fs.getInUnit(), precision);
        assertEquals("Unit should be " + u.toString(), u, fs.getUnit());
        assertTrue("Should be " + (expectAbsolute ? "Absolute" : "Relative"), expectAbsolute ? fs.isAbsolute() : fs
            .isRelative());
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        float value = 38.0f;
        FloatScalar.Abs<TemperatureUnit> fs = new FloatScalar.Abs<TemperatureUnit>(value, tempUnit);
        String result = fs.toString(true, true);
        assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
        assertTrue("toString result contains \"K\"", result.contains("K"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        float value = 38.0f;
        MutableFloatScalar.Abs<TemperatureUnit> fs = new MutableFloatScalar.Abs<TemperatureUnit>(value, tempUnit);
        String result = fs.toString(true, true);
        assertTrue("toString result contains \" Abs \"", result.contains(" Abs "));
        assertTrue("toString result contains \"K\"", result.contains("K"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void basicsAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        FloatScalar.Abs<TemperatureUnit> temperatureFS = new FloatScalar.Abs<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(temperatureFS, value, 0.001f, tempUnit, true);
        assertEquals("Value in SI is equivalent in Kelvin", 311.15f, temperatureFS.getSI(), 0.05);
        assertEquals("Value in Fahrenheit", 100.4f, temperatureFS.getInUnit(TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
        float out = temperatureFS.getInUnit();
        assertEquals("Value should match", value, out, 0.001);
        MutableFloatScalar.Abs<TemperatureUnit> mfs = new MutableFloatScalar.Abs<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, true);
        mfs.setSI(73);
        float safe = value;
        value = -200; // Approximate Celsius equivalent of 73 Kelvin
        checkContentsAndType(mfs, value, 1, tempUnit, true);
        value = safe; // Restore
        mfs.set(temperatureFS);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, true);
        FloatScalar.Abs<TemperatureUnit> temperature2FS = new FloatScalar.Abs<TemperatureUnit>(temperatureFS);
        assertTrue("temperature2FS should be equal to temperatureFS", temperature2FS.equals(temperatureFS));
        assertTrue("Value is Absolute", temperatureFS.isAbsolute());
        assertFalse("Value is not Relative", temperatureFS.isRelative());
        temperatureFS = new FloatScalar.Abs<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        checkContentsAndType(temperatureFS, value, 0.001f, TemperatureUnit.KELVIN, true);
        out = temperatureFS.getSI();
        assertEquals("Value should match", value, out, 0.001);
        for (int i = -100; i <= 100; i++)
        {
            float v = i / 10.0f;
            mfs.setSI(v);
            assertEquals("intValue should round like Math.round", Math.round(v), mfs.intValue(), 0.0001);
            assertEquals("longValue should round like Math.round", Math.round(v), mfs.longValue(), 0.0001);
            assertEquals("floatValue should return the value", v, mfs.floatValue(), 0.0001);
            assertEquals("doubleValue should return the value", v, mfs.doubleValue(), 0.0001);
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackAbsTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        float value2 = 38.0f;
        value2 = 12345;
        FloatScalar.Abs<TemperatureUnit> fs = new FloatScalar.Abs<TemperatureUnit>(value, tempUnit);
        FloatScalar.Abs<TemperatureUnit> fsCopy = fs.copy();
        MutableFloatScalar.Abs<TemperatureUnit> mfs = fs.mutable();
        checkContentsAndType(fs, value, 0.001f, tempUnit, true);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, true);
        checkContentsAndType(fsCopy, value, 0.001f, tempUnit, true);
        MutableFloatScalar.Abs<TemperatureUnit> mfsCopy = mfs.copy();
        checkContentsAndType(mfsCopy, value, 0.001f, tempUnit, true);
        MutableFloatScalar.Abs<TemperatureUnit> mmfs = mfs.mutable();
        checkContentsAndType(mmfs, value, 0.001f, tempUnit, true);
        assertEquals("hashCode is independent on mutability", fs.hashCode(), mfs.hashCode());
        // Modify mfs
        mfs.setInUnit(12345, TemperatureUnit.DEGREE_CELSIUS);
        checkContentsAndType(fs, value, 0.001f, tempUnit, true);
        checkContentsAndType(mfs, value2, 0.01f, tempUnit, true);
        checkContentsAndType(mfsCopy, value, 0.001f, tempUnit, true);
        checkContentsAndType(mmfs, value, 0.001f, tempUnit, true);
        FloatScalar.Abs<TemperatureUnit> ifs = mfs.immutable();
        assertTrue("Different value extremely likely results in different hashCode", fs.hashCode() != mfs.hashCode());
        // Restore value of mfs
        mfs.setValueSI(fs.getSI());
        checkContentsAndType(ifs, value2, 0.01f, tempUnit, true);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, true);
        checkContentsAndType(mmfs, value, 0.001f, tempUnit, true);
        mmfs.setSI(0);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, true);
        assertEquals("value should be about -273", -273, mmfs.getInUnit(tempUnit), 0.2);
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        float value = 38.0f;
        FloatScalar.Abs<LengthUnit> fs = new FloatScalar.Abs<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", fs.equals(fs));
        assertFalse("Not equal to null", fs.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", fs.equals(new String("abc")));
        FloatScalar.Rel<LengthUnit> fsCounterPart = new FloatScalar.Rel<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", fs.equals(fsCounterPart));
        FloatScalar.Abs<TemperatureUnit> fsWrongBaseUnit =
            new FloatScalar.Abs<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", fs.getSI(), fsWrongBaseUnit.getSI(), 0.0001f);
        assertFalse("Not equals because the standard SI unit differs", fs.equals(fsWrongBaseUnit));
        FloatScalar.Abs<LengthUnit> fsCompatibleUnit = new FloatScalar.Abs<LengthUnit>(38000.0f, LengthUnit.MILLIMETER);
        assertFalse("Units are different", fs.getUnit().equals(fsCompatibleUnit.getUnit()));
        assertTrue("equals returns true", fs.equals(fsCompatibleUnit));
        FloatScalar.Abs<LengthUnit> fsDifferentValue = new FloatScalar.Abs<LengthUnit>(123.456f, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", fs.equals(fsDifferentValue));
    }

    /**
     * Test the relational operations
     */
    @SuppressWarnings("static-method")
    @Test
    public final void relOpAbsTest()
    {
        FloatScalar.Abs<LengthUnit> base = new FloatScalar.Abs<LengthUnit>(123, LengthUnit.KILOMETER);
        FloatScalar.Abs<LengthUnit> same = new FloatScalar.Abs<LengthUnit>(123000, LengthUnit.METER);
        FloatScalar.Abs<LengthUnit> smaller = new FloatScalar.Abs<LengthUnit>(122999, LengthUnit.METER);
        FloatScalar.Abs<LengthUnit> larger = new FloatScalar.Abs<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertTrue("123km == 123000m", base.eq(same));
        assertFalse("NOT 123km != 123000m", base.ne(same));
        assertTrue("123km < 123001m", base.lt(larger));
        assertTrue("123km > 122999m", base.gt(smaller));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertFalse("NOT 123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km != 123001m", base.ne(larger));
        assertFalse("NOT 123km == 123001m", base.eq(larger));
        assertTrue("123km != 122999m", base.ne(smaller));
        assertFalse("NOT 123km == 122999m", base.eq(smaller));
        assertFalse("NOT 123km >= 123001m", base.ge(larger));
        assertFalse("NOT 123km <= 122999m", base.le(smaller));
        MutableFloatScalar.Abs<LengthUnit> same2 = new MutableFloatScalar.Abs<LengthUnit>(123000, LengthUnit.METER);
        MutableFloatScalar.Abs<LengthUnit> smaller2 = new MutableFloatScalar.Abs<LengthUnit>(122999, LengthUnit.METER);
        MutableFloatScalar.Abs<LengthUnit> larger2 = new MutableFloatScalar.Abs<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertTrue("123km == 123000m", base.eq(same2));
        assertFalse("NOT 123km != 123000m", base.ne(same2));
        assertTrue("123km < 123001m", base.lt(larger2));
        assertTrue("123km > 122999m", base.gt(smaller2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km != 123001m", base.ne(larger2));
        assertFalse("NOT 123km == 123001m", base.eq(larger2));
        assertTrue("123km != 122999m", base.ne(smaller2));
        assertFalse("NOT 123km == 122999m", base.eq(smaller2));
        assertFalse("NOT 123km >= 123001m", base.ge(larger2));
        assertFalse("NOT 123km <= 122999m", base.le(smaller2));
    }

    /**
     * Test the relational operations
     */
    @SuppressWarnings("static-method")
    @Test
    public final void relOpMutableAbsTest()
    {
        MutableFloatScalar.Abs<LengthUnit> base = new MutableFloatScalar.Abs<LengthUnit>(123, LengthUnit.KILOMETER);
        MutableFloatScalar.Abs<LengthUnit> same = new MutableFloatScalar.Abs<LengthUnit>(123000, LengthUnit.METER);
        MutableFloatScalar.Abs<LengthUnit> smaller = new MutableFloatScalar.Abs<LengthUnit>(122999, LengthUnit.METER);
        MutableFloatScalar.Abs<LengthUnit> larger = new MutableFloatScalar.Abs<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertTrue("123km == 123000m", base.eq(same));
        assertFalse("NOT 123km != 123000m", base.ne(same));
        assertTrue("123km < 123001m", base.lt(larger));
        assertTrue("123km > 122999m", base.gt(smaller));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertFalse("NOT 123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km != 123001m", base.ne(larger));
        assertFalse("NOT 123km == 123001m", base.eq(larger));
        assertTrue("123km != 122999m", base.ne(smaller));
        assertFalse("NOT 123km == 122999m", base.eq(smaller));
        assertFalse("NOT 123km >= 123001m", base.ge(larger));
        assertFalse("NOT 123km <= 122999m", base.le(smaller));
        FloatScalar.Abs<LengthUnit> same2 = new FloatScalar.Abs<LengthUnit>(123000, LengthUnit.METER);
        FloatScalar.Abs<LengthUnit> smaller2 = new FloatScalar.Abs<LengthUnit>(122999, LengthUnit.METER);
        FloatScalar.Abs<LengthUnit> larger2 = new FloatScalar.Abs<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertTrue("123km == 123000m", base.eq(same2));
        assertFalse("NOT 123km != 123000m", base.ne(same2));
        assertTrue("123km < 123001m", base.lt(larger2));
        assertTrue("123km > 122999m", base.gt(smaller2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km != 123001m", base.ne(larger2));
        assertFalse("NOT 123km == 123001m", base.eq(larger2));
        assertTrue("123km != 122999m", base.ne(smaller2));
        assertFalse("NOT 123km == 122999m", base.eq(smaller2));
        assertFalse("NOT 123km >= 123001m", base.ge(larger2));
        assertFalse("NOT 123km <= 122999m", base.le(smaller2));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        float[] seedValues = {-10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f};
        for (float seedValue : seedValues)
        {
            float input = seedValue;
            MutableFloatScalar.Abs<LengthUnit> fs;
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.abs();
            MathTester.tester(input, "abs", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.abs(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.acos();
            MathTester.tester(input, "acos", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.acos(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.asin();
            MathTester.tester(input, "asin", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.asin(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.atan();
            MathTester.tester(input, "atan", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.atan(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.cbrt();
            MathTester.tester(input, "cbrt", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.cbrt(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.ceil();
            MathTester.tester(input, "ceil", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.ceil(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.cos();
            MathTester.tester(input, "cos", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.cos(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.cosh();
            MathTester.tester(input, "cosh", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.cosh(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.exp();
            MathTester.tester(input, "exp", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.exp(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.expm1();
            MathTester.tester(input, "expm1", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.expm1(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.floor();
            MathTester.tester(input, "floor", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.floor(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.log();
            MathTester.tester(input, "log", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.log(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.log10();
            MathTester.tester(input, "log10", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.log10(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.log1p();
            MathTester.tester(input, "log1p", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.log1p(f);
                }
            });
            for (int i = -10; i <= 10; i++)
            {
                final float exponent = i * 0.5f;
                fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
                fs.pow(exponent);
                MathTester.tester(input, "pow(" + exponent + ")", fs, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.pow(f, exponent);
                    }
                });
            }
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.rint();
            MathTester.tester(input, "rint", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.rint(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.round();
            MathTester.tester(input, "round", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.round(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.signum();
            MathTester.tester(input, "signum", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.signum(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.sin();
            MathTester.tester(input, "sin", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.sin(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.sinh();
            MathTester.tester(input, "sinh", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.sinh(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.sqrt();
            MathTester.tester(input, "sqrt", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.sqrt(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.tan();
            MathTester.tester(input, "tan", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.tan(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.tanh();
            MathTester.tester(input, "tanh", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.tanh(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.toDegrees();
            MathTester.tester(input, "toDegrees", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.toDegrees(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.toRadians();
            MathTester.tester(input, "toRadians", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.toRadians(f);
                }
            });
            fs = new MutableFloatScalar.Abs<LengthUnit>(input, LengthUnit.METER);
            fs.inv();
            MathTester.tester(input, "inv", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return 1 / f;
                }
            });
        }
    }

    /**
     * Test plus(FloatScalarAbs, FloatScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfAbsAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Abs<LengthUnit> left = new FloatScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Abs<?> result = FloatScalar.plus(left, right);
        assertEquals("value of element should be SI plus of contributing elements", left.getSI() + right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test minus(FloatScalarAbs, FloatScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfAbsAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Abs<LengthUnit> left = new FloatScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Abs<?> result = FloatScalar.minus(left, right);
        assertEquals("value of element should be SI minus of contributing elements", left.getSI() - right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test multiply(FloatScalarAbs, FloatScalarAbs).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarymultiplyOfAbsAndAbsTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Abs<LengthUnit> left = new FloatScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Abs<LengthUnit> right = new FloatScalar.Abs<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Abs<?> result = FloatScalar.multiply(left, right);
        assertEquals("value of element should be SI multiply of contributing elements", left.getSI() * right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test divide(FloatScalarAbs, FloatScalarAbs).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarydivideOfAbsAndAbsTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Abs<LengthUnit> left = new FloatScalar.Abs<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Abs<LengthUnit> right = new FloatScalar.Abs<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Abs<?> result = FloatScalar.divide(left, right);
        assertEquals("value of element should be SI divide of contributing elements", left.getSI() / right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        float value = 38.0f;
        FloatScalar.Rel<TemperatureUnit> fs = new FloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        String result = fs.toString(true, true);
        assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
        assertTrue("toString result contains \"K\"", result.contains("K"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Immutable"));
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toStringMutableRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        float value = 38.0f;
        MutableFloatScalar.Rel<TemperatureUnit> fs = new MutableFloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        String result = fs.toString(true, true);
        assertTrue("toString result contains \" Rel \"", result.contains(" Rel "));
        assertTrue("toString result contains \"K\"", result.contains("K"));
        assertTrue("toString result starts with \"Immutable \"", result.startsWith("Mutable"));
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void basicsRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        FloatScalar.Rel<TemperatureUnit> temperatureFS = new FloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(temperatureFS, value, 0.001f, tempUnit, false);
        assertEquals("Value in SI is equivalent in Kelvin", 311.15f, temperatureFS.getSI(), 0.05);
        assertEquals("Value in Fahrenheit", 100.4f, temperatureFS.getInUnit(TemperatureUnit.DEGREE_FAHRENHEIT), 0.1);
        float out = temperatureFS.getInUnit();
        assertEquals("Value should match", value, out, 0.001);
        MutableFloatScalar.Rel<TemperatureUnit> mfs = new MutableFloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, false);
        mfs.setSI(73);
        float safe = value;
        value = -200; // Approximate Celsius equivalent of 73 Kelvin
        checkContentsAndType(mfs, value, 1, tempUnit, false);
        value = safe; // Restore
        mfs.set(temperatureFS);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, false);
        FloatScalar.Rel<TemperatureUnit> temperature2FS = new FloatScalar.Rel<TemperatureUnit>(temperatureFS);
        assertTrue("temperature2FS should be equal to temperatureFS", temperature2FS.equals(temperatureFS));
        assertTrue("Value is Relative", temperatureFS.isRelative());
        assertFalse("Value is not Absolute", temperatureFS.isAbsolute());
        temperatureFS = new FloatScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        checkContentsAndType(temperatureFS, value, 0.001f, TemperatureUnit.KELVIN, false);
        out = temperatureFS.getSI();
        assertEquals("Value should match", value, out, 0.001);
        for (int i = -100; i <= 100; i++)
        {
            float v = i / 10.0f;
            mfs.setSI(v);
            assertEquals("intValue should round like Math.round", Math.round(v), mfs.intValue(), 0.0001);
            assertEquals("longValue should round like Math.round", Math.round(v), mfs.longValue(), 0.0001);
            assertEquals("floatValue should return the value", v, mfs.floatValue(), 0.0001);
            assertEquals("doubleValue should return the value", v, mfs.doubleValue(), 0.0001);
        }
    }

    /**
     * Test conversion to mutable equivalent and back.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void toMutableAndBackRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        float value2 = 38.0f;
        value2 = 12345;
        FloatScalar.Rel<TemperatureUnit> fs = new FloatScalar.Rel<TemperatureUnit>(value, tempUnit);
        FloatScalar.Rel<TemperatureUnit> fsCopy = fs.copy();
        MutableFloatScalar.Rel<TemperatureUnit> mfs = fs.mutable();
        checkContentsAndType(fs, value, 0.001f, tempUnit, false);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, false);
        checkContentsAndType(fsCopy, value, 0.001f, tempUnit, false);
        MutableFloatScalar.Rel<TemperatureUnit> mfsCopy = mfs.copy();
        checkContentsAndType(mfsCopy, value, 0.001f, tempUnit, false);
        MutableFloatScalar.Rel<TemperatureUnit> mmfs = mfs.mutable();
        checkContentsAndType(mmfs, value, 0.001f, tempUnit, false);
        assertEquals("hashCode is independent on mutability", fs.hashCode(), mfs.hashCode());
        // Modify mfs
        mfs.setInUnit(12345, TemperatureUnit.DEGREE_CELSIUS);
        checkContentsAndType(fs, value, 0.001f, tempUnit, false);
        checkContentsAndType(mfs, value2, 0.01f, tempUnit, false);
        checkContentsAndType(mfsCopy, value, 0.001f, tempUnit, false);
        checkContentsAndType(mmfs, value, 0.001f, tempUnit, false);
        FloatScalar.Rel<TemperatureUnit> ifs = mfs.immutable();
        assertTrue("Different value extremely likely results in different hashCode", fs.hashCode() != mfs.hashCode());
        // Restore value of mfs
        mfs.setValueSI(fs.getSI());
        checkContentsAndType(ifs, value2, 0.01f, tempUnit, false);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, false);
        checkContentsAndType(mmfs, value, 0.001f, tempUnit, false);
        mmfs.setSI(0);
        checkContentsAndType(mfs, value, 0.001f, tempUnit, false);
        assertEquals("value should be about -273", -273, mmfs.getInUnit(tempUnit), 0.2);
    }

    /**
     * Test the equals method.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        float value = 38.0f;
        FloatScalar.Rel<LengthUnit> fs = new FloatScalar.Rel<LengthUnit>(value, lengthUnit);
        assertTrue("Equal to itself", fs.equals(fs));
        assertFalse("Not equal to null", fs.equals(null));
        assertFalse("Not equal to some other kind of object; e.g. a String", fs.equals(new String("abc")));
        FloatScalar.Abs<LengthUnit> fsCounterPart = new FloatScalar.Abs<LengthUnit>(value, lengthUnit);
        assertFalse("Not equal if one Absolute and other Relative", fs.equals(fsCounterPart));
        FloatScalar.Rel<TemperatureUnit> fsWrongBaseUnit =
            new FloatScalar.Rel<TemperatureUnit>(value, TemperatureUnit.KELVIN);
        assertEquals("The underlying SI values are the same", fs.getSI(), fsWrongBaseUnit.getSI(), 0.0001f);
        assertFalse("Not equals because the standard SI unit differs", fs.equals(fsWrongBaseUnit));
        FloatScalar.Rel<LengthUnit> fsCompatibleUnit = new FloatScalar.Rel<LengthUnit>(38000.0f, LengthUnit.MILLIMETER);
        assertFalse("Units are different", fs.getUnit().equals(fsCompatibleUnit.getUnit()));
        assertTrue("equals returns true", fs.equals(fsCompatibleUnit));
        FloatScalar.Rel<LengthUnit> fsDifferentValue = new FloatScalar.Rel<LengthUnit>(123.456f, LengthUnit.MILLIMETER);
        assertFalse("Different value makes equals return false", fs.equals(fsDifferentValue));
    }

    /**
     * Test the relational operations
     */
    @SuppressWarnings("static-method")
    @Test
    public final void relOpRelTest()
    {
        FloatScalar.Rel<LengthUnit> base = new FloatScalar.Rel<LengthUnit>(123, LengthUnit.KILOMETER);
        FloatScalar.Rel<LengthUnit> same = new FloatScalar.Rel<LengthUnit>(123000, LengthUnit.METER);
        FloatScalar.Rel<LengthUnit> smaller = new FloatScalar.Rel<LengthUnit>(122999, LengthUnit.METER);
        FloatScalar.Rel<LengthUnit> larger = new FloatScalar.Rel<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertTrue("123km == 123000m", base.eq(same));
        assertFalse("NOT 123km != 123000m", base.ne(same));
        assertTrue("123km < 123001m", base.lt(larger));
        assertTrue("123km > 122999m", base.gt(smaller));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertFalse("NOT 123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km != 123001m", base.ne(larger));
        assertFalse("NOT 123km == 123001m", base.eq(larger));
        assertTrue("123km != 122999m", base.ne(smaller));
        assertFalse("NOT 123km == 122999m", base.eq(smaller));
        assertFalse("NOT 123km >= 123001m", base.ge(larger));
        assertFalse("NOT 123km <= 122999m", base.le(smaller));
        MutableFloatScalar.Rel<LengthUnit> same2 = new MutableFloatScalar.Rel<LengthUnit>(123000, LengthUnit.METER);
        MutableFloatScalar.Rel<LengthUnit> smaller2 = new MutableFloatScalar.Rel<LengthUnit>(122999, LengthUnit.METER);
        MutableFloatScalar.Rel<LengthUnit> larger2 = new MutableFloatScalar.Rel<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertTrue("123km == 123000m", base.eq(same2));
        assertFalse("NOT 123km != 123000m", base.ne(same2));
        assertTrue("123km < 123001m", base.lt(larger2));
        assertTrue("123km > 122999m", base.gt(smaller2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km != 123001m", base.ne(larger2));
        assertFalse("NOT 123km == 123001m", base.eq(larger2));
        assertTrue("123km != 122999m", base.ne(smaller2));
        assertFalse("NOT 123km == 122999m", base.eq(smaller2));
        assertFalse("NOT 123km >= 123001m", base.ge(larger2));
        assertFalse("NOT 123km <= 122999m", base.le(smaller2));
    }

    /**
     * Test the relational operations
     */
    @SuppressWarnings("static-method")
    @Test
    public final void relOpMutableRelTest()
    {
        MutableFloatScalar.Rel<LengthUnit> base = new MutableFloatScalar.Rel<LengthUnit>(123, LengthUnit.KILOMETER);
        MutableFloatScalar.Rel<LengthUnit> same = new MutableFloatScalar.Rel<LengthUnit>(123000, LengthUnit.METER);
        MutableFloatScalar.Rel<LengthUnit> smaller = new MutableFloatScalar.Rel<LengthUnit>(122999, LengthUnit.METER);
        MutableFloatScalar.Rel<LengthUnit> larger = new MutableFloatScalar.Rel<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertTrue("123km == 123000m", base.eq(same));
        assertFalse("NOT 123km != 123000m", base.ne(same));
        assertTrue("123km < 123001m", base.lt(larger));
        assertTrue("123km > 122999m", base.gt(smaller));
        assertTrue("123km >= 123000m", base.ge(same));
        assertFalse("NOT 123km > 123000m", base.gt(same));
        assertFalse("NOT 123km < 123000m", base.lt(same));
        assertTrue("123km <= 123000m", base.le(same));
        assertTrue("123km != 123001m", base.ne(larger));
        assertFalse("NOT 123km == 123001m", base.eq(larger));
        assertTrue("123km != 122999m", base.ne(smaller));
        assertFalse("NOT 123km == 122999m", base.eq(smaller));
        assertFalse("NOT 123km >= 123001m", base.ge(larger));
        assertFalse("NOT 123km <= 122999m", base.le(smaller));
        FloatScalar.Rel<LengthUnit> same2 = new FloatScalar.Rel<LengthUnit>(123000, LengthUnit.METER);
        FloatScalar.Rel<LengthUnit> smaller2 = new FloatScalar.Rel<LengthUnit>(122999, LengthUnit.METER);
        FloatScalar.Rel<LengthUnit> larger2 = new FloatScalar.Rel<LengthUnit>(123001, LengthUnit.METER);
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertTrue("123km == 123000m", base.eq(same2));
        assertFalse("NOT 123km != 123000m", base.ne(same2));
        assertTrue("123km < 123001m", base.lt(larger2));
        assertTrue("123km > 122999m", base.gt(smaller2));
        assertTrue("123km >= 123000m", base.ge(same2));
        assertFalse("NOT 123km > 123000m", base.gt(same2));
        assertFalse("NOT 123km < 123000m", base.lt(same2));
        assertTrue("123km <= 123000m", base.le(same2));
        assertTrue("123km != 123001m", base.ne(larger2));
        assertFalse("NOT 123km == 123001m", base.eq(larger2));
        assertTrue("123km != 122999m", base.ne(smaller2));
        assertFalse("NOT 123km == 122999m", base.eq(smaller2));
        assertFalse("NOT 123km >= 123001m", base.ge(larger2));
        assertFalse("NOT 123km <= 122999m", base.le(smaller2));
    }

    /**
     * Test the Math functions.
     */
    @SuppressWarnings("static-method")
    @Test
    public final void mathFunctionsTestRelTest()
    {
        float[] seedValues = {-10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f};
        for (float seedValue : seedValues)
        {
            float input = seedValue;
            MutableFloatScalar.Rel<LengthUnit> fs;
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.abs();
            MathTester.tester(input, "abs", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.abs(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.acos();
            MathTester.tester(input, "acos", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.acos(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.asin();
            MathTester.tester(input, "asin", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.asin(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.atan();
            MathTester.tester(input, "atan", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.atan(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.cbrt();
            MathTester.tester(input, "cbrt", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.cbrt(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.ceil();
            MathTester.tester(input, "ceil", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.ceil(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.cos();
            MathTester.tester(input, "cos", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.cos(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.cosh();
            MathTester.tester(input, "cosh", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.cosh(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.exp();
            MathTester.tester(input, "exp", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.exp(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.expm1();
            MathTester.tester(input, "expm1", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.expm1(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.floor();
            MathTester.tester(input, "floor", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.floor(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.log();
            MathTester.tester(input, "log", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.log(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.log10();
            MathTester.tester(input, "log10", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.log10(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.log1p();
            MathTester.tester(input, "log1p", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.log1p(f);
                }
            });
            for (int i = -10; i <= 10; i++)
            {
                final float exponent = i * 0.5f;
                fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
                fs.pow(exponent);
                MathTester.tester(input, "pow(" + exponent + ")", fs, 0.001, new FloatToFloat()
                {
                    @Override
                    public float function(final float f)
                    {
                        return (float) Math.pow(f, exponent);
                    }
                });
            }
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.rint();
            MathTester.tester(input, "rint", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.rint(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.round();
            MathTester.tester(input, "round", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.round(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.signum();
            MathTester.tester(input, "signum", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return Math.signum(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.sin();
            MathTester.tester(input, "sin", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.sin(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.sinh();
            MathTester.tester(input, "sinh", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.sinh(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.sqrt();
            MathTester.tester(input, "sqrt", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.sqrt(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.tan();
            MathTester.tester(input, "tan", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.tan(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.tanh();
            MathTester.tester(input, "tanh", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.tanh(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.toDegrees();
            MathTester.tester(input, "toDegrees", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.toDegrees(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.toRadians();
            MathTester.tester(input, "toRadians", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return (float) Math.toRadians(f);
                }
            });
            fs = new MutableFloatScalar.Rel<LengthUnit>(input, LengthUnit.METER);
            fs.inv();
            MathTester.tester(input, "inv", fs, 0.001, new FloatToFloat()
            {
                @Override
                public float function(final float f)
                {
                    return 1 / f;
                }
            });
        }
    }

    /**
     * Test plus(FloatScalarRel, FloatScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryplusOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Rel<?> result = FloatScalar.plus(left, right);
        assertEquals("value of element should be SI plus of contributing elements", left.getSI() + right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test minus(FloatScalarRel, FloatScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binaryminusOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Rel<?> result = FloatScalar.minus(left, right);
        assertEquals("value of element should be SI minus of contributing elements", left.getSI() - right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test multiply(FloatScalarRel, FloatScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarymultiplyOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Rel<?> result = FloatScalar.multiply(left, right);
        assertEquals("value of element should be SI multiply of contributing elements", left.getSI() * right.getSI(), result
            .getSI(), 0.001f);
    }

    /**
     * Test divide(FloatScalarRel, FloatScalarRel).
     */
    @SuppressWarnings("static-method")
    @Test
    public final void binarydivideOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatScalar.Rel<LengthUnit> left = new FloatScalar.Rel<LengthUnit>(leftValue, LengthUnit.MILE);
        FloatScalar.Rel<LengthUnit> right = new FloatScalar.Rel<LengthUnit>(rightValue, LengthUnit.MILE);
        MutableFloatScalar.Rel<?> result = FloatScalar.divide(left, right);
        assertEquals("value of element should be SI divide of contributing elements", left.getSI() / right.getSI(), result
            .getSI(), 0.001f);
    }

    /** */
    interface FloatToFloat
    {
        /**
         * @param f float; value
         * @return float value
         */
        float function(float f);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValue float; unprocessed value
         * @param operation String; description of method that is being tested
         * @param actualResult FloatScalar&lt;?&gt;; the actual result of the operation
         * @param precision double; expected accuracy
         * @param function FloatToFloat; encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final float inputValue, final String operation, final FloatScalar<?> actualResult,
            final double precision, final FloatToFloat function)
        {
            float expectedResult = function.function(inputValue);
            float got = actualResult.getSI();
            String description =
                String.format("%s(%f->%f should be equal to %f with precision %f", operation, inputValue, expectedResult,
                    got, precision);
            // System.out.println(description);
            assertEquals(description, expectedResult, got, precision);
        }

    }

}
