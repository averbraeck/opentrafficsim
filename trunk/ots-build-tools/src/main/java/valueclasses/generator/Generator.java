package valueclasses.generator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Generate the code for the value classes.
 * <p>
 * Copyright (c) 2013-2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights
 * reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 24 sep. 2014 <br>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class Generator
{
    /** Name of this program */
    static String generator = "the OpenTrafficSim valueclasses generator";

    /** Description of the day on which the files were generated */
    static String when;

    /** The serialVersionUID to put in the generated classes */
    static String serialVersionUID;

    /** Directory where the tree of files will be built */
    static String buildDir = "d:\\valueTree";

    /** Base directory / package */
    final static String packageBaseName = "org.opentrafficsim.core";

    /**
     * Open a file and write the package line and initial block comment.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @return BufferedWriter; the open file
     */
    public static BufferedWriter openFile(String relativePackage, String name, String description)
    {
        BufferedWriter writer = null;
        String dirList = relativePackage;
        String[] intermediateDirs = dirList.split("[\\.]");
        String path = buildDir;
        for (String intermediateDir : intermediateDirs)
        {
            path = path + File.separatorChar + intermediateDir;
        }
        File dir = new File(path);
        if (!dir.exists() && !dir.mkdirs())
        {
            throw new Error("Cannot create path \"" + path + "\"");
        }
        String fileName = path + File.separatorChar + name + ".java";
        try
        {
            writer = new BufferedWriter(new FileWriter(new File(fileName)));
            writer.write("package " + packageBaseName + "." + relativePackage + ";\r\n\r\n");
            writer.write("/**\r\n * "
                    + description
                    + "\r\n * <p>\r\n * This file was generated by "
                    + generator
                    + ", "
                    + when
                    + "\r\n * <p>\r\n"
                    + " * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights"
                    + " reserved. <br>\r\n"
                    + " * BSD-style license. See <a href=\"http://opentrafficsim.org/node/13\">OpenTrafficSim License</a>.\r\n"
                    + " * <p>\r\n" + " * @version " + when + " <br>\r\n"
                    + " * @author <a href=\"http://www.tbm.tudelft.nl/averbraeck\">Alexander Verbraeck</a>\r\n"
                    + " * @author <a href=\"http://www.tudelft.nl/pknoppers\">Peter Knoppers</a>\r\n" + " */\r\n");
        }
        catch (Exception e)
        {
            throw new Error("Cannot write file " + fileName);
        }
        return writer;
    }

    /**
     * Close a file that was opened with openFile.
     * @param writer BufferedWriter; the result of the preceding call to openFile
     */
    public static void closeFile(BufferedWriter writer)
    {
        try
        {
            writer.close();
        }
        catch (IOException exception)
        {
            exception.printStackTrace();
        }

    }

    /**
     * Write a class file for an abstract class.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateAbstractClass(String relativePackage, String name, String description, String typeInfo,
            String contents)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, description);
            writer.write("public abstract class " + name + typeInfo + "\r\n{\r\n    /** */\r\n"
                    + "    private static final long serialVersionUID = " + serialVersionUID + "L;\r\n" + "\r\n"
                    + contents + "}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Write a class file that defines an interface that does nothing but define it's own name.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param description String; the description that is inserted in the block comment at the start of the file
     */
    public static void generateEmptyInterface(String relativePackage, String name, String description)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, description);
            writer.write("public interface " + name + "\r\n{\r\n    //\r\n}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Generate the code for the value classes.
     * @param args String[]; the command line arguments (not used)
     */
    public static void main(String args[])
    {
        Date now = new Date();
        when = new SimpleDateFormat("dd MMM, yyyy").format(now);
        serialVersionUID = new SimpleDateFormat("yyyyMMdd").format(now);
        File testPath = new File(buildDir);
        if (!testPath.exists())
        {
            throw new Error("buildDir (" + buildDir + ") does not exist");
        }
        else if (!testPath.isDirectory())
        {
            throw new Error("buildDir (" + buildDir + ") is not a directory");
        }
        generateEmptyInterface("value", "Absolute",
                "Absolute values are quantities that are measured from some agreed upon reference point.");
        generateEmptyInterface("value", "Relative", "Relative values express differences.");
        generateEmptyInterface("value", "DenseData", "Values are stored densely.");
        generateEmptyInterface("value", "SparseData", "Values are stored sparsely (lots of zero values expected).");
        generateAbstractClass("value", "AbstractValue", "AbstractValue is a class to help construct Matrix, Complex, "
                + "and Vector but it does not extend java.lang.Number. The Scalar\r\n"
                + " * class <i>does</i> extend Number, and implements the same interfaces from Value.\r\n",
                "<U extends Unit<U>> implements Value<U>, Serializable", "\r\n"
                        + "    /** the unit of the value. */\r\n" + "    private final U unit;\r\n\r\n" + "    /**\r\n"
                        + "     * Create a new value\r\n" + "     * @param unit Unit; the unit of the value\r\n"
                        + "     */\r\n" + "    public AbstractValue(final U unit)\r\n" + "    {\r\n"
                        + "        this.unit = unit;\r\n" + "    }\r\n\r\n" + "    /** {@inheritDoc} */\r\n"
                        + "    @Override\r\n" + "    public final U getUnit()\r\n" + "    {\r\n"
                        + "        return this.unit;\r\n" + "    }\r\n\r\n" + "    /** {@inheritDoc} */\r\n"
                        + "    @Override\r\n" + "    public final double expressAsSIUnit(final double value)\r\n"
                        + "    {\r\n" + "        return ValueUtil.expressAsSIUnit(value, this.unit);\r\n"
                        + "    }\r\n\r\n" + "    /**\r\n"
                        + "     * @param value the value to convert in the specified unit for this scalar\r\n"
                        + "     * @return the value in the unit as specified for this scalar\r\n" + "     */\r\n"
                        + "    protected final double expressAsSpecifiedUnit(final double value)\r\n" + "    {\r\n"
                        + "        return ValueUtil.expressAsUnit(value, this.unit);\r\n" + "    }\r\n\r\n"
                        + "    /** {@inheritDoc} */\r\n" + "    @Override\r\n"
                        + "    public final boolean isAbsolute()\r\n" + "    {\r\n"
                        + "        return this instanceof Absolute;\r\n" + "    }\r\n\r\n"
                        + "    /** {@inheritDoc} */\r\n" + "    @Override\r\n"
                        + "    public final boolean isRelative()\r\n" + "    {\r\n"
                        + "        return this instanceof Relative;\r\n" + "    }\r\n");
    }

}
