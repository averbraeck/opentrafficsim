package valueclasses.generator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Generate the code for the value classes.
 * <p>
 * Copyright (c) 2013-2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights
 * reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 24 sep. 2014 <br>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class Generator
{
    /** Name of this program */
    static String generator = "the OpenTrafficSim valueclasses generator";

    /** Description of the day on which the files were generated */
    static String when;

    /** The serialVersionUID to put in the generated classes */
    static String serialVersionUID;

    /** Directory where the tree of files will be built */
    static String buildDir = "d:\\valueTree";

    /** Base directory / package */
    final static String packageBaseName = "org.opentrafficsim.core";

    /** Indent step */
    final static String indentStep = "    ";

    /**
     * Open a file and write the package line and initial block comment.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; descriptions of the generic parameters of the class
     * @return BufferedWriter; the open file
     */
    public static BufferedWriter openFile(String relativePackage, String name, String[] imports, String description,
            String[] genericParams)
    {
        BufferedWriter writer = null;
        String dirList = relativePackage;
        String[] intermediateDirs = dirList.split("[\\.]");
        String path = buildDir;
        for (String intermediateDir : intermediateDirs)
        {
            path = path + File.separatorChar + intermediateDir;
        }
        File dir = new File(path);
        if (!dir.exists() && !dir.mkdirs())
        {
            throw new Error("Cannot create path \"" + path + "\"");
        }
        String fileName = path + File.separatorChar + name + ".java";
        try
        {
            writer = new BufferedWriter(new FileWriter(new File(fileName)));
            writer.write("package " + packageBaseName + "." + relativePackage + ";\r\n\r\n");
            if (null != imports)
            {
                for (String importString : imports)
                {
                    if (importString.length() > 0)
                    {
                        writer.write("import " + importString + ";");
                    }
                    writer.write("\r\n");
                }
                writer.write("\r\n");
            }
            writer.write("/**\r\n * "
                    + description
                    + "\r\n * <p>\r\n * This file was generated by "
                    + generator
                    + ", "
                    + when
                    + "\r\n * <p>\r\n"
                    + " * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights"
                    + " reserved. <br>\r\n"
                    + " * BSD-style license. See <a href=\"http://opentrafficsim.org/node/13\">OpenTrafficSim License</a>.\r\n"
                    + " * <p>\r\n" + " * @version " + when + " <br>\r\n"
                    + " * @author <a href=\"http://www.tbm.tudelft.nl/averbraeck\">Alexander Verbraeck</a>\r\n"
                    + " * @author <a href=\"http://www.tudelft.nl/pknoppers\">Peter Knoppers</a>\r\n");
            if (null != genericParams)
            {
                for (String param : genericParams)
                {
                    writer.write(" * @param " + param + "\r\n");
                }
            }
            writer.write(" */\r\n");
        }
        catch (Exception e)
        {
            throw new Error("Cannot write file " + fileName);
        }
        return writer;
    }

    /**
     * Close a file that was opened with openFile.
     * @param writer BufferedWriter; the result of the preceding call to openFile
     */
    public static void closeFile(BufferedWriter writer)
    {
        try
        {
            writer.close();
        }
        catch (IOException exception)
        {
            exception.printStackTrace();
        }

    }

    /**
     * Return the String that defines the serialVersionUID.
     * @param indent String; prepended to each output line
     * @return String
     */
    private static String buildSerialVersionUID(final String indent)
    {
        return buildField(indent, "private static final long serialVersionUID = " + serialVersionUID + "L", "");
    }

    /**
     * Write a class file.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param qualifiers String; qualifiers that go before the class key word; e.g. <cite>public abstract</cite>
     * @param typeInfo String; the text that goes immediately after the class name
     * @param generateSerialVersionUID boolean; if true a serialVersionUID is put in the result
     * @param contents String; the text that goes in the class
     */
    private static void generateClass(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String qualifiers, String typeInfo, boolean generateSerialVersionUID,
            String contents)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, imports, description, genericParams);
            writer.write(qualifiers + " class " + name + prependSpaceIfNonEmpty(typeInfo) + "\r\n{\r\n");
            if (generateSerialVersionUID)
            {
                writer.write(buildSerialVersionUID(indentStep));
            }
            writer.write(contents + "}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Write a class file for an abstract class.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateAbstractClass(String relativePackage, String name, String[] imports,
            String description, String[] genericParams, String typeInfo, String contents)
    {
        generateClass(relativePackage, name, imports, description, genericParams, "public abstract", typeInfo, true,
                contents);
    }

    /**
     * Write a class file for a final class that cannot be instantiated.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateFinalClass(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String typeInfo, String contents)
    {
        generateClass(
                relativePackage,
                name,
                imports,
                description,
                genericParams,
                "public final",
                typeInfo,
                false,
                buildMethod(indentStep, "private||" + name, "This class shall never be instantiated.", null, null,
                        null, new String[]{"// Prevent instantiation of this class"}, true) + contents);
    }

    /**
     * Insert a space before a String if (and only if) the String has length > 0 and does not start with a &lt;
     * character.
     * @param argument String; the String to (potentially) modify
     * @return String
     */
    private static String prependSpaceIfNonEmpty(String argument)
    {
        if (argument.length() == 0 || argument.startsWith("<"))
        {
            return argument;
        }
        return " " + argument;
    }

    /**
     * Write an interface file that defines an interface that does nothing but define it's own name.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param body String; the body of the interface file
     */
    public static void generateInterface(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String typeInfo, String body)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, imports, description, genericParams);
            writer.write("public interface " + name + prependSpaceIfNonEmpty(typeInfo) + "\r\n{\r\n");
            if (null != body)
            {
                writer.write(body);
            }
            else
            {
                writer.write("    // This interface does not force anything to be implemented in classes that implement it\r\n");
            }
            writer.write("}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Create a String that defines one method.
     * @param indent String; prefix for all output lines
     * @param qualifiersTypeAndName String; the qualifiers, the type and the name of the method separated by vertical
     *            bars, e.g. <cite>final public|double|getDoubleValue</cite>. If this method overrides a method in a
     *            parent class set this parameter to null.
     * @param description String; description of the method
     * @param params String[]; one String for each parameter of the method. Each parameter string consists of
     *            qualifiers, type, name separated by vertical bars, e.g. <cite>final int|index|index of the
     *            entry</cite>
     * @param exceptions String; exception type and description separated by a vertical bar, or null if this method does
     *            not throw exceptions
     * @param pragma String; text that goes after the JavaDoc, but before the start of the method code
     * @param body String[]; the lines of the body of the method. Lines on the outermost level should start with 0
     *            spaces
     * @param constructor boolean; if true; the new method is a constructor; if false; the new method is not a
     *            constructor
     * @return String; the Java source code of the method.
     */
    public static String buildMethod(String indent, String qualifiersTypeAndName, String description, String[] params,
            String exceptions, String pragma, String[] body, boolean constructor)
    {
        final int maxLineLength = 121;
        StringBuilder construction = new StringBuilder();
        String[] fields = qualifiersTypeAndName.split("[|]");
        if (null != description)
        {
            construction.append(indent + "/**\r\n" + indent + " * ");
            construction.append(description);
            construction.append("\r\n");
            if (null != params)
            {
                for (String param : params)
                {
                    String[] paramFields = param.split("[|]");
                    if (3 != paramFields.length)
                    {
                        throw new Error("param should consist of three fields separated by |; got \"" + param + "\"");
                    }
                    if (paramFields[0].startsWith("final "))
                    {
                        paramFields[0] = paramFields[0].substring(6);
                    }
                    String line = indent + " * @param " + paramFields[1] + " " + escapeHTML(paramFields[0]) + ";";
                    String remainder = paramFields[2];
                    String[] words = remainder.split("[ ]");
                    for (String word : words)
                    {
                        if (line.length() + 1 + word.length() >= maxLineLength)
                        {
                            construction.append(line + "\r\n");
                            line = indent + " *" + indentStep + indentStep + indentStep + word;
                        }
                        else
                        {
                            line += " " + word;
                        }
                    }
                    construction.append(line);
                    construction.append("\r\n");
                }
            }
            if (fields.length < 3)
            {
                throw new Error("qualifiersTypeAndName should consist of at least three fields separated by |; got "
                        + qualifiersTypeAndName);
            }
            if (!"void".equals(fields[1]) && !constructor)
            {
                construction.append(indent + " * @return ");
                construction.append(escapeHTML(fields[1]));
                if (4 == fields.length)
                {
                    construction.append("; " + escapeHTML(fields[3]));
                }
                construction.append("\r\n");
            }
            if (null != exceptions)
            {
                String[] exceptionFields = exceptions.split("[|]");
                if (exceptionFields.length != 2)
                {
                    throw new Error("exceptions should consist of two fields separated by |; got \"" + exceptions
                            + "\"");
                }
                construction.append(indent + " * @throws " + exceptionFields[0] + " " + exceptionFields[1] + "\r\n");
            }
            construction.append(indent + " */\r\n");
        }
        else
        {
            construction.append(indent + "/** {@inheritDoc} */\r\n" + indent + "@Override\r\n");
        }
        if (null != pragma)
        {
            if (pragma.length() == 0)
                throw new Error("pragma should not be the empty string");
            construction.append(indent + pragma + "\r\n");
        }
        String line = indent;
        if (fields[0].length() > 0)
        {
            line = line + fields[0] + " ";
        }
        if (fields[1].length() > 0)
        {
            line += fields[1] + " ";
        }
        line += fields[2] + "(";
        String sep = "";
        if (null != params)
        {
            for (String param : params)
            {
                String[] paramFields = param.split("[|]");
                if (!paramFields[1].startsWith("<"))
                {
                    String paramText = paramFields[0] + " " + paramFields[1];
                    if (line.length() + sep.length() + paramText.length() + 1 > maxLineLength)
                    {
                        if (!sep.equals(""))
                        {
                            sep = ",";
                        }
                        construction.append(line + sep + "\r\n");
                        line = indent + indentStep + indentStep + paramText;
                    }
                    else
                    {
                        line += sep + paramText;
                    }
                    sep = ", ";
                }
            }
        }
        line += ")";
        construction.append(line);
        if (null != exceptions)
        {
            String append = " throws " + exceptions.split("[|]")[0];
            if (line.length() + append.length() > maxLineLength)
            {
                construction.append("\r\n" + indent + indentStep + indentStep);
            }
            construction.append(append);
        }
        if (null != body)
        {
            construction.append("\r\n" + indent + "{\r\n");
            final String bodyIndent = indent + indentStep;
            for (String bodyLine : body)
            {
                construction.append(bodyIndent);
                construction.append(bodyLine);
                construction.append("\r\n");
            }
            construction.append(indent + "}\r\n");
        }
        else
        {
            construction.append(";\r\n");
        }
        construction.append("\r\n");
        return construction.toString();
    }

    /**
     * Replace HTML-special character by their escaped versions.
     * @param input String; text to convert to clean HTML
     * @return String; text with correct HTML excapes
     */
    private static String escapeHTML(final String input)
    {
        StringBuilder construction = new StringBuilder();
        for (int pos = 0; pos < input.length(); pos++)
        {
            String letter = input.substring(pos, pos + 1);
            if (letter.equals("<"))
            {
                construction.append("&lt;");
            }
            else if (letter.equals(">"))
            {
                construction.append("&gt;");
            }
            else if (letter.equals("&"))
            {
                construction.append("&amp;");
            }
            else
            {
                construction.append(letter);
            }
        }
        return construction.toString();
    }

    /**
     * Create a String that describes one field.
     * @param indent String; prepended to each output line
     * @param field String; the type and name of the field
     * @param description String; the description of the field
     * @return String
     */
    public static String buildField(String indent, String field, String description)
    {
        return indent + "/** " + description + " */\r\n" + indent + field + ";\r\n\r\n";
    }

    /**
     * Information about the math functions
     * <p>
     * Copyright (c) 2013-2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights
     * reserved. <br>
     * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
     * <p>
     * @version 30 sep. 2014 <br>
     * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
     */
    static class MathFunctionEntry
    {
        /** Name of the function */
        public final String name;

        /** Additional argument with description */
        public final String argument;

        /** If set, the result of the function is always double (regardless of the argument) */
        public final boolean castToFloatRequired;

        /** Description of the function */
        public final String description;

        /** If set this function also appears in *MathFunctionsImpl */
        public final boolean appearsInMathFunctionsImpl;

        /**
         * Create a new mathFunctionEntry.
         * @param name String; name of the function
         * @param argument String; additional argument of the function (set to null if the function has only one
         *            argument)
         * @param castToFloatRequired boolean; if true; the result of the function is double (regardless of the
         *            argument)
         * @param appearsInMathFunctionsImpl boolean; if true; this function must also appear in the *MathFunctionImpl
         *            class
         * @param comment String; description of the function
         */
        public MathFunctionEntry(final String name, final String argument, final boolean castToFloatRequired,
                boolean appearsInMathFunctionsImpl, final String comment)
        {
            this.name = name;
            this.argument = argument;
            this.castToFloatRequired = castToFloatRequired;
            this.appearsInMathFunctionsImpl = appearsInMathFunctionsImpl;
            this.description = comment;
        }
    }

    /** The math functions */
    public static MathFunctionEntry[] mathFunctions =
            {
                    new MathFunctionEntry("abs", null, false, false, "Set the value(s) to their absolute value."),
                    new MathFunctionEntry("acos", null, true, false,
                            "Set the value(s) to the arc cosine of the value(s); the resulting angle is in the range 0.0 through pi."),
                    new MathFunctionEntry("asin", null, true, false,
                            "Set the value(s) to the arc sine of the value(s); the resulting angle is in the range -pi/2 through pi/2."),
                    new MathFunctionEntry("atan", null, true, false,
                            "Set the value(s) to the arc tangent of the value(s); the resulting angle is in the range -pi/2 through pi/2."),
                    new MathFunctionEntry("cbrt", null, true, true, "Set the value(s) to the(ir) cube root."),
                    new MathFunctionEntry("ceil", null, false, false,
                            "Set the value(s) to the smallest (closest to negative infinity) value(s) that are greater than or equal to the\r\n"
                                    + indentStep + " * argument and equal to a mathematical integer."),
                    new MathFunctionEntry("cos", null, true, false,
                            "Set the value(s) to the trigonometric cosine of the value(s)."),
                    new MathFunctionEntry("cosh", null, true, true,
                            "Set the value(s) to the hyperbolic cosine of the value(s)."),
                    new MathFunctionEntry("exp", null, true, false,
                            "Set the value(s) to Euler's number e raised to the power of the value(s)."),
                    new MathFunctionEntry("expm1", null, true, true,
                            "Set the value(s) to Euler's number e raised to the power of the value(s) minus 1 (e^x - 1)."),
                    new MathFunctionEntry("floor", null, false, false,
                            "Set the value(s) to the largest (closest to positive infinity) value(s) that are less than or equal to the\r\n"
                                    + indentStep + " * argument and equal to a mathematical integer."),
                    new MathFunctionEntry("log", null, true, false,
                            "Set the value(s) to the natural logarithm (base e) of the value(s)."),
                    new MathFunctionEntry("log10", null, true, true,
                            "Set the value(s) to the base 10 logarithm of the value(s)."),
                    new MathFunctionEntry("log1p", null, true, true,
                            "Set the value(s) to the natural logarithm of the sum of the value(s) and 1."),
                    new MathFunctionEntry("pow", "double|x|the value to use as the power", true, false,
                            "Set the value(s) to the value(s) raised to the power of the argument."),
                    new MathFunctionEntry("rint", null, true, false,
                            "Set the value(s) to the value(s) that are closest in value to the argument and equal to a mathematical integer."),
                    new MathFunctionEntry("round", null, true, true,
                            "Set the value(s) to the closest long to the argument with ties rounding up."),
                    new MathFunctionEntry("signum", null, true, true,
                            "Set the value(s) to the signum function of the value(s); zero if the argument is zero, 1.0 if the argument is\r\n"
                                    + indentStep + "     * greater than zero, -1.0 if the argument is less than zero."),
                    new MathFunctionEntry("sin", null, true, false,
                            "Set the value(s) to the trigonometric sine of the value(s)."),
                    new MathFunctionEntry("sinh", null, true, true,
                            "Set the value(s) to the hyperbolic sine of the value(s)."),
                    new MathFunctionEntry("sqrt", null, true, false,
                            "Set the value(s) to the correctly rounded positive square root of the value(s)."),
                    new MathFunctionEntry("tan", null, true, false,
                            "Set the value(s) to the trigonometric tangent of the value(s)."),
                    new MathFunctionEntry("tanh", null, true, true,
                            "Set the value(s) to the hyperbolic tangent of the value(s)."),
                    new MathFunctionEntry("toDegrees", null, true, true,
                            "Set the value(s) to approximately equivalent angle(s) measured in degrees."),
                    new MathFunctionEntry("toRadians", null, true, true,
                            "Set the value(s) to approximately equivalent angle(s) measured in radians."),
                    new MathFunctionEntry("inv", null, true, false,
                            "Set the value(s) to the complement (1.0/x) of the value(s)."),};

    /**
     * Generate the code for the value classes.
     * @param args String[]; the command line arguments (not used)
     */
    public static void main(String args[])
    {
        Date now = new Date();
        when = new SimpleDateFormat("dd MMM, yyyy").format(now);
        serialVersionUID = new SimpleDateFormat("yyyyMMdd").format(now);
        File testPath = new File(buildDir);
        if (!testPath.exists())
        {
            throw new Error("buildDir (" + buildDir + ") does not exist");
        }
        else if (!testPath.isDirectory())
        {
            throw new Error("buildDir (" + buildDir + ") is not a directory");
        }
        generateInterface("value", "Absolute", null,
                "Absolute values are quantities that are measured from some agreed upon reference point.", null, "",
                null);
        generateInterface("value", "Relative", null, "Relative values express differences.", null, "", null);
        generateInterface("value", "DenseData", null, "Values are stored densely.", null, "", null);
        generateInterface("value", "SparseData", null, "Values are stored sparsely (lots of zero values expected).",
                null, "", null);
        generateAbstractClass(
                "value",
                "AbstractValue",
                new String[]{"java.io.Serializable", "", "org.opentrafficsim.core.unit.Unit"},
                "AbstractValue is a class to help construct Matrix, Complex, "
                        + "and Vector but it does not extend java.lang.Number. The Scalar\r\n"
                        + " * class <i>does</i> extend Number, and implements the same interfaces from Value.",
                new String[]{"<U> the Unit of the value(s) in this AbstractValue. Used for setting, getting and displaying the value(s)"},
                "<U extends Unit<U>> implements Value<U>, Serializable",
                buildField(indentStep, "private final U unit", "The unit of the AbstractValue")
                        + buildMethod(indentStep, "public||AbstractValue", "Construct a new AbstractValue.",
                                new String[]{"final U|unit|the unit of the new AbstractValue"}, null, null,
                                new String[]{"this.unit = unit;"}, true)
                        + buildMethod(indentStep, "public final|U|getUnit", null, null, null, null,
                                new String[]{"return this.unit;"}, false)
                        + buildMethod(indentStep, "protected final|double|expressAsSIUnit", null,
                                new String[]{"final double|value|"}, null, null,
                                new String[]{"return ValueUtil.expressAsSIUnit(value, this.unit);"}, false)
                        + buildMethod(indentStep, "protected final|double|expressAsSpecifiedUnit",
                                "Convert a value in SI standard unit into the unit of this AbstractValue",
                                new String[]{"final double|value|the value in standard SI unit"}, null, null,
                                new String[]{"return ValueUtil.expressAsUnit(value, this.unit);"}, false)
                        + buildMethod(indentStep, "public final|boolean|isAbsolute", null, null, null, null,
                                new String[]{"return this instanceof Absolute"}, false)
                        + buildMethod(indentStep, "public final|boolean|isRelative", null, null, null, null,
                                new String[]{"return this instanceof Relative"}, false));
        generateFinalClass(
                "value",
                "Format",
                null,
                "Format a floating point number in a reasonable way. <br>\r\n"
                        + " * I've experienced problems with the %g conversions that caused array bounds violations. Those versions of the JRE that do\r\n"
                        + " * <b>not</b> throw such Exceptions use one digit less than specified in the %g conversions. <br >\r\n"
                        + " * TODO: check how to always format numbers corresponding to the Locale used.",
                null,
                "",
                buildField(indentStep, "public static final int DEFAULTSIZE = 9",
                        "Default total width of formatted value.")
                        + buildField(indentStep, "public static final int DEFAULTPRECISION = 3",
                                "Default numberof fraction digits.")
                        + buildMethod(indentStep, "private static|String|formatString", "Build a format String.",
                                new String[]{"final int|width|the number of characters in the result",
                                        "final int|precision|the number of fractional digits in the result",
                                        "final String|converter|the format conversion specifier"}, null, null,
                                new String[]{"return String.format(\"%%%d.%d%s\", width, precision, converter);"},
                                false) + buildFormatMethods("float") + buildFormatMethods("double"));
        generateInterface("value", "MathFunctions", new String[]{"java.io.Serializable"},
                "Interface to force all functions of Math that must be implemented.", null, "extends Serializable",
                buildAllMathFunctions());
        generateInterface(
                "value",
                "Value",
                new String[]{"org.opentrafficsim.core.unit.Unit"},
                "Value is a static interface that forces implementation of a few unit- and value-related methods.",
                new String[]{"<U> the unit type"},
                "<U extends Unit<U>>",
                buildMethod(indentStep, "public final|U|getUnit", "Return the unit of the Value.", null, null, null,
                        null, false)
                        + buildMethod(indentStep, "|double|expressAsSIUnit", "Convert a value to the standard SI unit",
                                new String[]{"final double|value|the value to convert to the standard SI unit"}, null,
                                null, null, false)
                        + buildMethod(indentStep, "|boolean|isAbsolute", "Indicate whether this is an Absolute Value",
                                null, null, null, null, false)
                        + buildMethod(indentStep, "|boolean|isRelative", "Indicate whether this is a Relative Value",
                                null, null, null, null, false)
                        + buildMethod(indentStep, "|Value<U>|copy", "Create a deep copy of this Value", null, null,
                                null, null, false));

        generateClass(
                "value",
                "ValueException",
                null,
                "Exception that is thrown for bad indices or non-rectangular, or effectively empty arrays",
                null,
                "public",
                "extends Exception",
                true,
                buildMethod(indentStep, "public||ValueException", "Construct a new ValueException.", null, null, null,
                        new String[]{"super();"}, true)
                        + buildMethod(indentStep, "public||ValueException", "Construct a new ValueException.",
                                new String[]{"final String|message|description of the problem"}, null, null,
                                new String[]{"super(message);"}, true)
                        + buildMethod(indentStep, "public||ValueException", "Construct a new ValueException.",
                                new String[]{"final String|message|description of the problem",
                                        "final Throwable|cause|the cause of this ValueException"}, null, null,
                                new String[]{"super(message, cause);"}, true)
                        + buildMethod(
                                indentStep,
                                "public||ValueException",
                                "Construct a new ValueException.",
                                new String[]{
                                        "final String|message|description of the problem",
                                        "final Throwable|cause|the cause of this ValueException",
                                        "final boolean|enableSuppression|whether or not suppression is enabled or disabled",
                                        "final boolean|writableStackTrace|whether or not the stack trace should be writable"},
                                null, null,
                                new String[]{"super(message, cause, enableSuppression, writableStackTrace);"}, true));
        generateFinalClass(
                "value",
                "ValueUtil",
                null,
                "ValueUtil implements a couple of unit-related static methods.",
                null,
                "",
                buildMethod(indentStep, "public static|double|expressAsSIUnit",
                        "Convert a value in a given unit into the equivalent in the standard SI unit", new String[]{
                                "final double|value|the value to convert into standard SI unit",
                                "final Unit<?>|unit|the unit of the given value"}, null, null, new String[]{
                                "if (unit instanceof OffsetUnit<?>)", "{",
                                "    return (value - ((OffsetUnit<?>) unit).getOffsetToStandardUnit())",
                                "            * unit.getConversionFactorToStandardUnit();", "}",
                                "return value * unit.getConversionFactorToStandardUnit();"}, false)

                        + buildMethod(indentStep, "public static|double|expressAsUnit",
                                "Convert a value in the standard SI unit into another unit", new String[]{
                                        "final double|siValue|the given value in SI standard unit",
                                        "final Unit<?>|targetUnit|the unit to convert the value into"}, null, null,
                                new String[]{"if (targetUnit instanceof OffsetUnit<?>)", "{",
                                        "    return siValue / targetUnit().getConversionFactorToStandardUnit()",
                                        "            + ((OffsetUnit<?>) targetUnit).getOffsetToStandardUnit();", "}",
                                        "return siValue / targetUnit().getConversionFactorToStandardUnit();"}, false));

        generateInterface(
                "value.vdouble",
                "DoubleMathFunctions",
                new String[]{"org.opentrafficsim.core.value.MathFunctions"},
                "Force implementation of multiply and divide.",
                null,
                "",
                buildMethod(indentStep, "|void|multiply", "Scale the value(s) by a factor",
                        new String[]{"double|factor|the multiplier"}, null, null, null, false)
                        + buildMethod(indentStep, "|void|divide",
                                "Scale the value(s) by the inverse of a factor; i.e. a divisor",
                                new String[]{"double|divisor|the divisor"}, null, null, null, false)

        );

        generateFinalClass("value.vdouble", "DoubleMathFunctionsImpl",
                new String[]{"import cern.colt.function.tdouble.DoubleFunction"},
                "DoubleFunction implementations of the standard Math functions.", null, "",
                buildMathFunctionImpl("Double"));

        generateInterface(
                "value.vfloat",
                "FloatMathFunctions",
                new String[]{"org.opentrafficsim.core.value.MathFunctions"},
                "Force implementation of multiply and divide.",
                null,
                "extends MathFunctions",
                buildMethod(indentStep, "|void|multiply", "Scale the value(s) by a factor.",
                        new String[]{"float|factor|the multiplier"}, null, null, null, false)
                        + buildMethod(indentStep, "|void|divide",
                                "Scale the value(s) by the inverse of a factor; i.e. a divisor.",
                                new String[]{"float|divisor|the divisor"}, null, null, null, false)

        );

        generateFinalClass(
                "value.vfloat",
                "FloatMathFunctionsImpl",
                new String[]{"import cern.colt.function.tdouble.FloatFunction"},
                "FloatFunction implementations of the standard Math functions.",
                null,
                "",
                buildDoubleOrFloatFunction("cbrt", "Float", "(float)")
                        + buildDoubleOrFloatFunction("cosh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("expm1", "Float", "(float)")
                        + buildDoubleOrFloatFunction("log10", "Float", "(float)")
                        + buildDoubleOrFloatFunction("log1p", "Float", "(float)")
                        + buildDoubleOrFloatFunction("round", "Float", "")
                        + buildDoubleOrFloatFunction("signum", "Float", "")
                        + buildDoubleOrFloatFunction("sinh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("tanh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("toDegrees", "Float", "(float)")
                        + buildDoubleOrFloatFunction("toRadians", "Float", "(float)"));

        generateScalarClass("Float", false);
        generateScalarClass("Float", true);
        generateScalarClass("Double", false);
        generateScalarClass("Double", true);

        generateVectorClass("Float", false);
        generateVectorClass("Float", true);
        generateVectorClass("Double", false);
        generateVectorClass("Double", true);
    }

    /**
     * Generate the java code for *MathFunctionsImpl.
     * @param type String; type of the result of the generated functions
     * @return String; java code
     */
    private static String buildMathFunctionImpl(String type)
    {
        String useCast = (type.startsWith("D") ? "" : type + " "); // append a space
        StringBuilder construction = new StringBuilder();
        for (MathFunctionEntry mfu : mathFunctions)
        {
            if (mfu.appearsInMathFunctionsImpl)
            {
                construction.append("    /**\r\n     * Function that returns <tt>Math." + mfu.name
                        + "(a)</tt>.\r\n     */\r\n" + "    public static final " + type + "Function " + mfu.name
                        + " = new " + type + "Function()\r\n    {\r\n" + "        @Override\r\n        public "
                        + type.toLowerCase() + " apply(final " + type.toLowerCase() + " a)\r\n"
                        + "        {\r\n            return " + useCast + "Math." + mfu.name + "(a);\r\n"
                        + "        }\r\n    };\r\n\r\n");
            }
        }
        return construction.toString();
    }

    /**
     * Generate the java code that declares all the math functions
     * @return String; java code
     */
    private static String buildAllMathFunctions()
    {
        StringBuilder construction = new StringBuilder();
        for (MathFunctionEntry mfu : mathFunctions)
        {
            construction.append(buildMethod(indentStep, "|void|" + mfu.name, mfu.description, null == mfu.argument
                    ? new String[]{} : new String[]{mfu.argument}, null, null, null, false));
        }
        return construction.toString();
    }

    /**
     * Generate a class file for a vector type.
     * @param vectorType String; must be <cite>Float</cite>, or <cite>Double</cite> (starting with a capital latter)
     * @param mutable boolean; if true the mutable class is generated; of false the immutable class is generated
     */
    private static void generateVectorClass(String vectorType, boolean mutable)
    {
        final String lowerCaseType = vectorType.toLowerCase();
        final String outerIndent = indentStep;
        final String mutableType = mutable ? "Mutable" : "Immutable ";
        generateAbstractClass(
                "value.v" + lowerCaseType + ".vector",
                (mutable ? "Mutable" : "") + vectorType + "Vector",
                mutable ? new String[]{"org.opentrafficsim.core.unit.SICoefficients",
                        "org.opentrafficsim.core.unit.SIUnit", "org.opentrafficsim.core.unit.Unit",
                        "org.opentrafficsim.core.value.Absolute", "org.opentrafficsim.core.value.DenseData",
                        "org.opentrafficsim.core.value.Relative", "org.opentrafficsim.core.value.SparseData",
                        "org.opentrafficsim.core.value.ValueException",
                        "org.opentrafficsim.core.value.v" + lowerCaseType + "." + vectorType + "MathFunctions",
                        "org.opentrafficsim.core.value.v" + lowerCaseType + "." + vectorType + "MathFunctionsImpl",
                        "org.opentrafficsim.core.value.v" + lowerCaseType + ".scalar." + vectorType + "Scalar", "",
                        "cern.colt.matrix.t" + lowerCaseType + "." + vectorType + "Matrix1D",
                        "cern.colt.matrix.t" + lowerCaseType + ".impl.Dense" + vectorType + "Matrix1D",
                        "cern.colt.matrix.t" + lowerCaseType + ".impl.Sparse" + vectorType + "Matrix1D",
                        "cern.jet.math.t" + lowerCaseType + "." + vectorType + "Functions"} : new String[]{
                        "java.io.Serializable", "", "org.opentrafficsim.core.unit.Unit",
                        "org.opentrafficsim.core.value.Absolute", "org.opentrafficsim.core.value.AbstractValue",
                        "org.opentrafficsim.core.value.DenseData", "org.opentrafficsim.core.value.Format",
                        "org.opentrafficsim.core.value.Relative", "org.opentrafficsim.core.value.SparseData",
                        "org.opentrafficsim.core.value.ValueException", "org.opentrafficsim.core.value.ValueUtil",
                        "org.opentrafficsim.core.value.v" + lowerCaseType + ".scalar." + vectorType + "Scalar", "",
                        "cern.colt.matrix.t" + lowerCaseType + "." + vectorType + "Matrix1D",
                        "cern.colt.matrix.t" + lowerCaseType + ".impl.Dense" + vectorType + "Matrix1D",
                        "cern.colt.matrix.t" + lowerCaseType + ".impl.Sparse" + vectorType + "Matrix1D"},
                mutableType + vectorType + "Vector.",
                new String[]{"<U> the Unit for this " + (mutable ? "Mutable" : "") + vectorType + "Vector"},
                "<U extends Unit<U>> extends "
                        + (mutable ? vectorType + "Vector" : "AbstractValue")
                        + "<U> implements "
                        + (mutable ? "\r\n" + indentStep + indentStep + "Write" + vectorType + "VectorFunctions<U>, "
                                + vectorType + "MathFunctions" : "Serializable,\r\n" + indentStep + "ReadOnly"
                                + vectorType + "VectorFunctions<U>"),
                mutable
                        ? buildMethod(outerIndent, "protected||Mutable" + vectorType + "Vector",
                                "Construct a new Mutable" + vectorType + "Vector.",
                                new String[]{"final U|unit|the unit of the new Mutable" + vectorType + "Vector"}, null,
                                null, new String[]{"super(unit);",
                                        "// System.out.println(\"Created Mutable" + vectorType + "Vector\");"}, true)
                                + buildField(outerIndent, "private boolean copyOnWrite = false",
                                        "If set, any modification of the data must be preceded by replacing the data "
                                                + "with a local copy.")
                                + buildMethod(outerIndent, "private|boolean|isCopyOnWrite",
                                        "Retrieve the value of the copyOnWrite flag.", null, null, null,
                                        new String[]{"return this.copyOnWrite;"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "final|void|setCopyOnWrite",
                                        "Change the copyOnWrite flag.",
                                        new String[]{"final boolean|copyOnWrite|the new value for the copyOnWrite flag"},
                                        null, null, new String[]{"this.copyOnWrite = copyOnWrite;"}, false)
                                + buildMethod(outerIndent, "public final|void|normalize", null, null,
                                        "ValueException|when zSum is 0", null, new String[]{
                                                vectorType.toLowerCase() + " sum = zSum();",
                                                "if (0 == sum)",
                                                "{",
                                                indentStep
                                                        + "throw new ValueException(\"zSum is 0; cannot normalize\");",
                                                "}", "checkCopyOnWrite();", "for (int i = 0; i < size(); i++)", "{",
                                                indentStep + "safeSet(i, safeGet(i) / sum);", "}"}, false)
                                + buildVectorSubClass(outerIndent, "Abs", "Absolute " + mutableType + vectorType
                                        + "Vector", "Mutable" + vectorType + "Vector<U>", "Absolute", "Mutable"
                                        + vectorType + "Vector", true)
                                + buildVectorSubClass(outerIndent, "Rel", "Relative " + mutableType + vectorType
                                        + "Vector", "Mutable" + vectorType + "Vector<U>", "Relative", "Mutable"
                                        + vectorType + "Vector", true)
                                + buildMethod(outerIndent, "public abstract|" + vectorType + "Vector<U>|immutable",
                                        "Make (immutable) " + vectorType + "Vector equivalent for any type of Mutable"
                                                + vectorType + "Vector.", null, null, null, null, false)
                                + buildMethod(
                                        outerIndent,
                                        "public final|Mutable" + vectorType + "Vector<U>|copy",
                                        null,
                                        null,
                                        null,
                                        null,
                                        new String[]{
                                                "return immutable().mutable();",
                                                "// FIXME: This may cause both the original and the copy to be deep copied later",
                                                "// Maybe it is better to make one deep copy now..."}, false)
                                + buildMethod(
                                        outerIndent,
                                        "protected final|void|checkCopyOnWrite",
                                        "Check the copyOnWrite flag and, if it is set, make a deep copy of the data and clear the flag.",
                                        null,
                                        null,
                                        null,
                                        new String[]{
                                                "if (this.isCopyOnWrite())",
                                                "{",
                                                indentStep
                                                        + "// System.out.println(\"CopyOnWrite is set: Copying data\");",
                                                indentStep + "deepCopyData();", indentStep + "setCopyOnWrite(false);",
                                                "}"}, false)
                                + buildMethod(outerIndent, "public final|void|setSI", null, new String[]{
                                        "final int|index|", "final " + vectorType.toLowerCase() + "|valueSI"},
                                        "ValueException|when index is invalid", null,
                                        new String[]{"checkIndex(index);", "checkCopyOnWrite();",
                                                "safeSet(index, valueSI);"}, false)
                                + buildMethod(outerIndent, "public final|void|set", null, new String[]{
                                        "final int|index|", "final " + vectorType + "Scalar<U>|value"},
                                        "ValueException|when index is invalid", null,
                                        new String[]{"setSI(index, value.getvalueSI());"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "public final|void|setInUnit",
                                        null,
                                        new String[]{"final int|index|",
                                                "final " + vectorType.toLowerCase() + "|value", "final U|valueUnit|"},
                                        "ValueException|when index is invalid",
                                        null,
                                        new String[]{
                                                "// TODO: creating a "
                                                        + vectorType
                                                        + "Scalar.Abs along the way may not be the most efficient way to do this...",
                                                "setSI(index, new " + vectorType
                                                        + "Scalar.Abs<U>(value, valueUnit).getValueSI());"}, false)
                                + buildMethod(outerIndent, "public final|void|assign",
                                        "Execute a function on a cell by cell basis.",
                                        new String[]{"final cern.colt.function.t" + vectorType.toLowerCase() + "."
                                                + vectorType + "Function|" + vectorType.substring(0, 1).toLowerCase()
                                                + "|the function to apply"}, null, null,
                                        new String[]{
                                                "checkCopyOnWrite();",
                                                "getVectorSI().assign(" + vectorType.substring(0, 1).toLowerCase()
                                                        + ");"}, false)
                                + buildVectorFunctions(outerIndent, vectorType)
                                + buildMethod(outerIndent, "public final|void|multiply", null,
                                        new String[]{"final float|constant|"}, null, null, new String[]{"assign("
                                                + vectorType + "Functions.mult(constant));"}, false)
                                + buildMethod(outerIndent, "public final|void|divide", null,
                                        new String[]{"final float|constant|"}, null, null, new String[]{"assign("
                                                + vectorType + "Functions.div(constant));"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "private|Mutable" + vectorType
                                                + "Vector<U>|incrementValueByValue|this modified Mutable" + vectorType
                                                + "Vector",
                                        "Increment the values in this Mutable" + vectorType
                                                + "Vector by the corresponding values in a " + vectorType + "Vector.",
                                        new String[]{"final "
                                                + vectorType
                                                + "Vector<U>|increment|the values by which to increment the corresponding values in this Mutable"
                                                + vectorType + "Vector"},
                                        "ValueException|when the vectors do not have the same size", null,
                                        new String[]{
                                                "checkSizeAndCopyOnWrite(increment);",
                                                "for (int index = size(); --index >= 0;)",
                                                "{",
                                                indentStep
                                                        + "safeSet(index, safeGet(index) + increment.safeGet(index));",
                                                "}", "return this;"}, false)
                                + buildMethod(outerIndent, "public final|Mutable" + vectorType
                                        + "Vector<U>|incrementBy|this modified Mutable" + vectorType + "Vector",
                                        "Increment the values in this Mutable" + vectorType
                                                + "Vector by the corresponding values in a Relative " + vectorType
                                                + "Vector.", new String[]{"final " + vectorType
                                                + "Vector.Rel<U>|rel|the Relative " + vectorType + "Vector"},
                                        "ValueException|when the vectors do not have the same size", null,
                                        new String[]{"return incrementValueByValue(rel);"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "private|Mutable" + vectorType
                                                + "Vector<U>|decrementValueByValue|this modified Mutable" + vectorType
                                                + "Vector",
                                        "Decrement the values in this Mutable" + vectorType
                                                + "Vector by the corresponding values in a " + vectorType + "Vector.",
                                        new String[]{"final "
                                                + vectorType
                                                + "Vector<U>|decrement|contains the amounts by which to decrement the corresponding values in this Mutable"
                                                + vectorType + "Vector"},
                                        "ValueException|when the vectors do not have the same size", null,
                                        new String[]{
                                                "checkSizeAndCopyOnWrite(decrement);",
                                                "for (int index = size(); --index >= 0;)",
                                                "{",
                                                indentStep
                                                        + "safeSet(index, safeGet(index) - decrement.safeGet(index));",
                                                "}", "return this;"}, false)
                                + buildMethod(outerIndent, "public final|Mutable" + vectorType
                                        + "Vector<U>|decrementBy|this modified Mutable" + vectorType + "Vector",
                                        "Decrement the values in this Mutable" + vectorType
                                                + "Vector by the corresponding values in a Relative " + vectorType
                                                + "Vector.", new String[]{"final " + vectorType
                                                + "Vector.Rel<U>|rel|the Relative " + vectorType + "Vector"},
                                        "ValueException|when the vectors do not have the same size", null,
                                        new String[]{"return decrementValueByValue(rel);"}, false)
                                + buildMethod(outerIndent,
                                        "protected final|Mutable" + vectorType
                                                + "Vector.Rel<U>|decrementBy|this modified Relative Mutable" + vectorType
                                                + "Vector", "Decrement the values in this Relative Mutable"
                                                + vectorType + "Vector by the corresponding values in an Absolute "
                                                + vectorType + "Vector.", new String[]{"final " + vectorType
                                                + "Vector.Abs<U>|abs|the Absolute " + vectorType + "Vector"},
                                        "ValueException|when the vectors do not have the same size", null,
                                        new String[]{"return (Mutable" + vectorType
                                                + "Vector.Rel<U>) decrementValueByValue(abs);"}, false)

                        // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX END OF MUTABLE SPECIFIC METHODS

                        : buildField(outerIndent, "private " + vectorType + "Matrix1D vectorSI",
                                "The internal storage for the vector; the values are stored in standard SI unit; storage can be dense or sparse.")
                                + buildMethod(outerIndent, "protected||" + (mutable ? "Mutable" : " ") + vectorType
                                        + "Vector", "Construct a new " + mutableType + vectorType + "Vector.",
                                        new String[]{"final U|unit|the unit of the new " + (mutable ? "Mutable" : "")
                                                + vectorType + "Vector"}, null, null, new String[]{"super(unit);",
                                                "// System.out.println(\"Created " + vectorType + "Vector\");"}, true)
                                + buildVectorSubClass(outerIndent, "Abs", "Absolute " + mutableType + vectorType
                                        + "Vector", vectorType + "Vector<U>", "Absolute", vectorType + "Vector", false)
                                + buildVectorSubClass(outerIndent, "Rel", "Relative " + mutableType + vectorType
                                        + "Vector", vectorType + "Vector<U>", "Relative", vectorType + "Vector", false)
                                + buildMethod(outerIndent, "protected final|" + lowerCaseType
                                        + "Matrix1D|getVectorSI|the data in the internal format",
                                        "Retrieve the internal data.", null, null, null,
                                        new String[]{"return this.vectorSI;"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "protected final|void|deepCopyData",
                                        "Make a deep copy of the data (used ONLY in the Mutable" + vectorType
                                                + "Vector sub class).",
                                        null,
                                        null,
                                        null,
                                        new String[]{"this.vectorSI = getVectorSI().copy(); // makes a deep copy, using multithreading"},
                                        false)
                                + buildMethod(
                                        outerIndent,
                                        "public abstract|Mutable" + vectorType
                                                + "Vector<U>|mutable|mutable version of this " + vectorType + "Vector",
                                        "Create a mutable version of this "
                                                + vectorType
                                                + "Vector. <br>\r\n"
                                                + outerIndent
                                                + " * The mutable version is created with a shallow copy of the data and the internal "
                                                + "copyOnWrite flag set. The first\r\n"
                                                + outerIndent
                                                + " * operation in the mutable version that modifies the data shall trigger a deep copy of the data.",
                                        null, null, null, null, false)
                                + buildMethod(
                                        outerIndent,
                                        "protected final|void|initialize",
                                        "Import the values and convert them into the SI standard unit.",
                                        new String[]{"final " + vectorType.toLowerCase()
                                                + "[]|values|an array of values"},
                                        null,
                                        null,
                                        new String[]{
                                                "this.vectorSI = createMatrix1D(values.length);",
                                                "if (getUnit().equals(getUnit().getStandardUnit()))",
                                                "{",
                                                indentStep + "this.vectorSI.assign(values);",
                                                "}",
                                                "else",
                                                "{",
                                                indentStep + "for (int index = 0; index < values.length; index++)",
                                                indentStep + "{",
                                                indentStep + indentStep + "safeSet(index, "
                                                        + (vectorType.startsWith("F") ? "(float) " : "")
                                                        + "expressAsSIUnit(values[index]));", indentStep + "}", "}"},
                                        false)
                                + buildMethod(outerIndent, "protected final|void|initialize",
                                        "Import the values from an existing " + vectorType
                                                + "Matrix1D. This makes a shallow copy.", new String[]{"final "
                                                + vectorType + "Matrix1D|values|the values",}, null, null,
                                        new String[]{"this.vectorSI = values;"}, false)
                                + buildMethod(outerIndent, "protected final|void|initialize",
                                        "Construct the vector and store the values in the standard SI Unit.",
                                        new String[]{"final " + vectorType + "Scalar<U>[]|values|an array of values"},
                                        "valueException|when values is empty", null, new String[]{
                                                "this.vectorSI = createMatrix1D(values.length);",
                                                "for (int index = 0; index < values.length; index++)", "{",
                                                indentStep + "safeSet(index, values[index].getValueSI());",
                                                indentStep + "}"}, false)
                                + buildMethod(outerIndent, "protected abstract|" + vectorType
                                        + "Matrix1D|createMatrix1D|an instance of the right type of " + vectorType
                                        + "Matrix1D (absolute / relative, dense / sparse, etc.)",
                                        "Create storage for the data. <br/>\r\n" + outerIndent
                                                + " * This method must be implemented by each leaf class.",
                                        new String[]{"final int|size|the number of cells in the vector"}, null, null,
                                        null, false)
                                + buildMethod(outerIndent, "public final|" + vectorType.toLowerCase()
                                        + "[]|getValuesSI|array of values in the standard SI unit", "Create a "
                                        + vectorType.toLowerCase()
                                        + "[] array filled with the values in the standard SI unit.", null, null, null,
                                        new String[]{"return this.vectorSI.toArray(); // this makes a deep copy"},
                                        false)
                                + buildMethod(outerIndent, "public final|" + vectorType.toLowerCase()
                                        + "[]|getValuesInUnit|the values in the original unit", "Create a "
                                        + vectorType.toLowerCase()
                                        + "[] array filled with the values in the original unit.", null, null, null,
                                        new String[]{"return getValuesInUnit(getUnit());"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "public final|" + vectorType.toLowerCase()
                                                + "[]|getValuesInUnit|the values converted into the specified unit",
                                        "Create a " + vectorType.toLowerCase()
                                                + "[] array filled with the values converted into a specified unit.",
                                        new String[]{"final U|targetUnit|the unit into which the values are converted for display"},
                                        null, null, new String[]{
                                                "float[] values = this.vectorSI.toArray();",
                                                "for (int i = 0; i < values.length; i++)",
                                                "{",
                                                indentStep + "values[i] = "
                                                        + (vectorType.startsWith("F") ? "(float) " : "")
                                                        + "ValueUtil.expressAsUnit(values[i], targetUnit);", "}",
                                                "return values;"}, false)
                                + buildMethod(outerIndent, "public final|int|size", null, null, null, null,
                                        new String[]{"return (int) this.vectorSI.size();"}, false)
                                + buildMethod(outerIndent, "public final|" + vectorType.toLowerCase() + "|getSI", null,
                                        new String[]{"final int|index|"}, "ValueException|", null, new String[]{
                                                "checkIndex(index);", "return safeGet(index);"}, false)
                                + buildMethod(outerIndent, "public final|float|getInUnit", null,
                                        new String[]{"final int|index|"}, "ValueException", null,
                                        new String[]{"return " + (vectorType.startsWith("F") ? "(float) " : "")
                                                + "expressAsSpecifiedUnit(getSI(index));"}, false)
                                + buildMethod(outerIndent, "public final|" + vectorType.toLowerCase() + "|getInUnit",
                                        null, new String[]{"final int|index|", "final U|targetUnit|"},
                                        "ValueException", null, new String[]{"return "
                                                + (vectorType.startsWith("F") ? "(float) " : "")
                                                + "ValueUtil.expressAsUnit(getSI(index), targetUnit);"}, false)
                                + buildMethod(outerIndent, "public final|" + vectorType.toLowerCase() + "|zSum", null,
                                        null, null, null, new String[]{"return this.vectorSI.zSum();"}, false)
                                + buildMethod(outerIndent, "public final|int|cardinality", null, null, null, null,
                                        new String[]{"return this.vectorSI.cardinality();"}, false)
                                + buildMethod(outerIndent,
                                        "public final|String|toString|printable string with the vector contents", null,
                                        null, null, null, new String[]{"return toString(getUnit());"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "public final|String|toString|printable string with the vector contents",
                                        "Print this " + vectorType
                                                + "Vector with the values expressed in the specified unit.",
                                        new String[]{"final U|displayUnit|the unit into which the values are converted for display"},
                                        null,
                                        null,
                                        new String[]{
                                                "StringBuffer buf = new StringBuffer();",
                                                "if (this instanceof Mutable" + vectorType + "Vector)",
                                                "{",
                                                indentStep + "buf.append(\"Mutable   \");",
                                                "if (this instanceof Mutable" + vectorType + "Vector.Abs.Dense)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Abs Dense  \");",
                                                indentStep + "}",
                                                indentStep + "else if (this instanceof Mutable" + vectorType
                                                        + "Vector.Rel.Dense)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Rel Dense  \");",
                                                indentStep + "}",
                                                indentStep + "else if (this instanceof Mutable" + vectorType
                                                        + "Vector.Abs.Sparse)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Abs Sparse \");",
                                                indentStep + "}",
                                                indentStep + "else if (this instanceof Mutable" + vectorType
                                                        + "Vector.Rel.Sparse)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Rel Sparse \");",
                                                indentStep + "}",
                                                indentStep + "else",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"??? \");",
                                                indentStep + "}",
                                                "}",
                                                "else",
                                                "{",
                                                indentStep + "buf.append(\"Immutable \");",
                                                "if (this instanceof " + vectorType + "Vector.Abs.Dense)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Abs Dense  \");",
                                                indentStep + "}",
                                                indentStep + "else if (this instanceof " + vectorType
                                                        + "Vector.Rel.Dense)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Rel Dense  \");",
                                                indentStep + "}",
                                                indentStep + "else if (this instanceof " + vectorType
                                                        + "Vector.Abs.Sparse)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Abs Sparse \");",
                                                indentStep + "}",
                                                indentStep + "else if (this instanceof " + vectorType
                                                        + "Vector.Rel.Sparse)",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"Rel Sparse \");",
                                                indentStep + "}",
                                                indentStep + "else",
                                                indentStep + "{",
                                                indentStep + indentStep + "buf.append(\"??? \");",
                                                indentStep + "}",
                                                "}",
                                                "buf.append(\"[\" + displayUnit.getAbbreviation() + \"]\");",
                                                "for (int i = 0; i < size(); i++)",
                                                "{",
                                                indentStep
                                                        + (vectorType.startsWith("F") ? "float f = (float) "
                                                                : "double d = ")
                                                        + "ValueUtil.expressAsUnit(safeGet(i), displayUnit);",
                                                indentStep + "buf.append(\" \" + Format.format("
                                                        + vectorType.substring(0, 1).toLowerCase() + "));", "}",
                                                "return buf.toString();"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "protected final|void|checkSize",
                                        "Centralized size equality check.",
                                        new String[]{"final " + vectorType + "Vector<?>|other|other " + vectorType
                                                + "Vector"},
                                        "ValueException|when vectors have unequal size",
                                        null,
                                        new String[]{
                                                "if (size() != other.size())",
                                                "{",
                                                indentStep
                                                        + "throw new ValueException(\"The vectors have different sizes: "
                                                        + "\" + size() + \" != \" + other.size());", "}"}, false)
                                + buildMethod(outerIndent, "protected final|void|checkSize",
                                        "Centralized size equality check.",
                                        new String[]{"final " + vectorType.toLowerCase() + "[]|other|array of "
                                                + vectorType.toLowerCase()},
                                        "ValueException|when vectors have unequal size", null, new String[]{
                                                "if (size() != other.length)",
                                                "{",
                                                "throw new ValueException(\"The vector and the array have different sizes: "
                                                        + "\" + size() + \" != \" + other.length);", "}"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "protected final|void|checkIndex",
                                        "Check that a provided index is valid.",
                                        new String[]{"final int|index|the value to check"},
                                        "ValueException|when index is invalid",
                                        null,
                                        new String[]{
                                                "if (index < 0 || index >= size())",
                                                "{",
                                                indentStep
                                                        + "throw new ValueException(\"index out of range (valid range is 0..\" "
                                                        + "+ (size() - 1) + \", got \" + index + \")\");", "}"}, false)
                                + buildMethod(outerIndent, "protected final|" + vectorType.toLowerCase()
                                        + "|safeGet|the value stored at that index",
                                        "Retrieve a value in vectorSI without checking validity of the index.",
                                        new String[]{"final int|index|the index"}, null, null,
                                        new String[]{"return this.vectorSI.getQuick(index);"}, false)
                                + buildMethod(outerIndent, "protected final|void|safeSet",
                                        "Modify a value in vectorSI without checking validity of the index.",
                                        new String[]{
                                                "final int|index|the index",
                                                "final " + vectorType.toLowerCase()
                                                        + "|valueSI|the new value for the entry in vectorSI"}, null,
                                        null, new String[]{"this.vectorSI.setQuick(index, valueSI);"}, false)
                                + buildMethod(outerIndent, "protected final|" + vectorType
                                        + "Matrix1D|deepCopyOfData|deep copy of the data",
                                        "Create a deep copy of the data.", null, null, null,
                                        new String[]{"return this.vectorSI.copy();"}, false)
                                + buildMethod(outerIndent, "protected static <U extends Unit<U>>|" + vectorType
                                        + "Scalar<U>[]|checkNonEmpty|the provided array",
                                        "Check that a provided array can be used to create some descendant of a "
                                                + vectorType + "Vector.", new String[]{
                                                "final " + vectorType + "Scalar<U>[]|"
                                                        + vectorType.substring(0, 1).toLowerCase()
                                                        + "sArray|the provided array",
                                                "Unit|<U>|the unit of the " + vectorType + "Scalar array"},
                                        "ValueException|when the provided array has length equal to 0", null,
                                        new String[]{
                                                "if (0 == " + vectorType.substring(0, 1).toLowerCase()
                                                        + "sArray.length)",
                                                "{",
                                                indentStep + "throw new ValueException(",
                                                indentStep + indentStep + indentStep + "\"Cannot create a "
                                                        + vectorType + "Vector or Mutable" + vectorType
                                                        + "Vector from an empty array of " + vectorType + "Scalar\");",
                                                "}", "return fsArray;"}, false)
                                + buildMethod(
                                        outerIndent,
                                        "public final|int|hashcode",
                                        null,
                                        null,
                                        null,
                                        null,
                                        new String[]{"final int prime = 31;", "int result = 1;",
                                                "result = prime * result + this.vectorSI.hashCode();", "return result;"},
                                        false)
                                + buildMethod(
                                        outerIndent,
                                        "public final|boolean|equals",
                                        null,
                                        new String[]{"final Object|obj|"},
                                        null,
                                        null,
                                        new String[]{
                                                "if (this == obj)",
                                                "{",
                                                indentStep + "return true;",
                                                "}",
                                                "if (obj == null)",
                                                "{",
                                                "return false;",
                                                "}",
                                                "if (!(obj instanceof " + vectorType + "Vector))",
                                                "{",
                                                indentStep + "return false;",
                                                "}",
                                                vectorType + "Vector<?> other = (" + vectorType + "Vector<?>) obj;",
                                                "// unequal if not both absolute or both relative",
                                                "if (this.isAbsolute() != other.isAbsolute() || this.isRelative() != other.isRelative())",
                                                "{",
                                                indentStep + "return false;",
                                                "}",
                                                "// unequal if the standard SI units differ",
                                                "if (!this.getUnit().getStandardUnit().equals(other.getUnit().getStandardUnit()))",
                                                "{", indentStep + "return false;", "}",
                                                "// Colt's equals also tests the size of the vector",
                                                "if (!getVectorSI().equals(other.getVectorSI()))", "{",
                                                indentStep + "return false;", "}", "return true;"}, false)

        );
    }

    /**
     * Generate the code for the *Functions in Mutable*Vector.
     * @param indent String; prefix for all output lines
     * @param vectorType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @return String; java code
     */
    private static String buildVectorFunctions(final String indent, final String vectorType)
    {
        StringBuilder construction = new StringBuilder();
        for (MathFunctionEntry mfu : mathFunctions)
        {
            construction.append(buildMethod(indent, "public final|void|" + mfu.name, null, null != mfu.argument
                    ? new String[]{"final double" + "|x|"} : null, null, null, new String[]{"assign(" + vectorType
                    + (mfu.appearsInMathFunctionsImpl ? "MathFunctionsImpl." : "Functions.") + mfu.name
                    + (null != mfu.argument ? "(" + (vectorType.startsWith("F") ? "(float) " : "") : "")
                    + (null != mfu.argument ? "x)" : "") + ");"}, false));
        }

        return construction.toString();
    }

    /**
     * Generate the Java code for a sub class of vector
     * @param indent String; prefix for each output line
     * @param name String; name of the sub class, e.g. <cite>Abs</cite> or <cite>Rel</cite>
     * @param longName String; full name of the sub class, e.g. <cite>Absolute Immutable FloatVector</cite> or
     *            <cite>Relative Mutable DoubleVector</cite>
     * @param extendsString String; something like <cite>DoubleScalar&lt;U&gt;</cite>
     * @param implementsString String; something like <cite>Absolute, Comparable&lt;Abs&lt;U&gt;&gt;</cite>
     * @param parentClassName String; name of the class that is being sub-classed
     * @param mutable boolean; if true; the class file for the mutable version is generated; if false; the class file
     *            for the immutable version is generated
     * @return String; java code implementing the sub class
     */
    private static String buildVectorSubClass(final String indent, final String name, final String longName,
            final String extendsString, final String implementsString, final String parentClassName, boolean mutable)
    {
        final String absRelType = longName.split(" ")[0];
        final String floatType = extendsString.contains("Float") ? "Float" : "Double";
        StringBuilder construction = new StringBuilder();
        construction.append(indent + "/**\r\n" + indent + " * @param <U> Unit\r\n" + indent + " */\r\n");
        construction.append(indent + "public abstract static class " + name + "<U extends Unit<U>> extends "
                + extendsString + " implements " + implementsString + "\r\n" + indent + "{\r\n");
        final String contentIndent = indent + indentStep;
        construction.append(buildSerialVersionUID(contentIndent));
        construction.append(buildMethod(contentIndent, "protected||" + name, "Construct a new " + longName + ".",
                new String[]{"final U|unit|the unit of the new " + longName}, null, null, new String[]{"super(unit);",
                        "// System.out.println(\"Created " + name + "\");"}, true));
        construction.append(buildVectorSubSubClass(contentIndent, absRelType, "Dense", absRelType + " Dense "
                + parentClassName, mutable));
        construction.append(buildVectorSubSubClass(contentIndent, absRelType, "Sparse", absRelType + " Sparse "
                + parentClassName, mutable));
        construction.append(buildMethod(contentIndent, "public final|" + floatType + "Scalar." + name + "<U>|get",
                null, new String[]{"final int|index|"}, "valueException|when index < 0 or index >= size()", null,
                new String[]{"return new " + floatType + "Scalar." + name
                        + "<U>(getInUnit(index, getUnit()), getUnit());"}, false));
        construction.append(indent + "}\r\n\r\n");
        /*
         * construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName +
         * " from an existing " + absRelType + " Immutable " + floatType + "Scalar.", new String[]{"final " +
         * parentClassName + "." + name + "<U>|value|the reference"}, null, null, new String[]{
         * "super(value.getUnit());", "// System.out.println(\"Created " + name + "\");", "initialize(value);"}, true));
         * construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName +
         * " from an existing " + absRelType + " Mutable" + floatType + "Scalar.", new String[]{"final " + " Mutable" +
         * floatType + "Scalar." + name + "<U>|value|the reference"}, null, null, new String[]{
         * "super(value.getUnit());", "// System.out.println(\"Created " + name + "\");", "initialize(value);"}, true));
         * construction.append(buildMethod(contentIndent, "public final|" + "Mutable" + floatType + "Scalar." + name +
         * "<U>|mutable", null, null, null, null, new String[]{"return new Mutable" + floatType + "Scalar." + name +
         * "<U>(this);"}, false)); if (mutable) { construction.append(buildMethod(contentIndent, "public final|" +
         * parentClassName + "." + name + "<U>|immutable", null, null, null, null, new String[]{"return new " +
         * parentClassName + "." + name + "<U>(this);"}, false)); } construction.append(buildMethod(contentIndent,
         * "public final|int|compareTo", null, new String[]{"final|" + name + "<U> o|"}, null, null, new
         * String[]{"return new " + floatType + "(getValueSI()).compareTo(o.getValueSI());"}, false));
         * construction.append(buildMethod(contentIndent, "public final|" + (mutable ? "Mutable" : "") + parentClassName
         * + "." + name + "<U>|copy", null, null, null, null, new String[]{mutable ? "return new Mutable" + floatType +
         * "Scalar." + name + "<U>(this);" : "return this;"}, false)); construction.append(indent + "}\r\n\r\n");
         */
        return construction.toString();
    }

    /**
     * Generate the code for a vector sub sub class.
     * @param indent String; prefix of all output lines
     * @param absRel String; either <cite>Absolute</cite>, or <cite>Relative</cite>
     * @param denseOrSparse String; either <cite>Dense</cite>, or <cite>Sparse</cite>
     * @param longName String; something like <cite>Absolute Dense Immutable FloatVector</cite>
     * @param mutable boolean; if true; the code for the mutable version is generated; if false; the code for the
     *            immutable version is generated
     * @return String; Java code
     */
    private static String buildVectorSubSubClass(final String indent, final String absRel, final String denseOrSparse,
            final String longName, boolean mutable)
    {
        final String fixedLongName = mutable ? longName : longName.replaceFirst("( \\S*$)", " Immutable$1");
        final String floatingTypeName = longName.replaceFirst(".* (.*)Vector", "$1").replace("Mutable", "");
        final String vectorTypeName = longName.replaceFirst(".* (.*)$", "$1");
        final String immutableTypeName =
                vectorTypeName.startsWith("Mutable") ? vectorTypeName.substring(7) : vectorTypeName;
        StringBuilder construction = new StringBuilder();
        construction.append(indent + "/**\r\n" + indent + " * @param <U> Unit\r\n" + indent + " */\r\n");
        construction.append(indent + "public static class " + denseOrSparse + "<U extends Unit<U>> extends "
                + longName.split(" ")[0].substring(0, 3) + "<U>" + " implements " + denseOrSparse + "Data\r\n" + indent
                + "{\r\n");
        final String contentIndent = indent + indentStep;
        construction.append(buildSerialVersionUID(contentIndent));
        construction.append(buildMethod(contentIndent, "public||" + denseOrSparse, "Construct a new " + fixedLongName
                + ".", new String[]{
                "final " + floatingTypeName.toLowerCase() + "[]|values|the " + (mutable ? "initial " : "")
                        + "values of the entries in the new " + fixedLongName,
                "final U|unit|the unit of the new " + fixedLongName}, null, null, new String[]{"super(unit);",
                "// System.out.println(\"Created " + denseOrSparse + "\");", "initialize(values);"}, true));
        construction.append(buildMethod(contentIndent, "public||" + denseOrSparse, "Construct a new " + fixedLongName
                + ".", new String[]{"final " + floatingTypeName + "Scalar." + absRel.substring(0, 3)
                + "<U>[]|values|the " + (mutable ? "initial " : "") + "values of the entries in the new "
                + fixedLongName}, "valueException|when values has zero entries", null, new String[]{
                "super(checkNonEmpty(values)[0].getUnit());",
                "// System.out.println(\"Created " + denseOrSparse + "\");", "initialize(values);"}, true));
        construction.append(buildMethod(contentIndent, "protected||" + denseOrSparse, "For package internal use only.",
                new String[]{
                        "final " + floatingTypeName + "Matrix1D|values|the " + (mutable ? "initial " : "")
                                + "values of the entries in the new " + fixedLongName,
                        "final U|unit|the unit of the new " + fixedLongName}, null, null, mutable ? new String[]{
                        "super(unit);", "// System.out.println(\"Created " + denseOrSparse + "\");",
                        "setCopyOnWrite(true);", "initialize(values); // shallow copy"} : new String[]{"super(unit);",
                        "// System.out.println(\"Created " + denseOrSparse + "\");",
                        "initialize(values); // shallow copy"}, true));
        if (mutable)
        {
            construction.append(buildMethod(contentIndent,
                    "public final|" + floatingTypeName + "Vector." + absRel.substring(0, 3) + "." + denseOrSparse
                            + "<U>|immutable", null, null, null, null, new String[]{
                            "setCopyOnWrite(true);",
                            "return new " + floatingTypeName + "Vector." + absRel.substring(0, 3) + "." + denseOrSparse
                                    + "<U>(getVectorSI(), getUnit());"}, false));
        }
        construction.append(buildMethod(contentIndent,
                "public final|Mutable" + immutableTypeName + "." + absRel.substring(0, 3) + "." + denseOrSparse
                        + "<U>|mutable", null, null, null, null, mutable ? new String[]{
                        "setCopyOnWrite(true);",
                        "return new Mutable" + immutableTypeName + "." + absRel.substring(0, 3) + "." + denseOrSparse
                                + "<U>(getVectorSI(), getUnit());"} : new String[]{"return new Mutable"
                        + immutableTypeName + "." + absRel.substring(0, 3) + "." + denseOrSparse
                        + "<U>(getVectorSI(), getUnit());"}, false));
        construction.append(buildMethod(contentIndent, "protected final|" + floatingTypeName
                + "Matrix1D|createMatrix1D", null, new String[]{"final int|size|"}, null, null,
                new String[]{"return new " + denseOrSparse + floatingTypeName + "Matrix1D(size);"}, false));
        if (!mutable)
        {
            construction.append(buildMethod(contentIndent,
                    "public final|" + immutableTypeName + "." + absRel.substring(0, 3) + "." + denseOrSparse
                            + "<U>|copy", null, null, null, null, new String[]{"return this; // That was easy..."},
                    false));
        }
        construction.append(indent + "}\r\n\r\n");
        return construction.toString();
    }

    /**
     * Generate a class file for a scalar type.
     * @param scalarType String; must be <cite>Float</cite>, or <cite>Double</cite> (starting with a capital latter)
     * @param mutable boolean; if true the mutable class is generated; of false the immutable class is generated
     */
    private static void generateScalarClass(String scalarType, boolean mutable)
    {
        final String lowerCaseType = scalarType.toLowerCase();
        final String outerIndent = indentStep;
        final String cast = scalarType.equals("Double") ? "" : "(float) ";
        final String mutableType = mutable ? "Mutable" : "Immutable ";
        generateAbstractClass(
                "value.v" + lowerCaseType + ".scalar",
                (mutable ? "Mutable" : "") + scalarType + "Scalar",
                mutable ? new String[]{"org.opentrafficsim.core.unit.SICoefficients",
                        "org.opentrafficsim.core.unit.SIUnit", "org.opentrafficsim.core.unit.Unit",
                        "org.opentrafficsim.core.value.Absolute", "org.opentrafficsim.core.value.Relative",
                        "org.opentrafficsim.core.value.ValueUtil",
                        "org.opentrafficsim.core.value.v" + lowerCaseType + "." + scalarType + "MathFunctions"}
                        : new String[]{"org.opentrafficsim.core.unit.Unit", "org.opentrafficsim.core.value.Absolute",
                                "org.opentrafficsim.core.value.Relative", "org.opentrafficsim.core.value.Scalar",
                                "org.opentrafficsim.core.value.ValueUtil"},
                (mutable ? "Mutable" : "Immutable ") + scalarType + "Scalar.",
                new String[]{"<U> the unit of the values in the constructor and for display"},
                "<U extends Unit<U>> extends " + (mutable ? scalarType : "") + "Scalar<U>"
                        + (mutable ? " implements " + scalarType + "MathFunctions" : ""),
                (mutable ? "" : buildField(outerIndent, "private " + lowerCaseType + " valueSI",
                        "The value, stored in the standard SI unit."))
                        + buildMethod(outerIndent, "protected||" + (mutable ? "Mutable" : " ") + scalarType + "Scalar",
                                "Construct a new " + mutableType + scalarType + "Scalar.",
                                new String[]{"final U|unit|the unit of the new " + (mutable ? "Mutable" : "")
                                        + scalarType + "Scalar"}, null, null, new String[]{"super(unit);"}, true)
                        + buildScalarSubClass(outerIndent, "Abs", "Absolute " + mutableType + scalarType + "Scalar",
                                scalarType + "Scalar<U>", "Absolute, Comparable<Abs<U>>", scalarType + "Scalar",
                                mutable)
                        + buildScalarSubClass(outerIndent, "Rel", "Relative " + mutableType + scalarType + "Scalar",
                                scalarType + "Scalar<U>", "Relative, Comparable<Rel<U>>", scalarType + "Scalar",
                                mutable)
                        + (mutable
                                ? buildMethod(
                                        outerIndent,
                                        "public abstract|" + scalarType
                                                + "Scalar<U>|immutable|immutable version of this " + scalarType
                                                + "Scalar",
                                        "Construct an immutable version of this Mutable"
                                                + scalarType
                                                + "Scalar. <br>\r\n"
                                                + outerIndent
                                                + " * The immutable version is created as a deep copy of this. Delayed copying is not worthwhile for a Scalar.",
                                        null, null, null, null, false)
                                        + buildMethod(
                                                outerIndent,
                                                "final|void|setSI",
                                                "Replace the stored value by the supplied value which is expressed in the standard SI unit.",
                                                new String[]{"final "
                                                        + scalarType.toLowerCase()
                                                        + "|valueSI|the value to store (value must already be in the standard SI unit)"},
                                                null, null, new String[]{"setValueSI(valueSI);"}, false)
                                        + buildMethod(outerIndent, "final|void|set|",
                                                "Replace the stored value by the supplied value.",
                                                new String[]{"final " + scalarType
                                                        + "Scalar<U>|value|the strongly typed value to store"}, null,
                                                null, new String[]{"setValueSI(value.getValueSI());"}, false)
                                        + buildMethod(
                                                outerIndent,
                                                "final|void|setInUnit",
                                                "Replace the stored value by the supplied value which can be expressed in any compatible unit.",
                                                new String[]{"final " + scalarType + "|value|the value to store",
                                                        "final U|valueUnit|the unit of the supplied value"}, null,
                                                null, new String[]{"setValueSI(" + (cast.equals("") ? "" : cast + " ")
                                                        + "ValueUtil.expressAsSIUnit(value, valueUnit));"}, false)
                                        + buildOtherMutatingScalarMethods(outerIndent, scalarType)
                                : buildMethod(
                                        outerIndent,
                                        "public abstract|Mutable" + scalarType + "Scalar<U>|mutable",
                                        "Create a mutable version of this "
                                                + scalarType
                                                + "Scalar. <br>\r\n"
                                                + outerIndent
                                                + " * The mutable version is created as a deep copy of this. Delayed copying is not worthwhile for a Scalar.",
                                        null, null, null, null, false)
                                        + buildMethod(
                                                outerIndent,
                                                "protected final|void|initialize",
                                                "Initialize the valueSI field (performing conversion to the SI standard unit if needed).",
                                                new String[]{"final " + lowerCaseType
                                                        + "|value|the value in the unit of this " + scalarType
                                                        + "Scalar"}, null, null, new String[]{
                                                        "if (this.getUnit().equals(this.getUnit().getStandardUnit()))",
                                                        "{",
                                                        indentStep + "this.valueSI = value;",
                                                        "}",
                                                        "else",
                                                        "{",
                                                        indentStep + "this.valueSI = " + cast
                                                                + "expressAsSIUnit(value);", "}"}, false)
                                        + buildMethod(
                                                outerIndent,
                                                "protected final|void|initialize",
                                                "Initialize the valueSI field. As the provided value is already in the SI standard unit, conversion is never necessary.",
                                                new String[]{"final " + scalarType
                                                        + "Scalar<U>|value|the value to use for initialization"}, null,
                                                null, new String[]{"setValueSI(value.getValueSI());"}, false)
                                        + buildMethod(outerIndent, "public final|" + lowerCaseType + "|getValueSI",
                                                "Retrieve the value in the underlying SI unit.", null, null, null,
                                                new String[]{"return this.valueSI;"}, false)
                                        + buildMethod(outerIndent, "protected final|void|setValueSI",
                                                "Set the value in the underlying SI unit.", new String[]{"final "
                                                        + scalarType.toLowerCase()
                                                        + "|value|the new value in the underlying SI unit"}, null,
                                                null, new String[]{"this.valueSI = value;"}, false)
                                        + buildMethod(outerIndent, "public final|" + scalarType.toLowerCase()
                                                + "|getValueInUnit", "Retrieve the value in the original unit.", null,
                                                null, null, new String[]{"return " + cast
                                                        + "expressAsSpecifiedUnit(this.valueSI);"}, false)
                                        + buildMethod(outerIndent, "public final|" + scalarType.toLowerCase()
                                                + "|getValueInUnit",
                                                "Retrieve the value converted into some specified unit.",
                                                new String[]{"final U|targetUnit|the unit to convert the value into"},
                                                null, null, new String[]{"return " + cast
                                                        + "ValueUtil.expressAsUnit(this.valueSI, targetUnit);"}, false)
                                        + buildNumberMethods(scalarType))

        );

    }

    /**
     * Generate most of the java code that modifies MutableScalar values.
     * @param indent String; prepended to output lines on the outermost level of the generated code
     * @param scalarType String; either <cite>Float</cite> or <cite>Double</cite>
     * @return String
     */
    private static String buildOtherMutatingScalarMethods(String indent, String scalarType)
    {
        final String cast = (scalarType.startsWith("F") ? "(float)" : null);
        StringBuilder construction = new StringBuilder();
        construction.append(buildBlockComment(indent, "NON-STATIC METHODS"));
        construction.append(buildMethod(indent, "public final|void|add", "Add another value to this value. "
                + "Only Relative values are allowed; adding an absolute value to an absolute value\r\n" + indent
                + " * is not allowed. Adding an absolute value to an existing relative value would require the "
                + "result to become\r\n" + indent
                + " * absolute, which is a type change that is impossible. For that operation, use a static method.",
                new String[]{"final " + scalarType.toLowerCase() + "Scalar.Rel<U>|value|the value to add"}, null, null,
                new String[]{"setValueSI(getValueSI() + value.getValueSI());"}, false));
        construction
                .append(buildMethod(
                        indent,
                        "public final|void|subtract",
                        "Subtract another value from this value. "
                                + "Only relative values are allowed; subtracting an absolute value from a\r\n"
                                + indent
                                + " * relative value is not allowed. Subtracting an absolute value from an existing absolute value "
                                + "would require the\r\n" + indent
                                + " * result to become relative, which is a type change that is impossible. "
                                + "For that operation, use a static method.",
                        new String[]{"final " + scalarType.toLowerCase() + "Scalar.Rel<U>|value|the value to subtract"},
                        null, null, new String[]{"setValueSI(getValueSI() - value.getValueSI());"}, false));
        construction.append(buildBlockComment(indent, "STATIC METHODS"));
        construction.append(buildScalarIncrementDecrement(indent, scalarType, true));
        construction.append(buildScalarPlus(indent, scalarType, true));
        construction.append(buildScalarPlus(indent, scalarType, false));
        construction.append(buildScalarIncrementDecrement(indent, scalarType, false));
        construction.append(buildScalarMinus(indent, scalarType, true));
        construction.append(buildScalarMinus(indent, scalarType, false));
        // abs minus abs -> rel
        construction.append(buildMethod(indent, "public static <U extends Unit<U>>|Mutable" + scalarType
                + "Scalar.Rel<U>|minus|the difference of the two absolute values as a relative value",
                "Subtract two absolute values. Return a new instance of a relative value of the difference. The unit of the value\r\n"
                        + indent + " * will be the unit of the first argument.", new String[]{
                        "final " + scalarType + "Scalar.Abs<U>|valueAbs1|value 1",
                        "final " + scalarType + "Scalar.Abs<U>|valueAbs2|value 2",
                        "Unit|<U>|the unit of the parameters and the result"}, null, null, new String[]{
                        "Mutable" + scalarType + "Scalar.Rel<U> result = ",
                        indent + indent + "new Mutable" + scalarType
                                + "Scalar.Rel<U>(valueAbs1.getValueInUnit(), valueAbs1.getUnit());",
                        "result.decrementBy(valueAbs2);", "return result;"}, false));
        construction.append(buildScalarMultiplyOrDivide(indent, scalarType, true, true));
        construction.append(buildScalarMultiplyOrDivide(indent, scalarType, false, true));
        construction.append(buildScalarMultiplyOrDivide(indent, scalarType, true, false));
        construction.append(buildScalarMultiplyOrDivide(indent, scalarType, false, false));
        construction.append(buildBlockComment(indent, "MATH METHODS"));
        construction.append(buildScalarMathMethod(indent, "abs", "Math.abs(", ")", null, null));
        construction.append(buildScalarMathMethod(indent, "acos", "Math.acos(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "asin", "Math.asin(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "atan", "Math.atan(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "cbrt", "Math.cbrt(", ")",
                "// TODO: dimension for all SI coefficients / 3.", cast));
        construction.append(buildScalarMathMethod(indent, "ceil", "Math.ceil(", ")", null, cast));
        construction.append(buildScalarMathMethod(indent, "cos", "Math.cos(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "cosh", "Math.cosh(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "exp", "Math.exp(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "expm1", "Math.expm1(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "floor", "Math.floor(", ")", null, cast));
        construction.append(buildScalarMathMethod(indent, "log", "Math.log(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "log10", "Math.log10(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "log1p", "Math.log1p(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildMethod(indent, "public final|void|pow", null, new String[]{"final double|x|"}, null,
                null, new String[]{"// TODO: SI unit with coefficients * x.",
                        "setValueSI(" + (cast == null ? "" : cast + " ") + "Math.pow(getValueSI(), x));"}, false));
        construction.append(buildScalarMathMethod(indent, "rint", "Math.rint(", ")", null, cast));
        construction.append(buildScalarMathMethod(indent, "round", "Math.round(", ")", null, null));
        construction.append(buildScalarMathMethod(indent, "signum", "Math.signum(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", null));
        construction.append(buildScalarMathMethod(indent, "sin", "Math.sin(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "sinh", "Math.sinh(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "sqrt", "Math.sqrt(", ")", "// TODO: unit coefficients / 2.",
                cast));
        construction.append(buildScalarMathMethod(indent, "tan", "Math.tan(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "tanh", "Math.tanh(", ")",
                "// TODO: dimensionless result (SIUnit.ONE).", cast));
        construction.append(buildScalarMathMethod(indent, "toDegrees", "Math.toDegrees(", ")", null, cast));
        construction.append(buildScalarMathMethod(indent, "toRadians", "Math.toRadians(", ")", null, cast));
        construction.append(buildScalarMathMethod(indent, "inv", "1.0" + (scalarType.startsWith("F") ? "f" : "")
                + " / ", "", "// TODO: negate all coefficients in the Unit.", null));
        final String type = (cast == null ? "double" : cast.substring(1, cast.length() - 1));
        construction.append(buildMethod(indent, "public final|void|multiply", null, new String[]{"final " + type
                + "|constant|"}, null, null, new String[]{"setValueSI(getValueSI() * constant);"}, false));
        construction.append(buildMethod(indent, "public final|void|divide", null, new String[]{"final " + type
                + "|constant|"}, null, null, new String[]{"setValueSI(getValueSI() / constant);"}, false));
        return construction.toString();
    }

    /**
     * Build one math method.
     * @param indent String; prefix for all output lines
     * @param name String; name of the method
     * @param javaCodeBefore String; code that goes to the left of the value to process
     * @param javaCodeAfter String; code that goes to the right of the value to process
     * @param comment String; comment text that goes above the code line
     * @param cast String; if non null, this cast must be applied to the result of the code
     * @return String; java code
     */
    private static String buildScalarMathMethod(final String indent, final String name, final String javaCodeBefore,
            final String javaCodeAfter, final String comment, final String cast)
    {
        String code =
                "setValueSI(" + (null == cast ? "" : cast + " ") + javaCodeBefore + "getValueSI()" + javaCodeAfter
                        + ");";

        if (null != comment)
        {
            return buildMethod(indent, "public final|void|" + name, null, null, null, null,
                    new String[]{comment, code}, false);
        }
        return buildMethod(indent, "public final|void|" + name, null, null, null, null, new String[]{code}, false);
    }

    /**
     * Generate a block comment.
     * @param indent String; prefix of all output lines
     * @param comment String; the text to center in the block comment
     * @return String; java code
     */
    private static String buildBlockComment(final String indent, String comment)
    {
        comment = " " + comment + " ";
        StringBuffer construction = new StringBuffer();
        final String pattern = "/**********************************************************************************/";
        construction.append(indent + pattern + "\r\n");
        int halfTruncate = comment.length() / 2;
        construction.append(indent + pattern.substring(0, pattern.length() / 2 - halfTruncate));
        construction.append(comment);
        construction.append(pattern.substring(pattern.length() / 2 + comment.length() - halfTruncate));
        construction.append("\r\n");
        construction.append(indent + pattern + "\r\n\r\n");
        return construction.toString();
    }

    /**
     * Generate the code for scalar multiply or divide.
     * @param indent String; prefix for all output lines
     * @param scalarType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @param absolute boolean; if true; the code for handling two absolutes is generated; if false; the code for
     *            handling two relatives is generated
     * @param multiply boolean; if true; the code for multiply is generated; if false; the code for divide is generated
     * @return String; java code
     */
    private static String buildScalarMultiplyOrDivide(final String indent, final String scalarType, boolean absolute,
            boolean multiply)
    {
        final String absRel = absolute ? "Abs" : "Rel";
        return buildMethod(indent, "public static|Mutable" + scalarType + "Scalar." + absRel + "<SIUnit>|"
                + (multiply ? "multiply" : "divide") + "|the " + (multiply ? "product" : "ratio")
                + " of the two values", (multiply ? "Multiply" : "Divide")
                + " two values; the result is a new instance with a different (existing or generated) SI Unit.",
                new String[]{"final " + scalarType + "Scalar." + absRel + "<?>|left|the left operand",
                        "final " + scalarType + "Scalar." + absRel + "<?>|right|the right operand"}, null, null,
                new String[]{
                        "SIUnit targetUnit =",
                        indent + indent + "Unit.lookupOrCreateSIUnitWithSICoefficients(SICoefficients."
                                + (multiply ? "multiply" : "divide") + "(left.getUnit().getSICoefficients(),",
                        indent + indent + indent + indent + "right.getUnit().getSICoefficients()).toString());",
                        "return new Mutable" + scalarType + "Scalar." + absRel + "<SIUnit>(left.getValueSI() "
                                + (multiply ? "*" : "/") + " right.getValueSI(), targetUnit);"}, false);
    }

    /**
     * Generate the code for scalar incrementBy and decrementBy.
     * @param indent String; prefix for all output lines
     * @param scalarType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @param increment boolean; if true; the code for incrementBy is generated; if false; the code for decrementBy is
     *            generated
     * @return String; java code
     */
    private static String buildScalarIncrementDecrement(String indent, String scalarType, boolean increment)
    {
        return buildMethod(indent, "protected final|" + scalarType + "Scalar<?>|" + (increment ? "in" : "de")
                + "crementBy|the modified Mutable" + scalarType + "Scalar", (increment ? "In" : "De")
                + "crement the stored value by a specified amount.", new String[]{"final " + scalarType.toLowerCase()
                + "Scalar<?>|" + (increment ? "in" : "de") + "crement|the amount by which to "
                + (increment ? "in" : "de") + "crement the stored value"}, null, null, new String[]{
                "setValueSI(getValueSI() " + (increment ? "+ in" : "- de") + "crement.getValueSI());", "return this;"},
                false);
    }

    /**
     * Build the plus method for adding an array of relative scalars to an absolute or relative scalar.
     * @param indent String; prepended to each line
     * @param scalarType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @param absoluteResult boolean; if true the first operand and the result are absolute; if false, the first operand
     *            and the result are relative
     * @return String; java code
     */
    private static String buildScalarPlus(final String indent, final String scalarType, boolean absoluteResult)
    {
        final String absRel = absoluteResult ? "Abs" : "Rel";
        return buildMethod(
                indent,
                "public static <U extends Unit<U>>|Mutable" + scalarType + "Scalar." + absRel
                        + "<U>|plus|the sum of the values as " + (absoluteResult ? "an absolute" : "a relative")
                        + " value",
                absoluteResult
                        ? "Add a number of relative values to an absolute value. Return a new instance of the value. "
                                + "The unit of the return\r\n" + indent
                                + " * value will be the unit of the first argument. "
                                + "Due to type erasure of generics, the method cannot check whether an\r\n" + indent
                                + " * array of arguments submitted to the varargs has a mixed-unit content at runtime."
                        : "Add a number of relative values. Return a new instance of the value. Due to type erasure of generics, "
                                + "the method\r\n"
                                + indent
                                + " * cannot check whether an array of arguments submitted to the varargs has a "
                                + "mixed-unit content at runtime.",
                new String[]{
                        absoluteResult ? "final " + scalarType + "Scalar." + absRel + "<U>|value" + absRel
                                + "|the absolute base value" : "final U|targetUnit| the unit of the sum",
                        "final " + scalarType + "Scalar.Rel<U>...|valuesRel|zero or more relative values to add "
                                + (absoluteResult ? "to the absolute value" : "together"),
                        "Unit|<U>|the unit of the parameters and the result"},
                null,
                "@SafeVarargs",
                new String[]{
                        "Mutable"
                                + scalarType
                                + "Scalar."
                                + absRel
                                + "<U> result = new Mutable"
                                + scalarType
                                + "Scalar."
                                + absRel
                                + "<U>("
                                + (absoluteResult ? "valueAbs);" : "0.0" + (scalarType.startsWith("F") ? "f" : "")
                                        + ", targetUnit);"), "for (" + scalarType + "Scalar.Rel<U> v : valuesRel)",
                        "{", indentStep + "result.incrementBy(v);", "}", "return result;"}, false);
    }

    /**
     * Build the minus method for adding an array of relative scalars to an absolute or relative scalar.
     * @param indent String; prepended to each line
     * @param scalarType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @param absoluteResult boolean; if true the first operand and the result are absolute; if false, the first operand
     *            and the result are relative
     * @return String; java code
     */
    private static String buildScalarMinus(final String indent, final String scalarType, boolean absoluteResult)
    {
        final String absRel = absoluteResult ? "Abs" : "Rel";
        return buildMethod(
                indent,
                "public static <U extends Unit<U>>|Mutable" + scalarType + "Scalar." + absRel
                        + "<U>|minus|the resulting value as " + (absoluteResult ? "an absolute" : "a relative")
                        + " value",
                absoluteResult
                        ? "Subtract a number of relative values from an absolute value. Return a new instance of the value. "
                                + "The unit of the\r\n"
                                + indent
                                + " * return value will be the unit of the first argument. "
                                + "Due to type erasure of generics, the method cannot check\r\n"
                                + indent
                                + " * whether an array of arguments submitted to the varargs has a mixed-unit content at runtime."
                        : "Subtract a number of relative values from a relative value. Return a new instance of the value. "
                                + "The unit of the\r\n"
                                + indent
                                + " * value will be the unit of the first argument. Due to type erasure of generics, the method "
                                + "cannot check whether an\r\n"
                                + indent
                                + " * array of arguments submitted to the varargs has a "
                                + "mixed-unit content at runtime.", new String[]{
                        "final " + scalarType + "Scalar." + absRel + "<U>|value" + absRel + "|the "
                                + (absoluteResult ? "absolute" : "relative") + " base value",
                        "final " + scalarType + "Scalar.Rel<U>...|valuesRel|zero or more relative values to subtract "
                                + (absoluteResult ? "from the absolute value" : "from the first value"),
                        "Unit|<U>|the unit of the parameters and the result"}, null, "@SafeVarargs", new String[]{
                        "Mutable" + scalarType + "Scalar." + absRel + "<U> result = new Mutable" + scalarType
                                + "Scalar." + absRel + "<U>(value" + absRel + ");",
                        "for (" + scalarType + "Scalar.Rel<U> v : valuesRel)", "{",
                        indentStep + "result.decrementBy(v);", "}", "return result;"}, false);
    }

    /**
     * Generate the Java code that implements the Number methods.
     * @return
     */
    private static String buildNumberMethods(String type)
    {
        final String cast = type.equals("Float") ? "" : "(float) ";
        final String lowerCaseType = type.toLowerCase();
        final String indent = indentStep;
        StringBuilder construction = new StringBuilder();
        construction.append(buildBlockComment(indent, "NUMBER METHODS"));
        construction.append(buildMethod(indent, "public final|int|intValue", null, null, null, null,
                new String[]{"return " + (type.equals("Float") ? "" : "(int) ") + "Math.round(this.valueSI);"}, false));
        construction.append(buildMethod(indent, "public final|long|longValue", null, null, null, null,
                new String[]{"return Math.round(this.valueSI);"}, false));
        construction.append(buildMethod(indent, "public final|float|floatValue", null, null, null, null,
                new String[]{"return " + cast + "this.valueSI;"}, false));
        construction.append(buildMethod(indent, "public final|double|doubleValue", null, null, null, null,
                new String[]{"return this.valueSI;"}, false));
        construction.append(buildMethod(indent, "public final|String|toString", null, null, null, null,
                new String[]{"return this.getValueInUnit() + \" \" + this.getUnit().getAbbreviationKey();"}, false));
        construction.append(buildMethod(indent, "public final|int|hashCode", null, null, null, null, type
                .equals("Float") ? new String[]{"final int prime = 31;", "int result = 1;",
                "result = prime * result + Float.floatToIntBits(this.valueSI);", "return result;"} : new String[]{
                "final int prime = 31;", "int result = 1;", "long temp;",
                "temp = Double.doubleToLongBits(this.valueSI);",
                "result = prime * result + (int) (temp ^ (temp >>> 32));", "return result;"}, false));
        construction.append(buildMethod(indent, "public final|boolean|equals", null,
                new String[]{"final Object|obj|the Object to compare with"}, null, null, new String[]{
                        "if (this == obj)",
                        "{",
                        indentStep + "return true;",
                        "}",
                        "if (obj == null)",
                        "{",
                        indentStep + "return false;",
                        "}",
                        "if (!(obj instanceof " + type + "Scalar))",
                        "{",
                        indentStep + "return false;",
                        "}",
                        type + "Scalar<?> other = (" + type + "Scalar<?>) obj;",
                        "// unequal if not both Absolute or both Relative",
                        "if (this.isAbsolute() != other.isAbsolute() || this.isRelative() != other.isRelative())",
                        "{",
                        indentStep + "return false;",
                        "}",
                        "// unequal if the underlying standard SI unit is different",
                        "if (!this.getUnit().getStandardUnit().equals(other.getUnit().getStandardUnit()))",
                        "{",
                        indentStep + "return false;",
                        "}",
                        "if (" + type + "." + lowerCaseType + (type.equals("Float") ? "ToIntBits" : "ToLongBits")
                                + "(this.valueSI) != " + type + "." + lowerCaseType
                                + (type.equals("Float") ? "ToIntBits" : "ToLongBits") + "(other.valueSI))", "{",
                        indentStep + "return false;", "}", "return true;"}, false));

        return construction.toString();
    }

    /**
     * Generate the Java code for a sub class of scalar
     * @param indent String; prefix for each output line
     * @param name String; name of the sub class, e.g. <cite>Abs</cite> or <cite>Rel</cite>
     * @param longName String; full name of the sub class, e.g. <cite>Absolute Immutable FloatScalar</cite> or
     *            <cite>Relative Mutable DoubleScalar</cite>
     * @param extendsString String; something like <cite>DoubleScalar&lt;U&gt;</cite>
     * @param implementsString String; something like <cite>Absolute, Comparable&lt;Abs&lt;U&gt;&gt;</cite>
     * @param parentClassName String; name of the class that is being sub-classed
     * @param mutable boolean; if true; the class file for the mutable version is generated; if false; the class file
     *            for the immutable version is generated
     * @return String; java code implementing the sub class
     */
    private static String buildScalarSubClass(final String indent, final String name, final String longName,
            final String extendsString, final String implementsString, final String parentClassName, boolean mutable)
    {
        final String absRelType = longName.split(" ")[0];
        final String floatType = extendsString.contains("Float") ? "Float" : "Double";
        StringBuilder construction = new StringBuilder();
        construction.append(indent + "/**\r\n" + indent + " * @param <U> Unit\r\n" + indent + " */\r\n");
        construction.append(indent + "public static class " + name + "<U extends Unit<U>> extends "
                + (mutable ? "Mutable" : "") + extendsString + " implements " + implementsString + "\r\n" + indent
                + "{\r\n");
        final String contentIndent = indent + indentStep;
        construction.append(buildSerialVersionUID(contentIndent));
        construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName + ".",
                new String[]{"final " + floatType.toLowerCase() + "|value|the value of the new " + longName,
                        "final U|unit|the unit of the new " + longName}, null, null, new String[]{"super(unit);",
                        "// System.out.println(\"Created " + name + "\");", "initialize(value);"}, true));
        construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName
                + " from an existing " + absRelType + " Immutable " + floatType + "Scalar.", new String[]{"final "
                + parentClassName + "." + name + "<U>|value|the reference"}, null, null, new String[]{
                "super(value.getUnit());", "// System.out.println(\"Created " + name + "\");", "initialize(value);"},
                true));
        construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName
                + " from an existing " + absRelType + " Mutable" + floatType + "Scalar.", new String[]{"final "
                + " Mutable" + floatType + "Scalar." + name + "<U>|value|the reference"}, null, null, new String[]{
                "super(value.getUnit());", "// System.out.println(\"Created " + name + "\");", "initialize(value);"},
                true));
        construction.append(buildMethod(contentIndent, "public final|" + "Mutable" + floatType + "Scalar." + name
                + "<U>|mutable", null, null, null, null, new String[]{"return new Mutable" + floatType + "Scalar."
                + name + "<U>(this);"}, false));
        if (mutable)
        {
            construction.append(buildMethod(contentIndent, "public final|" + parentClassName + "." + name
                    + "<U>|immutable", null, null, null, null, new String[]{"return new " + parentClassName + "."
                    + name + "<U>(this);"}, false));
        }
        construction.append(buildMethod(contentIndent, "public final|int|compareTo", null, new String[]{"final|" + name
                + "<U> o|"}, null, null, new String[]{"return new " + floatType
                + "(getValueSI()).compareTo(o.getValueSI());"}, false));
        construction.append(buildMethod(contentIndent, "public final|" + (mutable ? "Mutable" : "") + parentClassName
                + "." + name + "<U>|copy", null, null, null, null, new String[]{mutable ? "return new Mutable"
                + floatType + "Scalar." + name + "<U>(this);" : "return this;"}, false));
        construction.append(indent + "}\r\n\r\n");
        return construction.toString();
    }

    /**
     * Build the implementation of a DoubleFunction.
     * @param name String; name of the DoubleFunction.
     * @param objectType String; should be <cite>Double</cite>, or <cite>Float</cite>
     * @param cast String; should be <cite>(float)</cite> or the empty String
     * @return String; java code that implements the DoubleFunction
     */
    private static String buildDoubleOrFloatFunction(final String name, String objectType, String cast)
    {
        String useCast = (cast.length() == 0 ? "" : cast + " "); // append a space
        return "    /**\r\n     * Function that returns <tt>Math." + name + "(a)</tt>.\r\n     */\r\n"
                + "    public static final " + objectType + "Function " + name + " = new " + objectType
                + "Function()\r\n    {\r\n" + "        @Override\r\n        public " + objectType.toLowerCase()
                + " apply(final " + objectType.toLowerCase() + " a)\r\n" + "        {\r\n            return " + useCast
                + "Math." + name + "(a);\r\n" + "        }\r\n    };\r\n\r\n";
    }

    /**
     * Generate the three format functions for either float or double typed value.
     * @param valueType String; should be <cite>float</cite> or <cite>double</cite>
     * @return String; java code for the three format functions
     */
    private static String buildFormatMethods(String valueType)
    {
        return buildMethod(indentStep, "public static|String|format", "Format a floating point value.", new String[]{
                "final " + valueType + "|value|the value to format",
                "final int|width|the number of characters in the result",
                "final int|precision|the number of fractional digits in the result"}, null, null,
                new String[]{"return String.format(formatString(width, precision, \"f\"), value);"}, false)

                + buildMethod(indentStep, "public static|String|format", "Format a floating point value.",
                        new String[]{"final " + valueType + "|value|the value to format",
                                "final int|size|the number of characters in the result"}, null, null,
                        new String[]{"return Format.format(value, size, Format.DEFAULTPRECISION);"}, false)
                + buildMethod(indentStep, "public static|String|format", "Format a floating point value.",
                        new String[]{"final " + valueType + "|value|the value to format",}, null, null,
                        new String[]{"return format(value, Format.DEFAULTSIZE, Format.DEFAULTPRECISION);"}, false);
    }

}
