package valueclasses.generator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Generate the code for the value classes.
 * <p>
 * Copyright (c) 2013-2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights
 * reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 24 sep. 2014 <br>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class Generator
{
    /** Name of this program */
    static String generator = "the OpenTrafficSim valueclasses generator";

    /** Description of the day on which the files were generated */
    static String when;

    /** The serialVersionUID to put in the generated classes */
    static String serialVersionUID;

    /** Directory where the tree of files will be built */
    static String buildDir = "d:\\valueTree";

    /** Base directory / package */
    final static String packageBaseName = "org.opentrafficsim.core";

    /**
     * Open a file and write the package line and initial block comment.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; descriptions of the generic parameters of the class
     * @return BufferedWriter; the open file
     */
    public static BufferedWriter openFile(String relativePackage, String name, String[] imports, String description,
            String[] genericParams)
    {
        BufferedWriter writer = null;
        String dirList = relativePackage;
        String[] intermediateDirs = dirList.split("[\\.]");
        String path = buildDir;
        for (String intermediateDir : intermediateDirs)
        {
            path = path + File.separatorChar + intermediateDir;
        }
        File dir = new File(path);
        if (!dir.exists() && !dir.mkdirs())
        {
            throw new Error("Cannot create path \"" + path + "\"");
        }
        String fileName = path + File.separatorChar + name + ".java";
        try
        {
            writer = new BufferedWriter(new FileWriter(new File(fileName)));
            writer.write("package " + packageBaseName + "." + relativePackage + ";\r\n\r\n");
            if (null != imports)
            {
                for (String importString : imports)
                {
                    if (importString.length() > 0)
                    {
                        writer.write("import " + importString + ";");
                    }
                    writer.write("\r\n");
                }
                writer.write("\r\n");
            }
            writer.write("/**\r\n * "
                    + description
                    + "\r\n * <p>\r\n * This file was generated by "
                    + generator
                    + ", "
                    + when
                    + "\r\n * <p>\r\n"
                    + " * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights"
                    + " reserved. <br>\r\n"
                    + " * BSD-style license. See <a href=\"http://opentrafficsim.org/node/13\">OpenTrafficSim License</a>.\r\n"
                    + " * <p>\r\n" + " * @version " + when + " <br>\r\n"
                    + " * @author <a href=\"http://www.tbm.tudelft.nl/averbraeck\">Alexander Verbraeck</a>\r\n"
                    + " * @author <a href=\"http://www.tudelft.nl/pknoppers\">Peter Knoppers</a>\r\n");
            if (null != genericParams)
            {
                for (String param : genericParams)
                {
                    writer.write(" * @param " + param + "\r\n");
                }
            }
            writer.write(" */\r\n");
        }
        catch (Exception e)
        {
            throw new Error("Cannot write file " + fileName);
        }
        return writer;
    }

    /**
     * Close a file that was opened with openFile.
     * @param writer BufferedWriter; the result of the preceding call to openFile
     */
    public static void closeFile(BufferedWriter writer)
    {
        try
        {
            writer.close();
        }
        catch (IOException exception)
        {
            exception.printStackTrace();
        }

    }

    /**
     * Write a class file.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param qualifiers String; qualifiers that go before the class key word; e.g. <cite>public abstract</cite>
     * @param typeInfo String; the text that goes immediately after the class name
     * @param generateSerialVersionUID boolean; if true a serialVersionUID is put in the result
     * @param contents String; the text that goes in the class
     */
    private static void generateClass(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String qualifiers, String typeInfo, boolean generateSerialVersionUID,
            String contents)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, imports, description, genericParams);
            writer.write(qualifiers + " class " + name + prependSpaceIfNonEmpty(typeInfo) + "\r\n{\r\n");
            if (generateSerialVersionUID)
            {
                writer.write(buildField("private static final long serialVersionUID = " + serialVersionUID + "L", ""));
            }
            writer.write(contents + "}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Write a class file for an abstract class.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateAbstractClass(String relativePackage, String name, String[] imports,
            String description, String[] genericParams, String typeInfo, String contents)
    {
        generateClass(relativePackage, name, imports, description, genericParams, "public abstract", typeInfo, true,
                contents);
    }

    /**
     * Write a class file for a final class that cannot be instantiated.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateFinalClass(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String typeInfo, String contents)
    {
        generateClass(
                relativePackage,
                name,
                imports,
                description,
                genericParams,
                "public final",
                typeInfo,
                false,
                buildMethod("private||name", "This class shall never be instantiated.", null,
                        new String[]{"// Prevent instantiation of this class"}, true) + contents);
    }

    /**
     * Insert a space before a String if (and only if) the String has length > 0 and does not start with a &lt;
     * character.
     * @param argument String; the String to (potentially) modify
     * @return String
     */
    private static String prependSpaceIfNonEmpty(String argument)
    {
        if (argument.length() == 0 || argument.startsWith("<"))
        {
            return argument;
        }
        return " " + argument;
    }

    /**
     * Write an interface file that defines an interface that does nothing but define it's own name.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param body String; the body of the interface file
     */
    public static void generateInterface(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String typeInfo, String body)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, imports, description, genericParams);
            writer.write("public interface " + name + prependSpaceIfNonEmpty(typeInfo) + "\r\n{\r\n");
            if (null != body)
            {
                writer.write(body);
            }
            else
            {
                writer.write("    // This interface does not force anything to be implemented in classes that implement it\r\n");
            }
            writer.write("}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Create a String that defines one method.
     * @param qualifiersTypeAndName String; the qualifiers, the type and the name of the method separated by vertical
     *            bars, e.g. <cite>final public|double|getDoubleValue</cite>. If this method overrides a method in a
     *            parent class set this parameter to null.
     * @param description String; description of the method
     * @param params String[]; one String for each parameter of the method. Each parameter string consists of
     *            qualifiers, type, name separated by vertical bars, e.g. <cite>final int|index|index of the
     *            entry</cite>
     * @param body String[]; the lines of the body of the method. Lines on the outermost level should start with 0
     *            spaces
     * @param constructor boolean; if true; the new method is a constructor; if false; the new method is not a
     *            constructor
     * @return String; the Java source code of the method.
     */
    public static String buildMethod(String qualifiersTypeAndName, String description, String[] params, String[] body,
            boolean constructor)
    {
        StringBuilder construction = new StringBuilder();
        String[] fields = qualifiersTypeAndName.split("[|]");
        if (null != description)
        {
            construction.append("    /**\r\n     * ");
            construction.append(description);
            construction.append("\r\n");
            if (null != params)
            {
                for (String param : params)
                {
                    String[] paramFields = param.split("[|]");
                    if (3 != paramFields.length)
                    {
                        throw new Error("param should consist of three fields separated by |; got " + param);
                    }
                    if (paramFields[0].startsWith("final "))
                    {
                        paramFields[0] = paramFields[0].substring(6);
                    }
                    construction.append("     * @param ");
                    construction.append(paramFields[1]);
                    construction.append(" ");
                    construction.append(paramFields[0]);
                    construction.append("; ");
                    construction.append(paramFields[2]);
                    construction.append("\r\n");
                }
            }
            if (3 != fields.length)
            {
                throw new Error("typeAndName should consist of two fields separated by |; got " + qualifiersTypeAndName);
            }
            if (!"void".equals(fields[1]) && !constructor)
            {
                construction.append("     * @return ");
                construction.append(fields[1]);
                construction.append("\r\n");
            }
            construction.append("     */\r\n");
        }
        else
        {
            construction.append("    /** {@inheritDoc} */\r\n    @Override\r\n");
        }
        construction.append("    ");

        construction.append(fields[0]);
        construction.append(" ");
        if (fields[1].length() > 0)
        {
            construction.append(fields[1]);
            construction.append(" ");
        }
        construction.append(fields[2]);
        construction.append("(");
        String sep = "";
        if (null != params)
        {
            for (String param : params)
            {
                construction.append(sep);
                sep = ", ";
                String[] paramFields = param.split("[|]");
                construction.append(paramFields[0]);
                construction.append(" ");
                construction.append(paramFields[1]);
            }
        }
        construction.append(")");
        if (null != body)
        {
            construction.append("\r\n    {\r\n");
            for (String bodyLine : body)
            {
                construction.append("        ");
                construction.append(bodyLine);
                construction.append("\r\n");
            }
            construction.append("    }\r\n");
        }
        else
        {
            construction.append(";\r\n");
        }
        construction.append("\r\n");
        return construction.toString();
    }

    /**
     * Create a String that describes one field.
     * @param field String; the type and name of the field
     * @param description String; the description of the field
     * @return String
     */
    public static String buildField(String field, String description)
    {
        return "    /** " + description + " */\r\n    " + field + ";\r\n\r\n";
    }

    /**
     * Generate the code for the value classes.
     * @param args String[]; the command line arguments (not used)
     */
    public static void main(String args[])
    {
        Date now = new Date();
        when = new SimpleDateFormat("dd MMM, yyyy").format(now);
        serialVersionUID = new SimpleDateFormat("yyyyMMdd").format(now);
        File testPath = new File(buildDir);
        if (!testPath.exists())
        {
            throw new Error("buildDir (" + buildDir + ") does not exist");
        }
        else if (!testPath.isDirectory())
        {
            throw new Error("buildDir (" + buildDir + ") is not a directory");
        }
        generateInterface("value", "Absolute", null,
                "Absolute values are quantities that are measured from some agreed upon reference point.", null, "",
                null);
        generateInterface("value", "Relative", null, "Relative values express differences.", null, "", null);
        generateInterface("value", "DenseData", null, "Values are stored densely.", null, "", null);
        generateInterface("value", "SparseData", null, "Values are stored sparsely (lots of zero values expected).",
                null, "", null);
        generateAbstractClass(
                "value",
                "AbstractValue",
                new String[]{"java.io.Serializable", "", "org.opentrafficsim.core.unit.Unit"},
                "AbstractValue is a class to help construct Matrix, Complex, "
                        + "and Vector but it does not extend java.lang.Number. The Scalar\r\n"
                        + " * class <i>does</i> extend Number, and implements the same interfaces from Value.",
                new String[]{"<U> the Unit of the value(s) in this AbstractValue. Used for setting, getting and displaying the value(s)"},
                "<U extends Unit<U>> implements Value<U>, Serializable",
                buildField("private final U unit", "The unit of the AbstractValue")
                        + buildMethod("public||AbstractValue", "Construct a new AbstractValue.",
                                new String[]{"final U|unit|the unit of the new AbstractValue"},
                                new String[]{"this.unit = unit;"}, true)
                        + buildMethod("public final|U|getUnit", null, null, new String[]{"return this.unit;"}, false)
                        + buildMethod("protected final|double|expressAsSIUnit", null,
                                new String[]{"final double|value|"},
                                new String[]{"return ValueUtil.expressAsSIUnit(value, this.unit);"}, false)
                        + buildMethod("protected final|double|expressAsSpecifiedUnit",
                                "Convert a value in SI standard unit into the unit of this AbstractValue",
                                new String[]{"final double|value|the value in standard SI unit"},
                                new String[]{"return ValueUtil.expressAsUnit(value, this.unit);"}, false)
                        + buildMethod("public final|boolean|isAbsolute", null, null,
                                new String[]{"return this instanceof Absolute"}, false)
                        + buildMethod("public final|boolean|isRelative", null, null,
                                new String[]{"return this instanceof Relative"}, false));
        generateFinalClass(
                "value",
                "Format",
                null,
                "Format a floating point number in a reasonable way. <br>\r\n"
                        + " * I've experienced problems with the %g conversions that caused array bounds violations. Those versions of the JRE that do\r\n"
                        + " * <b>not</b> throw such Exceptions use one digit less than specified in the %g conversions. <br >\r\n"
                        + " * TODO: check how to always format numbers corresponding to the Locale used.",
                null,
                "",
                buildField("public static final int DEFAULTSIZE = 9", "Default total width of formatted value.")
                        + buildField("public static final int DEFAULTPRECISION = 3",
                                "Default numberof fraction digits.")
                        + buildMethod("private static|String|formatString", "Build a format String.", new String[]{
                                "final int|width|the number of characters in the result",
                                "final int|precision|the number of fractional digits in the result",
                                "final String|converter|the format conversion specifier"},
                                new String[]{"return String.format(\"%%%d.%d%s\", width, precision, converter);"},
                                false) + buildFormatMethods("float") + buildFormatMethods("double"));
        generateInterface(
                "value",
                "MathFunctions",
                new String[]{"java.io.Serializable"},
                "Interface to force all functions of Math that must be implemented.",
                null,
                "extends Serializable",
                buildMathFunction("void abs()", "Set the value(s) to their absolute value(s).")
                        + buildMathFunction("void acos()",
                                "Set the value(s) to the arc cosine of the value; the resulting angle is in the range -pi/2 through pi/2.")
                        + buildMathFunction("void asin()",
                                "Set the value(s) to the arc sine of the value; the resulting angle is in the range -pi/2 through pi/2.")
                        + buildMathFunction("void atan()",
                                "Set the value(s) to the arc tangent of the value; the resulting angle is in the range -pi/2 through pi/2.")
                        + buildMathFunction("void cbrt()", "Set the value(s) to their cube root.")
                        + buildMathFunction("void ceil()",
                                "Set the value(s) to the smallest (closest to negative infinity) value(s) that are greater than or equal to the"
                                        + " * argument and equal to a mathematical integer.")
                        + buildMathFunction("void cos()",
                                "Set the value(s) to the trigonimetric cosine of the value(s).")
                        + buildMathFunction("void cosh()", "Set the value(s) to the hyperbolic cosine of the value(s).")
                        + buildMathFunction("void exp()",
                                "Set the value(s) to Euler's number e raised to the power of the value(s).")
                        + buildMathFunction("void exp()",
                                "Set the value(s) to Euler's number e raised to the power of the value(s) minus 1 (e^x - 1).")
                        + buildMathFunction("void floor()",
                                "Set the value(s) to the largest (closest to positive infinity) value(s) that are less than or equal to the"
                                        + " * argument and equal to a mathematical integer.")
                        + buildMathFunction("void log()",
                                "Set the value(s) to the natural logarithm (base e) of the value(s).")
                        + buildMathFunction("void log()", "Set the value(s) to the base 10logarithm of the value(s).")
                        + buildMathFunction("void log1p()",
                                "Set the value(s) to the natural logarithm of sum of the value(s) and 1")
                        + buildMathFunction("void pow(double x)",
                                "Set the value(s) to  the value(s) raised to the power of the argument\r\n"
                                        + "     * @param x double; the argument")
                        + buildMathFunction("void rint()",
                                "Set the value(s) to the value(s) that are closest in value to the argument and equal to a mathematical integer.")
                        + buildMathFunction("void round()",
                                "Set the value(s) to the closest long to the argument with ties rounding up.")
                        + buildMathFunction("void signum()",
                                "Set the value(s) to the signum function of the value(s); zero if the argument is zero, 1.0 if the argument is"
                                        + "     * greater than zero, -1.0 if the argument is less than zero.")
                        + buildMathFunction("void sin()", "Set the value(s) to the trigonimetric sine of the value(s).")
                        + buildMathFunction("void sinh()", "Set the value(s) to the hyperbolic sine of the value(s).")
                        + buildMathFunction("void sqrt()",
                                "Set the value(s) to the correctly rounded positive square root of the value(s)")
                        + buildMathFunction("void tan()",
                                "Set the value(s) to the trigonimetric tangent of the value(s).")
                        + buildMathFunction("void tanh()",
                                "Set the value(s) to the hyperbolic tangent of the value(s).")
                        + buildMathFunction("void toDegrees()",
                                "Set the value(s) to approximately equivalent angle(s) measured in degrees.")
                        + buildMathFunction("void toRadians()",
                                "Set the value(s) to approximately equivalent angle(s) measured in radians.")
                        + buildMathFunction("void inv()", "Set the value(s) to the complement (1.0/x) of the value(s)."));
        generateInterface(
                "value",
                "Value",
                new String[]{"org.opentrafficsim.core.unit.Unit"},
                "Value is a static interface that forces implementation of a few unit- and value-related methods.",
                new String[]{"<U> the unit type"},
                "<U extends Unit<U>>",
                buildMethod("public final|U|getUnit", "Return the unit of the Value.", null, null, false)
                        + buildMethod("|double|expressAsSIUnit", "Convert a value to the standard SI unit",
                                new String[]{"final double|value|the value to convert to the standard SI unit"}, null,
                                false)
                        + buildMethod("|boolean|isAbsolute", "Indicate whether this is an Absolute Value", null, null,
                                false)
                        + buildMethod("|boolean|isRelative", "Indicate whether this is a Relative Value", null, null,
                                false)
                        + buildMethod("|Value<U>|copy", "Create a deep copy of this Value", null, null, false));

        generateClass(
                "value",
                "ValueException",
                null,
                "Exception that is thrown for bad indices or non-rectangular, or effectively empty arrays",
                null,
                "public",
                "extends Exception",
                true,
                buildMethod("public||ValueException", "Construct a new ValueException.", null,
                        new String[]{"super();"}, true)
                        + buildMethod("public||ValueException", "Construct a new ValueException.",
                                new String[]{"final String|message|description of the problem"},
                                new String[]{"super(message);"}, true)
                        + buildMethod("public||ValueException", "Construct a new ValueException.", new String[]{
                                "final String|message|description of the problem",
                                "final Throwable|cause|the cause of this ValueException"},
                                new String[]{"super(message, cause);"}, true)
                        + buildMethod("public||ValueException", "Construct a new ValueException.", new String[]{
                                "final String|message|description of the problem",
                                "final Throwable|cause|the cause of this ValueException",
                                "final boolean|enableSuppression|whether or not suppression is enabled or disabled",
                                "final boolean|writableStackTrace|whether or not the stack trace should be writable"},
                                new String[]{"super(message, cause, enableSuppression, writableStackTrace);"}, true));
        generateFinalClass(
                "value",
                "ValueUtil",
                null,
                "ValueUtil implements a couple of unit-related static methods.",
                null,
                "",
                buildMethod("public static|double|expressAsSIUnit",
                        "Convert a value in a given unit into the equivalent in the standard SI unit", new String[]{
                                "final double|value|the value to convert into standard SI unit",
                                "final Unit<?>|unit|the unit of the given value"}, new String[]{
                                "if (unit instanceof OffsetUnit<?>)", "{",
                                "    return (value - ((OffsetUnit<?>) unit).getOffsetToStandardUnit())",
                                "            * unit.getConversionFactorToStandardUnit();", "}",
                                "return value * unit.getConversionFactorToStandardUnit();"}, false)

                        + buildMethod("public static|double|expressAsUnit",
                                "Convert a value in the standard SI unit into another unit", new String[]{
                                        "final double|siValue|the given value in SI standard unit",
                                        "final Unit<?>|targetUnit|the unit to convert the value into"}, new String[]{
                                        "if (targetUnit instanceof OffsetUnit<?>)", "{",
                                        "    return siValue / targetUnit.getConversionFactorToStandardUnit()",
                                        "            + ((OffsetUnit<?>) targetUnit).getOffsetToStandardUnit();", "}",
                                        "return siValue / targetUnit.getConversionFactorToStandardUnit();"}, false));

        generateInterface(
                "value.vdouble",
                "DoubleMathFunctions",
                new String[]{"org.opentrafficsim.core.value.MathFunctions"},
                "Force implementation of multiply and divide.",
                null,
                "",
                buildMethod("|void|multiply", "Scale the value(s) by a factor",
                        new String[]{"double|factor|the multiplier"}, null, false)
                        + buildMethod("|void|divide", "Scale the value(s) by the inverse of a factor; i.e. a divisor",
                                new String[]{"double|divisor|the divisor"}, null, false)

        );

        generateFinalClass(
                "value.vdouble",
                "DoubleMathFunctionsImpl",
                new String[]{"import cern.colt.function.tdouble.DoubleFunction"},
                "DoubleFunction implementations of all standard Math functions.",
                null,
                "",
                buildDoubleOrFloatFunction("cbrt", "Double", "") + buildDoubleOrFloatFunction("cosh", "Double", "")
                        + buildDoubleOrFloatFunction("expm1", "Double", "")
                        + buildDoubleOrFloatFunction("log10", "Double", "")
                        + buildDoubleOrFloatFunction("log1p", "Double", "")
                        + buildDoubleOrFloatFunction("round", "Double", "")
                        + buildDoubleOrFloatFunction("signum", "Double", "")
                        + buildDoubleOrFloatFunction("sinh", "Double", "")
                        + buildDoubleOrFloatFunction("tanh", "Double", "")
                        + buildDoubleOrFloatFunction("toDegrees", "Double", "")
                        + buildDoubleOrFloatFunction("toRadians", "Double", ""));

        generateInterface(
                "value.vfloat",
                "FloatMathFunctions",
                new String[]{"org.opentrafficsim.core.value.MathFunctions"},
                "Force implementation of multiply and divide.",
                null,
                "",
                buildMethod("|void|multiply", "Scale the value(s) by a factor",
                        new String[]{"float|factor|the multiplier"}, null, false)
                        + buildMethod("|void|divide", "Scale the value(s) by the inverse of a factor; i.e. a divisor",
                                new String[]{"float|divisor|the divisor"}, null, false)

        );

        generateFinalClass(
                "value.vfloat",
                "FloatMathFunctionsImpl",
                new String[]{"import cern.colt.function.tdouble.FloatFunction"},
                "FloatFunction implementations of all standard Math functions.",
                null,
                "",
                buildDoubleOrFloatFunction("cbrt", "Float", "(float)")
                        + buildDoubleOrFloatFunction("cosh", "Double", "")
                        + buildDoubleOrFloatFunction("expm1", "Float", "(float)")
                        + buildDoubleOrFloatFunction("log10", "Float", "(float)")
                        + buildDoubleOrFloatFunction("log1p", "Float", "")
                        + buildDoubleOrFloatFunction("round", "Float", "")
                        + buildDoubleOrFloatFunction("signum", "Float", "")
                        + buildDoubleOrFloatFunction("sinh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("tanh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("toDegrees", "Float", "")
                        + buildDoubleOrFloatFunction("toRadians", "Float", "(float)"));

    }

    /**
     * Build the implementation of a DoubleFunction.
     * @param name String; name of the DoubleFunction.
     * @param objectType String; should be <cite>Double</cite>, or <cite>Float</cite>
     * @param casts String; should be <cite>(float)</cite> or the empty String
     * @return String; java code that implements the DoubleFunction
     */
    private static String buildDoubleOrFloatFunction(final String name, String objectType, String casts)
    {
        return "    /*\r\n     * Function that returns <tt>Math." + name + "(a)</tt>.\r\n     */\r\n"
                + "    public static final " + objectType + "Function " + name + " = new " + objectType
                + "Function()\r\n    {\r\n" + "        @Override\r\n        public " + objectType.toLowerCase()
                + " apply(final " + objectType.toLowerCase() + " a)\r\n" + "        {\r\n            return " + casts
                + "Math." + name + "(a)\r\n" + "        }\r\n    };\r\n\r\n";
    }

    /**
     * Build the interface for one math function
     * @param function String; code for the math function
     * @param description String; description of the math function
     * @return String; java code for the interface of the math function
     */
    private static String buildMathFunction(final String function, final String description)
    {
        return "    /**\r\n     * " + description + "\r\n     */\r\n    " + function + "\r\n\r\n";
    }

    /**
     * Generate the three format functions for either float or double typed value.
     * @param valueType String; should be <cite>float</cite> or <cite>double</cite>
     * @return String; java code for the three format functions
     */
    private static String buildFormatMethods(String valueType)
    {
        return buildMethod("public static|String|format", "Format a floating point value.", new String[]{
                "final " + valueType + "|value|the value to format",
                "final int|width|the number of characters in the result",
                "final int|precision|the number of fractional digits in the result"},
                new String[]{"return String.format(formatString(width, precision, \"f\"), value);"}, false)

                + buildMethod("public static|String|format", "Format a floating point value.", new String[]{
                        "final " + valueType + "|value|the value to format",
                        "final int|size|the number of characters in the result"},
                        new String[]{"return Format.format(value, size, Format.DEFAULTPRECISION);"}, false)
                + buildMethod("public static|String|format", "Format a floating point value.", new String[]{"final "
                        + valueType + "|value|the value to format",},
                        new String[]{"return format(value, Format.DEFAULTSIZE, Format.DEFAULTPRECISION);"}, false);
    }

}
