package valueclasses.generator;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Generate the code for the value classes.
 * <p>
 * Copyright (c) 2013-2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights
 * reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/node/13">OpenTrafficSim License</a>.
 * <p>
 * @version 24 sep. 2014 <br>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class Generator
{
    /** Name of this program */
    static String generator = "the OpenTrafficSim valueclasses generator";

    /** Description of the day on which the files were generated */
    static String when;

    /** The serialVersionUID to put in the generated classes */
    static String serialVersionUID;

    /** Directory where the tree of files will be built */
    static String buildDir = "d:\\valueTree";

    /** Base directory / package */
    final static String packageBaseName = "org.opentrafficsim.core";

    /** Indent step */
    final static String indentStep = "    ";

    /**
     * Open a file and write the package line and initial block comment.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; descriptions of the generic parameters of the class
     * @return BufferedWriter; the open file
     */
    public static BufferedWriter openFile(String relativePackage, String name, String[] imports, String description,
            String[] genericParams)
    {
        BufferedWriter writer = null;
        String dirList = relativePackage;
        String[] intermediateDirs = dirList.split("[\\.]");
        String path = buildDir;
        for (String intermediateDir : intermediateDirs)
        {
            path = path + File.separatorChar + intermediateDir;
        }
        File dir = new File(path);
        if (!dir.exists() && !dir.mkdirs())
        {
            throw new Error("Cannot create path \"" + path + "\"");
        }
        String fileName = path + File.separatorChar + name + ".java";
        try
        {
            writer = new BufferedWriter(new FileWriter(new File(fileName)));
            writer.write("package " + packageBaseName + "." + relativePackage + ";\r\n\r\n");
            if (null != imports)
            {
                for (String importString : imports)
                {
                    if (importString.length() > 0)
                    {
                        writer.write("import " + importString + ";");
                    }
                    writer.write("\r\n");
                }
                writer.write("\r\n");
            }
            writer.write("/**\r\n * "
                    + description
                    + "\r\n * <p>\r\n * This file was generated by "
                    + generator
                    + ", "
                    + when
                    + "\r\n * <p>\r\n"
                    + " * Copyright (c) 2014 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights"
                    + " reserved. <br>\r\n"
                    + " * BSD-style license. See <a href=\"http://opentrafficsim.org/node/13\">OpenTrafficSim License</a>.\r\n"
                    + " * <p>\r\n" + " * @version " + when + " <br>\r\n"
                    + " * @author <a href=\"http://www.tbm.tudelft.nl/averbraeck\">Alexander Verbraeck</a>\r\n"
                    + " * @author <a href=\"http://www.tudelft.nl/pknoppers\">Peter Knoppers</a>\r\n");
            if (null != genericParams)
            {
                for (String param : genericParams)
                {
                    writer.write(" * @param " + param + "\r\n");
                }
            }
            writer.write(" */\r\n");
        }
        catch (Exception e)
        {
            throw new Error("Cannot write file " + fileName);
        }
        return writer;
    }

    /**
     * Close a file that was opened with openFile.
     * @param writer BufferedWriter; the result of the preceding call to openFile
     */
    public static void closeFile(BufferedWriter writer)
    {
        try
        {
            writer.close();
        }
        catch (IOException exception)
        {
            exception.printStackTrace();
        }

    }

    /**
     * Return the String that defines the serialVersionUID.
     * @param indent String; prepended to each output line
     * @return String
     */
    private static String buildSerialVersionUID(final String indent)
    {
        return buildField(indent, "private static final long serialVersionUID = " + serialVersionUID + "L", "");
    }

    /**
     * Write a class file.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param qualifiers String; qualifiers that go before the class key word; e.g. <cite>public abstract</cite>
     * @param typeInfo String; the text that goes immediately after the class name
     * @param generateSerialVersionUID boolean; if true a serialVersionUID is put in the result
     * @param contents String; the text that goes in the class
     */
    private static void generateClass(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String qualifiers, String typeInfo, boolean generateSerialVersionUID,
            String contents)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, imports, description, genericParams);
            writer.write(qualifiers + " class " + name + prependSpaceIfNonEmpty(typeInfo) + "\r\n{\r\n");
            if (generateSerialVersionUID)
            {
                writer.write(buildSerialVersionUID(indentStep));
            }
            writer.write(contents + "}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Write a class file for an abstract class.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateAbstractClass(String relativePackage, String name, String[] imports,
            String description, String[] genericParams, String typeInfo, String contents)
    {
        generateClass(relativePackage, name, imports, description, genericParams, "public abstract", typeInfo, true,
                contents);
    }

    /**
     * Write a class file for a final class that cannot be instantiated.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param contents String; the text that goes in the class
     */
    private static void generateFinalClass(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String typeInfo, String contents)
    {
        generateClass(
                relativePackage,
                name,
                imports,
                description,
                genericParams,
                "public final",
                typeInfo,
                false,
                buildMethod(indentStep, "private||name", "This class shall never be instantiated.", null,
                        new String[]{"// Prevent instantiation of this class"}, true) + contents);
    }

    /**
     * Insert a space before a String if (and only if) the String has length > 0 and does not start with a &lt;
     * character.
     * @param argument String; the String to (potentially) modify
     * @return String
     */
    private static String prependSpaceIfNonEmpty(String argument)
    {
        if (argument.length() == 0 || argument.startsWith("<"))
        {
            return argument;
        }
        return " " + argument;
    }

    /**
     * Write an interface file that defines an interface that does nothing but define it's own name.
     * @param relativePackage String; the last element(s) of the package name
     * @param name String; the name of the class file to write
     * @param imports String[]; the imports for the new class file
     * @param description String; the description that is inserted in the block comment at the start of the file
     * @param genericParams String[]; the descriptions of the generic parameters of the class
     * @param typeInfo String; the text that goes immediately after the class name
     * @param body String; the body of the interface file
     */
    public static void generateInterface(String relativePackage, String name, String[] imports, String description,
            String[] genericParams, String typeInfo, String body)
    {
        try
        {
            BufferedWriter writer = openFile(relativePackage, name, imports, description, genericParams);
            writer.write("public interface " + name + prependSpaceIfNonEmpty(typeInfo) + "\r\n{\r\n");
            if (null != body)
            {
                writer.write(body);
            }
            else
            {
                writer.write("    // This interface does not force anything to be implemented in classes that implement it\r\n");
            }
            writer.write("}\r\n");
            closeFile(writer);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Create a String that defines one method.
     * @param indent TODO
     * @param qualifiersTypeAndName String; the qualifiers, the type and the name of the method separated by vertical
     *            bars, e.g. <cite>final public|double|getDoubleValue</cite>. If this method overrides a method in a
     *            parent class set this parameter to null.
     * @param description String; description of the method
     * @param params String[]; one String for each parameter of the method. Each parameter string consists of
     *            qualifiers, type, name separated by vertical bars, e.g. <cite>final int|index|index of the
     *            entry</cite>
     * @param body String[]; the lines of the body of the method. Lines on the outermost level should start with 0
     *            spaces
     * @param constructor boolean; if true; the new method is a constructor; if false; the new method is not a
     *            constructor
     * @return String; the Java source code of the method.
     */
    public static String buildMethod(String indent, String qualifiersTypeAndName, String description, String[] params,
            String[] body, boolean constructor)
    {
        StringBuilder construction = new StringBuilder();
        String[] fields = qualifiersTypeAndName.split("[|]");
        if (null != description)
        {
            construction.append(indent + "/**\r\n" + indent + " * ");
            construction.append(description);
            construction.append("\r\n");
            if (null != params)
            {
                for (String param : params)
                {
                    String[] paramFields = param.split("[|]");
                    if (3 != paramFields.length)
                    {
                        throw new Error("param should consist of three fields separated by |; got \"" + param + "\"");
                    }
                    if (paramFields[0].startsWith("final "))
                    {
                        paramFields[0] = paramFields[0].substring(6);
                    }
                    construction.append(indent + " * @param ");
                    construction.append(paramFields[1]);
                    construction.append(" ");
                    construction.append(paramFields[0]);
                    construction.append("; ");
                    construction.append(paramFields[2]);
                    construction.append("\r\n");
                }
            }
            if (fields.length < 3)
            {
                throw new Error("qualifiersTypeAndName should consist of at least three fields separated by |; got "
                        + qualifiersTypeAndName);
            }
            if (!"void".equals(fields[1]) && !constructor)
            {
                construction.append(indent + " * @return ");
                construction.append(fields[1]);
                if (4 == fields.length)
                {
                    construction.append("; " + fields[3]);
                }
                construction.append("\r\n");
            }
            construction.append(indent + " */\r\n");
        }
        else
        {
            construction.append(indent + "/** {@inheritDoc} */\r\n" + indent + "@Override\r\n");
        }
        construction.append(indent);

        construction.append(fields[0]);
        construction.append(" ");
        if (fields[1].length() > 0)
        {
            construction.append(fields[1]);
            construction.append(" ");
        }
        construction.append(fields[2]);
        construction.append("(");
        String sep = "";
        if (null != params)
        {
            for (String param : params)
            {
                construction.append(sep);
                sep = ", ";
                String[] paramFields = param.split("[|]");
                if (!paramFields[1].startsWith("<"))
                {
                    construction.append(paramFields[0]);
                    construction.append(" ");
                    construction.append(paramFields[1]);
                }
            }
        }
        construction.append(")");
        if (null != body)
        {
            construction.append("\r\n" + indent + "{\r\n");
            final String bodyIndent = indent + indentStep;
            for (String bodyLine : body)
            {
                construction.append(bodyIndent);
                construction.append(bodyLine);
                construction.append("\r\n");
            }
            construction.append(indent + "}\r\n");
        }
        else
        {
            construction.append(";\r\n");
        }
        construction.append("\r\n");
        return construction.toString();
    }

    /**
     * Create a String that describes one field.
     * @param indent String; prepended to each output line
     * @param field String; the type and name of the field
     * @param description String; the description of the field
     * @return String
     */
    public static String buildField(String indent, String field, String description)
    {
        return indent + "/** " + description + " */\r\n" + indent + field + ";\r\n\r\n";
    }

    /**
     * Generate the code for the value classes.
     * @param args String[]; the command line arguments (not used)
     */
    public static void main(String args[])
    {
        Date now = new Date();
        when = new SimpleDateFormat("dd MMM, yyyy").format(now);
        serialVersionUID = new SimpleDateFormat("yyyyMMdd").format(now);
        File testPath = new File(buildDir);
        if (!testPath.exists())
        {
            throw new Error("buildDir (" + buildDir + ") does not exist");
        }
        else if (!testPath.isDirectory())
        {
            throw new Error("buildDir (" + buildDir + ") is not a directory");
        }
        generateInterface("value", "Absolute", null,
                "Absolute values are quantities that are measured from some agreed upon reference point.", null, "",
                null);
        generateInterface("value", "Relative", null, "Relative values express differences.", null, "", null);
        generateInterface("value", "DenseData", null, "Values are stored densely.", null, "", null);
        generateInterface("value", "SparseData", null, "Values are stored sparsely (lots of zero values expected).",
                null, "", null);
        generateAbstractClass(
                "value",
                "AbstractValue",
                new String[]{"java.io.Serializable", "", "org.opentrafficsim.core.unit.Unit"},
                "AbstractValue is a class to help construct Matrix, Complex, "
                        + "and Vector but it does not extend java.lang.Number. The Scalar\r\n"
                        + " * class <i>does</i> extend Number, and implements the same interfaces from Value.",
                new String[]{"<U> the Unit of the value(s) in this AbstractValue. Used for setting, getting and displaying the value(s)"},
                "<U extends Unit<U>> implements Value<U>, Serializable",
                buildField(indentStep, "private final U unit", "The unit of the AbstractValue")
                        + buildMethod(indentStep, "public||AbstractValue", "Construct a new AbstractValue.",
                                new String[]{"final U|unit|the unit of the new AbstractValue"},
                                new String[]{"this.unit = unit;"}, true)
                        + buildMethod(indentStep, "public final|U|getUnit", null, null,
                                new String[]{"return this.unit;"}, false)
                        + buildMethod(indentStep, "protected final|double|expressAsSIUnit", null,
                                new String[]{"final double|value|"},
                                new String[]{"return ValueUtil.expressAsSIUnit(value, this.unit);"}, false)
                        + buildMethod(indentStep, "protected final|double|expressAsSpecifiedUnit",
                                "Convert a value in SI standard unit into the unit of this AbstractValue",
                                new String[]{"final double|value|the value in standard SI unit"},
                                new String[]{"return ValueUtil.expressAsUnit(value, this.unit);"}, false)
                        + buildMethod(indentStep, "public final|boolean|isAbsolute", null, null,
                                new String[]{"return this instanceof Absolute"}, false)
                        + buildMethod(indentStep, "public final|boolean|isRelative", null, null,
                                new String[]{"return this instanceof Relative"}, false));
        generateFinalClass(
                "value",
                "Format",
                null,
                "Format a floating point number in a reasonable way. <br>\r\n"
                        + " * I've experienced problems with the %g conversions that caused array bounds violations. Those versions of the JRE that do\r\n"
                        + " * <b>not</b> throw such Exceptions use one digit less than specified in the %g conversions. <br >\r\n"
                        + " * TODO: check how to always format numbers corresponding to the Locale used.",
                null,
                "",
                buildField(indentStep, "public static final int DEFAULTSIZE = 9",
                        "Default total width of formatted value.")
                        + buildField(indentStep, "public static final int DEFAULTPRECISION = 3",
                                "Default numberof fraction digits.")
                        + buildMethod(indentStep, "private static|String|formatString", "Build a format String.",
                                new String[]{"final int|width|the number of characters in the result",
                                        "final int|precision|the number of fractional digits in the result",
                                        "final String|converter|the format conversion specifier"},
                                new String[]{"return String.format(\"%%%d.%d%s\", width, precision, converter);"},
                                false) + buildFormatMethods("float") + buildFormatMethods("double"));
        generateInterface(
                "value",
                "MathFunctions",
                new String[]{"java.io.Serializable"},
                "Interface to force all functions of Math that must be implemented.",
                null,
                "extends Serializable",
                buildMathFunction("void abs()", "Set the value(s) to their absolute value(s).")
                        + buildMathFunction("void acos()",
                                "Set the value(s) to the arc cosine of the value; the resulting angle is in the range -pi/2 through pi/2.")
                        + buildMathFunction("void asin()",
                                "Set the value(s) to the arc sine of the value; the resulting angle is in the range -pi/2 through pi/2.")
                        + buildMathFunction("void atan()",
                                "Set the value(s) to the arc tangent of the value; the resulting angle is in the range -pi/2 through pi/2.")
                        + buildMathFunction("void cbrt()", "Set the value(s) to their cube root.")
                        + buildMathFunction("void ceil()",
                                "Set the value(s) to the smallest (closest to negative infinity) value(s) that are greater than or equal to the"
                                        + " * argument and equal to a mathematical integer.")
                        + buildMathFunction("void cos()",
                                "Set the value(s) to the trigonimetric cosine of the value(s).")
                        + buildMathFunction("void cosh()", "Set the value(s) to the hyperbolic cosine of the value(s).")
                        + buildMathFunction("void exp()",
                                "Set the value(s) to Euler's number e raised to the power of the value(s).")
                        + buildMathFunction("void exp()",
                                "Set the value(s) to Euler's number e raised to the power of the value(s) minus 1 (e^x - 1).")
                        + buildMathFunction("void floor()",
                                "Set the value(s) to the largest (closest to positive infinity) value(s) that are less than or equal to the"
                                        + " * argument and equal to a mathematical integer.")
                        + buildMathFunction("void log()",
                                "Set the value(s) to the natural logarithm (base e) of the value(s).")
                        + buildMathFunction("void log()", "Set the value(s) to the base 10logarithm of the value(s).")
                        + buildMathFunction("void log1p()",
                                "Set the value(s) to the natural logarithm of sum of the value(s) and 1")
                        + buildMathFunction("void pow(double x)",
                                "Set the value(s) to  the value(s) raised to the power of the argument\r\n"
                                        + "     * @param x double; the argument")
                        + buildMathFunction("void rint()",
                                "Set the value(s) to the value(s) that are closest in value to the argument and equal to a mathematical integer.")
                        + buildMathFunction("void round()",
                                "Set the value(s) to the closest long to the argument with ties rounding up.")
                        + buildMathFunction("void signum()",
                                "Set the value(s) to the signum function of the value(s); zero if the argument is zero, 1.0 if the argument is"
                                        + "     * greater than zero, -1.0 if the argument is less than zero.")
                        + buildMathFunction("void sin()", "Set the value(s) to the trigonimetric sine of the value(s).")
                        + buildMathFunction("void sinh()", "Set the value(s) to the hyperbolic sine of the value(s).")
                        + buildMathFunction("void sqrt()",
                                "Set the value(s) to the correctly rounded positive square root of the value(s)")
                        + buildMathFunction("void tan()",
                                "Set the value(s) to the trigonimetric tangent of the value(s).")
                        + buildMathFunction("void tanh()",
                                "Set the value(s) to the hyperbolic tangent of the value(s).")
                        + buildMathFunction("void toDegrees()",
                                "Set the value(s) to approximately equivalent angle(s) measured in degrees.")
                        + buildMathFunction("void toRadians()",
                                "Set the value(s) to approximately equivalent angle(s) measured in radians.")
                        + buildMathFunction("void inv()", "Set the value(s) to the complement (1.0/x) of the value(s)."));
        generateInterface(
                "value",
                "Value",
                new String[]{"org.opentrafficsim.core.unit.Unit"},
                "Value is a static interface that forces implementation of a few unit- and value-related methods.",
                new String[]{"<U> the unit type"},
                "<U extends Unit<U>>",
                buildMethod(indentStep, "public final|U|getUnit", "Return the unit of the Value.", null, null, false)
                        + buildMethod(indentStep, "|double|expressAsSIUnit", "Convert a value to the standard SI unit",
                                new String[]{"final double|value|the value to convert to the standard SI unit"}, null,
                                false)
                        + buildMethod(indentStep, "|boolean|isAbsolute", "Indicate whether this is an Absolute Value",
                                null, null, false)
                        + buildMethod(indentStep, "|boolean|isRelative", "Indicate whether this is a Relative Value",
                                null, null, false)
                        + buildMethod(indentStep, "|Value<U>|copy", "Create a deep copy of this Value", null, null,
                                false));

        generateClass(
                "value",
                "ValueException",
                null,
                "Exception that is thrown for bad indices or non-rectangular, or effectively empty arrays",
                null,
                "public",
                "extends Exception",
                true,
                buildMethod(indentStep, "public||ValueException", "Construct a new ValueException.", null,
                        new String[]{"super();"}, true)
                        + buildMethod(indentStep, "public||ValueException", "Construct a new ValueException.",
                                new String[]{"final String|message|description of the problem"},
                                new String[]{"super(message);"}, true)
                        + buildMethod(indentStep, "public||ValueException", "Construct a new ValueException.",
                                new String[]{"final String|message|description of the problem",
                                        "final Throwable|cause|the cause of this ValueException"},
                                new String[]{"super(message, cause);"}, true)
                        + buildMethod(
                                indentStep,
                                "public||ValueException",
                                "Construct a new ValueException.",
                                new String[]{
                                        "final String|message|description of the problem",
                                        "final Throwable|cause|the cause of this ValueException",
                                        "final boolean|enableSuppression|whether or not suppression is enabled or disabled",
                                        "final boolean|writableStackTrace|whether or not the stack trace should be writable"},
                                new String[]{"super(message, cause, enableSuppression, writableStackTrace);"}, true));
        generateFinalClass(
                "value",
                "ValueUtil",
                null,
                "ValueUtil implements a couple of unit-related static methods.",
                null,
                "",
                buildMethod(indentStep, "public static|double|expressAsSIUnit",
                        "Convert a value in a given unit into the equivalent in the standard SI unit", new String[]{
                                "final double|value|the value to convert into standard SI unit",
                                "final Unit<?>|unit|the unit of the given value"}, new String[]{
                                "if (unit instanceof OffsetUnit<?>)", "{",
                                "    return (value - ((OffsetUnit<?>) unit).getOffsetToStandardUnit())",
                                "            * unit.getConversionFactorToStandardUnit();", "}",
                                "return value * unit.getConversionFactorToStandardUnit();"}, false)

                        + buildMethod(indentStep, "public static|double|expressAsUnit",
                                "Convert a value in the standard SI unit into another unit", new String[]{
                                        "final double|siValue|the given value in SI standard unit",
                                        "final Unit<?>|targetUnit|the unit to convert the value into"}, new String[]{
                                        "if (targetUnit instanceof OffsetUnit<?>)", "{",
                                        "    return siValue / targetUnit.getConversionFactorToStandardUnit()",
                                        "            + ((OffsetUnit<?>) targetUnit).getOffsetToStandardUnit();", "}",
                                        "return siValue / targetUnit.getConversionFactorToStandardUnit();"}, false));

        generateInterface(
                "value.vdouble",
                "DoubleMathFunctions",
                new String[]{"org.opentrafficsim.core.value.MathFunctions"},
                "Force implementation of multiply and divide.",
                null,
                "",
                buildMethod(indentStep, "|void|multiply", "Scale the value(s) by a factor",
                        new String[]{"double|factor|the multiplier"}, null, false)
                        + buildMethod(indentStep, "|void|divide",
                                "Scale the value(s) by the inverse of a factor; i.e. a divisor",
                                new String[]{"double|divisor|the divisor"}, null, false)

        );

        generateFinalClass(
                "value.vdouble",
                "DoubleMathFunctionsImpl",
                new String[]{"import cern.colt.function.tdouble.DoubleFunction"},
                "DoubleFunction implementations of the standard Math functions.",
                null,
                "",
                buildDoubleOrFloatFunction("cbrt", "Double", "") + buildDoubleOrFloatFunction("cosh", "Double", "")
                        + buildDoubleOrFloatFunction("expm1", "Double", "")
                        + buildDoubleOrFloatFunction("log10", "Double", "")
                        + buildDoubleOrFloatFunction("log1p", "Double", "")
                        + buildDoubleOrFloatFunction("round", "Double", "")
                        + buildDoubleOrFloatFunction("signum", "Double", "")
                        + buildDoubleOrFloatFunction("sinh", "Double", "")
                        + buildDoubleOrFloatFunction("tanh", "Double", "")
                        + buildDoubleOrFloatFunction("toDegrees", "Double", "")
                        + buildDoubleOrFloatFunction("toRadians", "Double", ""));

        generateInterface(
                "value.vfloat",
                "FloatMathFunctions",
                new String[]{"org.opentrafficsim.core.value.MathFunctions"},
                "Force implementation of multiply and divide.",
                null,
                "",
                buildMethod(indentStep, "|void|multiply", "Scale the value(s) by a factor",
                        new String[]{"float|factor|the multiplier"}, null, false)
                        + buildMethod(indentStep, "|void|divide",
                                "Scale the value(s) by the inverse of a factor; i.e. a divisor",
                                new String[]{"float|divisor|the divisor"}, null, false)

        );

        generateFinalClass(
                "value.vfloat",
                "FloatMathFunctionsImpl",
                new String[]{"import cern.colt.function.tdouble.FloatFunction"},
                "FloatFunction implementations of the standard Math functions.",
                null,
                "",
                buildDoubleOrFloatFunction("cbrt", "Float", "(float)")
                        + buildDoubleOrFloatFunction("cosh", "Double", "")
                        + buildDoubleOrFloatFunction("expm1", "Float", "(float)")
                        + buildDoubleOrFloatFunction("log10", "Float", "(float)")
                        + buildDoubleOrFloatFunction("log1p", "Float", "")
                        + buildDoubleOrFloatFunction("round", "Float", "")
                        + buildDoubleOrFloatFunction("signum", "Float", "")
                        + buildDoubleOrFloatFunction("sinh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("tanh", "Float", "(float)")
                        + buildDoubleOrFloatFunction("toDegrees", "Float", "")
                        + buildDoubleOrFloatFunction("toRadians", "Float", "(float)"));

        generateScalarClass("Float", false);
        generateScalarClass("Float", true);
        generateScalarClass("Double", false);
        generateScalarClass("Double", true);

    }

    /**
     * Generate a class file for a scalar type.
     * @param scalarType String; must be <cite>Float</cite>, or <cite>Double</cite> (starting with a capital latter)
     * @param mutable boolean; if true the mutable class is generated; of false the immutable class is generated
     */
    private static void generateScalarClass(String scalarType, boolean mutable)
    {
        final String lowerCaseType = scalarType.toLowerCase();
        final String outerIndent = indentStep;
        final String cast = scalarType.equals("Double") ? "" : "(float) ";
        final String mutableType = mutable ? "Mutable" : "Immutable ";
        generateAbstractClass(
                "value.v" + lowerCaseType + ".scalar",
                (mutable ? "Mutable" : "") + scalarType + "Scalar",
                mutable ? new String[]{"org.opentrafficsim.core.unit.SICoefficients",
                        "org.opentrafficsim.core.unit.SIUnit", "org.opentrafficsim.core.unit.Unit",
                        "org.opentrafficsim.core.value.Absolute", "org.opentrafficsim.core.value.Relative",
                        "org.opentrafficsim.core.value.ValueUtil",
                        "org.opentrafficsim.core.value.v" + lowerCaseType + "." + scalarType + "MathFunctions"}
                        : new String[]{"org.opentrafficsim.core.unit.Unit", "org.opentrafficsim.core.value.Absolute",
                                "org.opentrafficsim.core.value.Relative", "org.opentrafficsim.core.value.Scalar",
                                "org.opentrafficsim.core.value.ValueUtil"},
                (mutable ? "Mutable" : "Immutable ") + scalarType + "Scalar.",
                new String[]{"<U> the unit of the values in the constructor and for display"},
                "<U extends Unit<U>> extends " + (mutable ? "Float" : "") + "Scalar<U>"
                        + (mutable ? " implements " + scalarType + "MathFunctions" : ""),
                (mutable ? "" : buildField(outerIndent, "private " + lowerCaseType + " valueSI",
                        "The value, stored in the standard SI unit."))
                        + buildMethod(outerIndent, "protected||" + (mutable ? "Mutable" : " ") + scalarType + "Scalar",
                                "Construct a new " + mutableType + scalarType + "Scalar.",
                                new String[]{"final U|unit|the unit of the new " + (mutable ? "Mutable" : "")
                                        + scalarType + "Scalar"}, new String[]{"super(unit);"}, true)
                        + buildSubClass(outerIndent, "Abs", "Absolute " + mutableType + scalarType + "Scalar",
                                scalarType + "Scalar<U>", "Absolute, Comparable<Abs<U>>", scalarType + "Scalar",
                                mutable)
                        + buildSubClass(outerIndent, "Rel", "Relative " + mutableType + scalarType + "Scalar",
                                scalarType + "Scalar<U>", "Relative, Comparable<Rel<U>>", scalarType + "Scalar",
                                mutable)
                        + (mutable
                                ? buildMethod(
                                        outerIndent,
                                        "public abstract|" + scalarType + "Scalar<U>|immutable",
                                        "Create an immutable version of this Mutable"
                                                + scalarType
                                                + "Scalar. <br>\r\n"
                                                + outerIndent
                                                + " * The immutable version is created as a deep copy of this. Delayed copying is not worthwhile for a Scalar.",
                                        null, null, false)
                                        + buildMethod(
                                                outerIndent,
                                                "final|void|setSI",
                                                "Replace the stored value by the supplied value which is expressed in the standard SI unit.",
                                                new String[]{"final "
                                                        + scalarType.toLowerCase()
                                                        + "|valueSI|the value to store (value must already be in the standard SI unit)"},
                                                new String[]{"setValueSI(valueSI);"}, false)
                                        + buildMethod(outerIndent, "final|void|set|",
                                                "Replace the stored value by the supplied value.",
                                                new String[]{"final " + scalarType
                                                        + "Scalar<U>|value|the strongly typed value to store"},
                                                new String[]{"setValueSI(value.getValueSI());"}, false)
                                        + buildMethod(
                                                outerIndent,
                                                "final|void|setInUnit",
                                                "Replace the stored value by the supplied value which can be expressed in any compatible unit.",
                                                new String[]{"final float|value|the value to store",
                                                        "final U|valueUnit|the unit of the supplied value"},
                                                new String[]{"setValueSI(" + cast
                                                        + " ValueUtil.expressAsSIUnit(value, valueUnit));"}, false)
                                        + buildOtherMutatingScalarMethods(outerIndent, scalarType)
                                : buildMethod(
                                        outerIndent,
                                        "public abstract|Mutable" + scalarType + "Scalar<U>|mutable",
                                        "Create a mutable version of this "
                                                + scalarType
                                                + "Scalar. <br>\r\n"
                                                + outerIndent
                                                + " * The mutable version is created as a deep copy of this. Delayed copying is not worthwhile for a Scalar.",
                                        null, null, false)
                                        + buildMethod(
                                                outerIndent,
                                                "protected final|void|initialize",
                                                "Initialize the valueSI field (performing conversion to the SI standard unit if needed).",
                                                new String[]{"final " + lowerCaseType
                                                        + "|value|the value in the unit of this " + scalarType
                                                        + "Scalar"}, new String[]{
                                                        "if (this.getUnit().equals(this.getUnit().getStandardUnit()))",
                                                        "{",
                                                        indentStep + "this.valueSI = value;",
                                                        "}",
                                                        "else",
                                                        "{",
                                                        indentStep + "this.valueSI = " + cast
                                                                + "expressAsSIUnit(value);", "}"}, false)
                                        + buildMethod(
                                                outerIndent,
                                                "protected final|void|initialize",
                                                "Initialize the valueSI field. As the provided value is already in the SI standard unit, conversion is never necessary.",
                                                new String[]{"final " + scalarType
                                                        + "Scalar<U>|value|the value to use for initialization"},
                                                new String[]{"setValueSI(value.getValueSI());"}, false)
                                        + buildMethod(outerIndent, "public final|" + lowerCaseType + "|getValueSI",
                                                "Retrieve the value in the underlying SI unit.", null,
                                                new String[]{"return this.valueSI;"}, false)
                                        + buildMethod(outerIndent, "protected final|void|setValueSI",
                                                "Set the value in the underlying SI unit.", new String[]{"final "
                                                        + scalarType.toLowerCase()
                                                        + "|value|the new value in the underlying SI unit"},
                                                new String[]{"this.valueSI = value;"}, false)
                                        + buildMethod(
                                                outerIndent,
                                                "public final|" + scalarType.toLowerCase() + "|getValueInUnit",
                                                "Retrieve the value in the original unit.",
                                                null,
                                                new String[]{"return " + cast + "expressAsSpecifiedUnit(this.valueSI);"},
                                                false)
                                        + buildMethod(outerIndent, "public final|" + scalarType.toLowerCase()
                                                + "|getValueInUnit",
                                                "Retrieve the value converted into some specified unit.",
                                                new String[]{"final U|targetUnit|the unit to convert the value into"},
                                                new String[]{"return " + cast
                                                        + "ValueUtil.expressAsUnit(this.valueSI, targetUnit);"}, false)
                                        + buildNumberMethods(scalarType))

        );

    }

    /**
     * Generate most of the java code that modifies MutableScalar values.
     * @param indent String; prepended to output lines on the outermost level of the generated code
     * @param scalarType String; either <cite>Float</cite> or <cite>Double</cite>
     * @return String
     */
    private static String buildOtherMutatingScalarMethods(String indent, String scalarType)
    {
        StringBuilder construction = new StringBuilder();
        construction.append(indent
                + "/**********************************************************************************/\r\n");
        construction.append(indent
                + "/******************************* NON-STATIC METHODS *******************************/\r\n");
        construction.append(indent
                + "/**********************************************************************************/\r\n\r\n");
        construction.append(buildMethod(indent, "public final|void|add", "Add another value to this value. "
                + "Only Relative values are allowed; adding an absolute value to an absolute value\r\n" + indent
                + " * is not allowed. Adding an absolute value to an existing relative value would require the "
                + "result to become\r\n" + indent
                + " * absolute, which is atype change that is impossible. For that operation, use a static method.",
                new String[]{"final " + scalarType.toLowerCase() + "Scalar.Rel<U>|value|the value to add"},
                new String[]{"setValueSI(getValueSI() + value.getValueSI());"}, false));
        construction
                .append(buildMethod(
                        indent,
                        "public final|void|subtract",
                        "Subtract another value from this value. "
                                + "Only relative values are allowed; subtracting an absolute value from a\r\n"
                                + indent
                                + " * relative value is not allowed. Subtracting an absolute value from an existing absolute value "
                                + "would require the\r\n" + indent
                                + " * result to become relative, which is a type change that is impossible. "
                                + "For that operation, use a static method.",
                        new String[]{"final " + scalarType.toLowerCase() + "Scalar.Rel<U>|value|the value to subtract"},
                        new String[]{"setValueSI(getValueSI() - value.getValueSI());"}, false));
        construction.append(indent
                + "/**********************************************************************************/\r\n");
        construction.append(indent
                + "/********************************* STATIC METHODS *********************************/\r\n");
        construction.append(indent
                + "/**********************************************************************************/\r\n\r\n");
        construction.append(buildMethod(indent, "protected final|" + scalarType
                + "Scalar<?>|incrementBy|the modified Mutable" + scalarType + "Scalar",
                "Increment the stored value by a specified amount.", new String[]{"final " + scalarType.toLowerCase()
                        + "Scalar<?>|increment|the amount by which to increment the stored value"}, new String[]{
                        "setValueSI(getValueSI() + increment.getValueSI());", "return this;"}, false));
        construction.append(buildScalarPlus(indent, scalarType, true));
        construction.append(buildScalarPlus(indent, scalarType, false));
        construction.append(buildMethod(indent, "protected final|" + scalarType
                + "Scalar<?>|decrementBy|the modified Mutable" + scalarType + "Scalar",
                "Decrement the stored value by a specified amount.", new String[]{"final " + scalarType.toLowerCase()
                        + "Scalar<?>|decrement|the amount by which to decrement the stored value"}, new String[]{
                        "setValueSI(getValueSI() - decrement.getValueSI());", "return this;"}, false));
        construction.append(buildScalarMinus(indent, scalarType, true));
        construction.append(buildScalarMinus(indent, scalarType, false));

        return construction.toString();
    }

    /**
     * Build the plus method for adding an array of relative scalars to an absolute or relative scalar.
     * @param indent String; prepended to each line
     * @param scalarType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @param absoluteResult boolean; if true the first operand and the result are absolute; if false, the first operand
     *            and the result are relative
     * @return String; java code
     */
    private static String buildScalarPlus(final String indent, final String scalarType, boolean absoluteResult)
    {
        final String absRel = absoluteResult ? "Abs" : "Rel";
        return buildMethod(
                indent,
                "@SafeVarargs\r\n" + indent + "public static <U extends Unit<U>>|Mutable" + scalarType + "Scalar."
                        + absRel + "<U>|plus|the sum of the values as "
                        + (absoluteResult ? "an absolute" : "a relative") + " value",
                absoluteResult
                        ? "Add a number of relative values to an absolute value. Return a new instance of the value. "
                                + "The unit of the return\r\n" + indent
                                + " * value will be the unit of the first argument. "
                                + "Due to type erasure of generics, the method cannot check whether an\r\n" + indent
                                + " * array of arguments submitted to the varargs has a mixed-unit content at runtime."
                        : "Add a number of relative values. Return a new instance of the value. Due to type erasure of generics, "
                                + "the method\r\n"
                                + indent
                                + " * cannot check whether an array of arguments submitted to the varargs has a "
                                + "mixed-unit content at runtime.", new String[]{
                        absoluteResult ? "final " + scalarType + "Scalar." + absRel + "<U>|value" + absRel
                                + "|the absolute base value" : "final U|targetUnit| the unit of the sum",
                        "final " + scalarType + "Scalar.Rel<U>...|valuesRel|zero or more relative values to add "
                                + (absoluteResult ? "to the absolute value" : "together"),
                        "Unit|<U>|the unit of the parameters and the result"}, new String[]{
                        "Mutable"
                                + scalarType
                                + "Scalar."
                                + absRel
                                + "<U> result = new MutableFloatScalar."
                                + absRel
                                + "<U>("
                                + (absoluteResult ? "valueAbs);" : "0.0" + (scalarType.startsWith("F") ? "f" : "")
                                        + ", targetUnit);"), "for (" + scalarType + "Scalar.Rel<U> v : valuesRel)",
                        "{", indentStep + "result.incrementBy(v);", "}", "return result;"}, false);
    }

    /**
     * Build the minus method for adding an array of relative scalars to an absolute or relative scalar.
     * @param indent String; prepended to each line
     * @param scalarType String; either <cite>Float</cite>, or <cite>Double</cite>
     * @param absoluteResult boolean; if true the first operand and the result are absolute; if false, the first operand
     *            and the result are relative
     * @return String; java code
     */
    private static String buildScalarMinus(final String indent, final String scalarType, boolean absoluteResult)
    {
        final String absRel = absoluteResult ? "Abs" : "Rel";
        return buildMethod(
                indent,
                "@SafeVarargs\r\n" + indent + "public static <U extends Unit<U>>|Mutable" + scalarType + "Scalar."
                        + absRel + "<U>|minus|the resulting value as "
                        + (absoluteResult ? "an absolute" : "a relative") + " value",
                absoluteResult
                        ? "Subtract a number of relative values from an absolute value. Return a new instance of the value. "
                                + "The unit of the\r\n"
                                + indent
                                + " * return value will be the unit of the first argument. "
                                + "Due to type erasure of generics, the method cannot check\r\n"
                                + indent
                                + " * whether an array of arguments submitted to the varargs has a mixed-unit content at runtime."
                        : "Subtract a number of relative values from a relative value. Return a new instance of the value. "
                                + "The unit of the\r\n"
                                + indent
                                + " * value will be the unit of the first argument. Due to type erasure of generics, the method "
                                + "cannot check whether an\r\n"
                                + indent
                                + " * array of arguments submitted to the varargs has a "
                                + "mixed-unit content at runtime.", new String[]{
                        "final " + scalarType + "Scalar." + absRel + "<U>|value" + absRel + "|the "
                                + (absoluteResult ? "absolute" : "relative") + " base value",
                        "final " + scalarType + "Scalar.Rel<U>...|valuesRel|zero or more relative values to subtract "
                                + (absoluteResult ? "from the absolute value" : "from the first value"),
                        "Unit|<U>|the unit of the parameters and the result"}, new String[]{
                        "Mutable" + scalarType + "Scalar." + absRel + "<U> result = new MutableFloatScalar." + absRel
                                + "<U>(value" + absRel + ");", "for (" + scalarType + "Scalar.Rel<U> v : valuesRel)",
                        "{", indentStep + "result.decrementBy(v);", "}", "return result;"}, false);
    }

    /**
     * Generate the Java code that implements the Number methods.
     * @return
     */
    private static String buildNumberMethods(String type)
    {
        final String cast = type.equals("Float") ? "" : "(float) ";
        final String lowerCaseType = type.toLowerCase();
        final String indent = indentStep;
        StringBuilder construction = new StringBuilder();
        construction.append(indent
                + "/**********************************************************************************/\r\n");
        construction.append(indent
                + "/******************************** NUMBER METHODS **********************************/\r\n");
        construction.append(indent
                + "/**********************************************************************************/\r\n\r\n");
        construction.append(buildMethod(indent, "public final|int|intValue", null, null,
                new String[]{"return " + (type.equals("Float") ? "" : "(int) ") + "Math.round(this.valueSI);"}, false));
        construction.append(buildMethod(indent, "public final|long|longValue", null, null,
                new String[]{"return Math.round(this.valueSI);"}, false));
        construction.append(buildMethod(indent, "public final|float|floatValue", null, null, new String[]{"return "
                + cast + "this.valueSI;"}, false));
        construction.append(buildMethod(indent, "public final|double|doubleValue", null, null,
                new String[]{"return this.valueSI;"}, false));
        construction.append(buildMethod(indent, "public final|String|toString", null, null,
                new String[]{"return this.getValueInUnit() + \" \" + this.getUnit().getAbbreviationKey();"}, false));
        construction.append(buildMethod(indent, "public final|int|hashCode", null, null, type.equals("Float")
                ? new String[]{"final int prime = 31;", "int result = 1;",
                        "result = prime * result + Float.floatToIntBits(this.valueSI);", "return result;"}
                : new String[]{"final int prime = 31;", "int result = 1;", "long temp;",
                        "temp = Double.doubleToLongBits(this.valueSI);",
                        "result = prime * result + (int) (temp ^ (temp >>> 32));", "return result;"}, false));
        construction.append(buildMethod(indent, "public final|boolean|equals", null,
                new String[]{"final Object|obj|the Object to compare with"}, new String[]{
                        "if (this == obj)",
                        "{",
                        indentStep + "return true;",
                        "}",
                        "if (obj == null)",
                        "{",
                        indentStep + "return false;",
                        "}",
                        "if (!(obj instanceof " + type + "Scalar))",
                        "{",
                        indentStep + "return false;",
                        "}",
                        type + "Scalar<?> other = (" + type + "Scalar<?>) obj;",
                        "// unequal if not both Absolute or both Relative",
                        "if (this.isAbsolute() != other.isAbsolute() || this.isRelative() != other.isRelative())",
                        "{",
                        indentStep + "return false;",
                        "}",
                        "// unequal if the underlying standard SI unit is different",
                        "if (!this.getUnit().getStandardUnit().equals(other.getUnit().getStandardUnit()))",
                        "{",
                        indentStep + "return false;",
                        "}",
                        "if (" + type + "." + lowerCaseType + (type.equals("Float") ? "ToIntBits" : "ToLongBits")
                                + "(this.valueSI) != " + type + "." + lowerCaseType
                                + (type.equals("Float") ? "ToIntBits" : "ToLongBits") + "(other.valueSI))", "{",
                        indentStep + "return false;", "}", "return true;"}, false));
        construction.append(indent
                + "/**********************************************************************************/\r\n");
        construction.append(indent
                + "/******************************** NUMBER METHODS **********************************/\r\n");
        construction.append(indent
                + "/**********************************************************************************/\r\n\r\n");

        return construction.toString();
    }

    /**
     * Generate the Java code for a sub class of scalar
     * @param indent String; prefix for each output line
     * @param name String; name of the sub class, e.g. <cite>Abs</cite> or <cite>Rel</cite>
     * @param longName String; full name of the sub class, e.g. <cite>Absolute Immutable FloatScalar</cite> or
     *            <cite>Relative Mutable DoubleScalar</cite>
     * @param extendsString String; something like <cite>DoubleScalar&lt;U&gt;</cite>
     * @param implementsString String; something like <cite>Absolute, Comparable&lt;Abs&lt;U&gt;&gt;</cite>
     * @param parentClassName String; name of the class that is being sub-classed
     * @param mutable boolean; if true; the class file for the mutable version is generated; if false; the class file
     *            for the immutable version is generated
     * @return String; java code implementing the sub class
     */
    private static String buildSubClass(final String indent, final String name, final String longName,
            final String extendsString, final String implementsString, final String parentClassName, boolean mutable)
    {
        final String absRelType = longName.split(" ")[0];
        final String floatType = extendsString.contains("Float") ? "Float" : "Double";
        StringBuilder construction = new StringBuilder();
        construction.append(indent + "/**\r\n" + indent + " * @param <U> Unit\r\n" + indent + " */\r\n");
        construction.append(indent + "public static class " + name + "<U extends Unit<U>> extends "
                + (mutable ? "Mutable" : "") + extendsString + " implements " + implementsString + "\r\n" + indent
                + "{\r\n");
        final String contentIndent = indent + indentStep;
        construction.append(buildSerialVersionUID(contentIndent));
        construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName + ".",
                new String[]{"final " + floatType.toLowerCase() + "|value|the value of the new " + longName,
                        "final U|unit|the unit of the new " + longName}, new String[]{"super(unit);",
                        "// System.out.println(\"Created " + name + "\");", "initialize(value);"}, true));
        construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName
                + " from an existing " + absRelType + " Immutable " + floatType + "Scalar.", new String[]{"final "
                + parentClassName + "." + name + "<U>|value|the reference"}, new String[]{"super(value.getUnit());",
                "// System.out.println(\"Created " + name + "\");", "initialize(value);"}, true));
        construction.append(buildMethod(contentIndent, "public||" + name, "Construct a new " + longName
                + " from an existing " + absRelType + " Mutable" + floatType + "Scalar.", new String[]{"final "
                + " Mutable" + floatType + "Scalar." + name + "<U>|value|the reference"}, new String[]{
                "super(value.getUnit());", "// System.out.println(\"Created " + name + "\");", "initialize(value);"},
                true));
        construction.append(buildMethod(contentIndent, "public final|" + "Mutable" + floatType + "Scalar." + name
                + "<U>|mutable", null, null, new String[]{"return new Mutable" + floatType + "Scalar." + name
                + "<U>(this);"}, false));
        if (mutable)
        {
            construction.append(buildMethod(contentIndent, "public final|" + parentClassName + "." + name
                    + "<U>|immutable", null, null, new String[]{"return new " + parentClassName + "." + name
                    + "<U>(this);"}, false));
        }
        construction.append(buildMethod(contentIndent, "public final|int|compareTo", null, new String[]{"final|" + name
                + "<U> o|"}, new String[]{"return new " + floatType + "(getValueSI()).compareTo(o.getValueSI());"},
                false));
        construction.append(buildMethod(contentIndent, "public final|" + (mutable ? "Mutable" : "") + parentClassName
                + "." + name + "<U>|copy", null, null, new String[]{mutable ? "return new Mutable" + floatType
                + "Scalar." + name + "<U>(this);" : "return this;"}, false));
        construction.append(indent + "}\r\n\r\n");
        return construction.toString();
    }

    /**
     * Build the implementation of a DoubleFunction.
     * @param name String; name of the DoubleFunction.
     * @param objectType String; should be <cite>Double</cite>, or <cite>Float</cite>
     * @param casts String; should be <cite>(float)</cite> or the empty String
     * @return String; java code that implements the DoubleFunction
     */
    private static String buildDoubleOrFloatFunction(final String name, String objectType, String casts)
    {
        return "    /*\r\n     * Function that returns <tt>Math." + name + "(a)</tt>.\r\n     */\r\n"
                + "    public static final " + objectType + "Function " + name + " = new " + objectType
                + "Function()\r\n    {\r\n" + "        @Override\r\n        public " + objectType.toLowerCase()
                + " apply(final " + objectType.toLowerCase() + " a)\r\n" + "        {\r\n            return " + casts
                + "Math." + name + "(a)\r\n" + "        }\r\n    };\r\n\r\n";
    }

    /**
     * Build the interface for one math function
     * @param function String; code for the math function
     * @param description String; description of the math function
     * @return String; java code for the interface of the math function
     */
    private static String buildMathFunction(final String function, final String description)
    {
        return "    /**\r\n     * " + description + "\r\n     */\r\n    " + function + "\r\n\r\n";
    }

    /**
     * Generate the three format functions for either float or double typed value.
     * @param valueType String; should be <cite>float</cite> or <cite>double</cite>
     * @return String; java code for the three format functions
     */
    private static String buildFormatMethods(String valueType)
    {
        return buildMethod(indentStep, "public static|String|format", "Format a floating point value.", new String[]{
                "final " + valueType + "|value|the value to format",
                "final int|width|the number of characters in the result",
                "final int|precision|the number of fractional digits in the result"},
                new String[]{"return String.format(formatString(width, precision, \"f\"), value);"}, false)

                + buildMethod(indentStep, "public static|String|format", "Format a floating point value.",
                        new String[]{"final " + valueType + "|value|the value to format",
                                "final int|size|the number of characters in the result"},
                        new String[]{"return Format.format(value, size, Format.DEFAULTPRECISION);"}, false)
                + buildMethod(indentStep, "public static|String|format", "Format a floating point value.",
                        new String[]{"final " + valueType + "|value|the value to format",},
                        new String[]{"return format(value, Format.DEFAULTSIZE, Format.DEFAULTPRECISION);"}, false);
    }

}
