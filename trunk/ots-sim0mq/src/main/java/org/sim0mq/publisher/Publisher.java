package org.sim0mq.publisher;

import java.rmi.RemoteException;
import java.util.LinkedHashMap;
import java.util.Map;

import org.djunits.Throw;
import org.djutils.event.EventProducerInterface;
import org.djutils.metadata.MetaData;
import org.djutils.metadata.ObjectDescriptor;
import org.opentrafficsim.core.gtu.GTU;
import org.opentrafficsim.core.network.Network;
import org.opentrafficsim.core.network.OTSNetwork;

/**
 * Publish all available transceivers for an OTS network to a Sim0MQ master and handle its requests. <br>
 * Example sequence of events: <br>
 * <ol>
 * <li>OTSNetwork is somehow constructed and then a Publisher for that network is constructed.</li>
 * <li>Sim0MQ master requests names of all available subscription handlers</li>
 * <li>Sim0MQ master decides that it wants all GTU MOVE events of all GTUs. To do that it needs to know about all GTUs when they
 * are created and about all GTUs that have already been created. The Sim0MQ master issues to the publisher a request to
 * subscribe to all NETWORK.GTU_ADD_EVENTs of the GTUs_in_network SubscriptionHandler</li>
 * <li>This Publisher requests the GTUs_in_network SubscriptionHandler to subscribe to the add events. From now on, the
 * GTUs_in_network SubscriptionHandler will receive these events generated by the OTSNetwork and transcribe those into a Sim0MQ
 * events which are transmitted to the Sim0MQ master.</li>
 * <li>Sim0MQ master requests publisher to list all the elements of the GTUs_in_network SubscriptionHandler</li>
 * <li>This Publisher calls the list method of the GTUs_in_network SubscriptionHandler which results in a list of all active
 * GTUs being sent to the Sim0MQ master</li>
 * <li>The Sim0MQ master requests this Publisher to create a subscription for the update events of the GTU_move
 * SubscriptionHandler, providing the GTU id as address. It does that once for every GTU id.</li>
 * <li>This Publishers creates the subscriptions. From now on any GTU.MOVE_EVENT event is transcribed by the GTU_move
 * SubscriptionHandler in to a corresponding Sim0MQ event and sent to the Sim0MQ master.</li>
 * </ol>
 * <p>
 * Copyright (c) 2020-2020 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="http://opentrafficsim.org/docs/license.html">OpenTrafficSim License</a>.
 * <p>
 * $LastChangedDate: 2020-02-13 11:08:16 +0100 (Thu, 13 Feb 2020) $, @version $Revision: 6383 $, by $Author: pknoppers $,
 * @author <a href="http://www.tbm.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="http://www.tudelft.nl/pknoppers">Peter Knoppers</a>
 */
public class Publisher extends AbstractTransceiver
{
    /** Map Publisher names to the corresponding Publisher object. */
    private final Map<String, SubscriptionHandler> subscriptionHandlerMap = new LinkedHashMap<>();

    /** Embedded transceiver that can produce the names of all the subscription handlers for the objects in the OTS network. */
    private final TransceiverInterface idTransceiver = new AbstractTransceiver("Ids of available SubscriptionHandlers",
            new MetaData("SubscriptionHandler", "id of subscription handler", new ObjectDescriptor[0]),
            new MetaData("SubscriptionHandler", "Id of subscription handler", new ObjectDescriptor[] {
                    new ObjectDescriptor("SubscriptionHandler", "Id of subscription handler", String.class) }))
    {
        /** {@inheritDoc} */
        @Override
        public Object[] get(final Object[] address)
        {
            getAddressFields().verifyComposition(address);
            Object[] result = new Object[subscriptionHandlerMap.size()];
            int index = 0;
            for (String key : subscriptionHandlerMap.keySet())
            {
                result[index++] = key;
            }
            return result;
        };
    };

    /**
     * Construct a Publisher for an OTS network.
     * @param network OTSNetwork; the OTS network
     */
    public Publisher(final OTSNetwork network)
    {
        super("Publisher for " + Throw.whenNull(network, "Network may not be null").getId(),
                new MetaData("Publisher for " + network.getId(), "Publisher",
                        new ObjectDescriptor[] { new ObjectDescriptor("Transceiver name", "Transceiver name", String.class) }),
                new MetaData("Subscription handlers", "Subscription handlers", new ObjectDescriptor[] {
                        new ObjectDescriptor("Subscription handler", "Subscription handler", SubscriptionHandler.class) }));

        GTUIdTransceiver gtuIdTransceiver = new GTUIdTransceiver(network);
        GTUTransceiver gtuTransceiver = new GTUTransceiver(network, gtuIdTransceiver);
        SubscriptionHandler gtuSubscriptionHandler =
                new SubscriptionHandler("GTU move", gtuTransceiver, null, null, null, GTU.MOVE_EVENT, null);
        addSubscriptionHandler(gtuSubscriptionHandler);
        addSubscriptionHandler(new SubscriptionHandler("GTUs in network", gtuIdTransceiver, new LookupEventProducerInterface()
        {
            @Override
            public EventProducerInterface lookup(final Object[] address)
            {
                return network;
            }
            
            @Override
            public String toString()
            {
                return "Subscription handler for GTUs in network";
            }
        }, Network.GTU_ADD_EVENT, Network.GTU_REMOVE_EVENT, null, gtuSubscriptionHandler));
        // LinkIdTransceiver linkIdTransceiver = new LinkIdTransceiver(network);
        // addTransceiver(linkIdTransceiver);
        // addTransceiver(new LinkTransceiver(network, linkIdTransceiver));
        // addTransceiver(new CrossSectionElementTransceiver(network));
        // addTransceiver(new LinkGTUIdTransceiver(network));
        // addTransceiver(new LaneGTUIdTransceiver(network));
        // NodeIdTransceiver nodeIdTransceiver = new NodeIdTransceiver(network);
        // addTransceiver(nodeIdTransceiver);
        // addTransceiver(new NodeTransceiver(network, nodeIdTransceiver));
    }

    /**
     * Add a SubscriptionHandler to the map.
     * @param subscriptionHandler SubscriptionHandler; the subscription handler to add to the map
     */
    private void addSubscriptionHandler(final SubscriptionHandler subscriptionHandler)
    {
        this.subscriptionHandlerMap.put(subscriptionHandler.getId(), subscriptionHandler);
    }

    /** {@inheritDoc} */
    @Override
    public Object[] get(final Object[] address)
    {
        getAddressFields().verifyComposition(address);
        SubscriptionHandler result = this.subscriptionHandlerMap.get(address[0]);
        if (null != result)
        {
            return new Object[] { result };
        }
        return null;
    }

    /** {@inheritDoc} */
    @Override
    public final TransceiverInterface getIdSource(final int addressLevel)
    {
        Throw.when(addressLevel != 0, IndexOutOfBoundsException.class, "addressLevel must be 0");
        return this.idTransceiver;
    }

    /**
     * Execute one command.
     * @param subscriptionHandlerName String; name of the SubscriptionHandler for which the command is destined
     * @param command Command; the operation to perform
     * @param address Object[]; the address on which to perform the operation
     * @throws RemoteException ...
     */
    public void executeCommand(final String subscriptionHandlerName, final SubscriptionHandler.Command command,
            final Object[] address) throws RemoteException
    {
        
        SubscriptionHandler subscriptionHandler = this.subscriptionHandlerMap.get(subscriptionHandlerName);
        if (null == subscriptionHandler)
        {
            System.err.println("No subscription handler for \"" + subscriptionHandlerName + "\"");
            return;
        }
        subscriptionHandler.executeCommand(command, address);
    }

}
